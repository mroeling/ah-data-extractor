{
  "version": 3,
  "sources": ["../../@aurelia/metadata/src/index.ts", "../../@aurelia/kernel/src/utilities.ts", "../../@aurelia/kernel/src/errors.ts", "../../@aurelia/kernel/src/functions.ts", "../../@aurelia/kernel/src/di.registration.ts", "../../@aurelia/kernel/src/resource.ts", "../../@aurelia/kernel/src/di.container.ts", "../../@aurelia/kernel/src/di.ts", "../../@aurelia/kernel/src/platform.ts", "../../@aurelia/kernel/src/di.resolvers.ts", "../../node_modules/tslib/tslib.es6.js", "../../@aurelia/kernel/src/logger.ts", "../../@aurelia/kernel/src/module-loader.ts", "../../@aurelia/kernel/src/eventaggregator.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/expression-parser/src/ast.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/expression-parser/src/utilities.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/expression-parser/src/ast.visitor.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/expression-parser/src/errors.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/expression-parser/src/expression-parser.ts", "../../@aurelia/template-compiler/src/utilities.ts", "../../@aurelia/template-compiler/src/binding-mode.ts", "../../@aurelia/template-compiler/src/interfaces-template-compiler.ts", "../../@aurelia/template-compiler/src/attribute-mapper.ts", "../../@aurelia/template-compiler/src/errors.ts", "../../@aurelia/template-compiler/src/attribute-pattern.ts", "../../@aurelia/template-compiler/src/utilities-metadata.ts", "../../@aurelia/template-compiler/src/instructions.ts", "../../@aurelia/template-compiler/src/binding-command.ts", "../../node_modules/tslib/tslib.es6.js", "../../@aurelia/template-compiler/src/template-element-factory.ts", "../../@aurelia/template-compiler/src/utilities-dom.ts", "../../@aurelia/template-compiler/src/template-compiler.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/utilities.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/errors.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/scope.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/ast.eval.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/ast.utilities.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/queue.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/interfaces.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/subscriber-batch.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/subscriber-collection.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/collection-length-observer.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/array-observer.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/set-observer.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/map-observer.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/connectable.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/connectable-switcher.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/proxy-observation.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/computed-observer.ts", "../../@aurelia/vite-plugin/node_modules/node_modules/tslib/tslib.es6.js", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/object-property-info.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/computed-decorators.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/dirty-checker.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/primitive-observer.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/property-accessor.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/setter-observer.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/observer-locator.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/observation.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/observable.ts", "../../@aurelia/vite-plugin/node_modules/@aurelia/runtime/src/proxy-decorators.ts", "../../@aurelia/platform/src/index.ts", "../../@aurelia/platform-browser/src/index.ts", "../../node_modules/tslib/tslib.es6.js", "../../@aurelia/runtime-html/src/binding/interfaces-bindings.ts", "../../@aurelia/runtime-html/src/utilities-metadata.ts", "../../@aurelia/runtime-html/src/utilities.ts", "../../@aurelia/runtime-html/src/errors.ts", "../../@aurelia/runtime-html/src/bindable.ts", "../../@aurelia/runtime-html/src/utilities-di.ts", "../../@aurelia/runtime-html/src/resources/resources-shared.ts", "../../@aurelia/runtime-html/src/resources/binding-behavior.ts", "../../@aurelia/runtime-html/src/resources/binding-behaviors/binding-mode.ts", "../../@aurelia/runtime-html/src/resources/binding-behaviors/debounce.ts", "../../@aurelia/runtime-html/src/signaler.ts", "../../@aurelia/runtime-html/src/resources/binding-behaviors/signals.ts", "../../@aurelia/runtime-html/src/resources/binding-behaviors/throttle.ts", "../../@aurelia/runtime-html/src/app-task.ts", "../../@aurelia/runtime-html/src/platform.ts", "../../@aurelia/runtime-html/src/dom.node.ts", "../../@aurelia/runtime-html/src/watch.ts", "../../@aurelia/runtime-html/src/resources/custom-attribute.ts", "../../@aurelia/runtime-html/src/templating/lifecycle-hooks.ts", "../../@aurelia/runtime-html/src/resources/value-converter.ts", "../../@aurelia/runtime-html/src/binding/binding-utils.ts", "../../@aurelia/runtime-html/src/binding/attribute-binding.ts", "../../@aurelia/runtime-html/src/binding/interpolation-binding.ts", "../../@aurelia/runtime-html/src/binding/content-binding.ts", "../../@aurelia/runtime-html/src/binding/let-binding.ts", "../../@aurelia/runtime-html/src/binding/property-binding.ts", "../../@aurelia/runtime-html/src/binding/ref-binding.ts", "../../@aurelia/runtime-html/src/binding/listener-binding.ts", "../../@aurelia/runtime-html/src/templating/view.ts", "../../@aurelia/runtime-html/src/utilities-dom.ts", "../../@aurelia/runtime-html/src/templating/controller.projection.ts", "../../@aurelia/runtime-html/src/binding/spread-binding.ts", "../../@aurelia/runtime-html/src/observation/observation-utils.ts", "../../@aurelia/runtime-html/src/observation/class-attribute-accessor.ts", "../../@aurelia/runtime-html/src/resources/resolvers.ts", "../../@aurelia/runtime-html/src/renderer.ts", "../../@aurelia/runtime-html/src/templating/rendering.ts", "../../@aurelia/runtime-html/src/templating/styles.ts", "../../@aurelia/runtime-html/src/templating/watchers.ts", "../../@aurelia/runtime-html/src/templating/controller.ts", "../../@aurelia/runtime-html/src/dom.ts", "../../@aurelia/runtime-html/src/resources/custom-element.ts", "../../@aurelia/runtime-html/src/app-root.ts", "../../@aurelia/runtime-html/src/aurelia.ts", "../../@aurelia/runtime-html/src/observation/svg-analyzer.ts", "../../@aurelia/runtime-html/src/compiler/attribute-mapper.ts", "../../@aurelia/runtime-html/src/compiler/template-compiler.ts", "../../@aurelia/runtime-html/src/observation/attribute-ns-accessor.ts", "../../@aurelia/runtime-html/src/observation/data-attribute-accessor.ts", "../../@aurelia/runtime-html/src/observation/select-value-observer.ts", "../../@aurelia/runtime-html/src/observation/style-attribute-accessor.ts", "../../@aurelia/runtime-html/src/observation/value-attribute-observer.ts", "../../@aurelia/runtime-html/src/observation/observer-locator.ts", "../../@aurelia/runtime-html/src/observation/checked-observer.ts", "../../@aurelia/runtime-html/src/resources/binding-behaviors/attr.ts", "../../@aurelia/runtime-html/src/resources/binding-behaviors/self.ts", "../../@aurelia/runtime-html/src/resources/binding-behaviors/update-trigger.ts", "../../@aurelia/runtime-html/src/resources/template-controllers/if.ts", "../../@aurelia/runtime-html/src/resources/template-controllers/repeat.ts", "../../@aurelia/runtime-html/src/resources/template-controllers/with.ts", "../../@aurelia/runtime-html/src/resources/template-controllers/switch.ts", "../../@aurelia/runtime-html/src/resources/template-controllers/promise.ts", "../../@aurelia/runtime-html/src/resources/custom-attributes/focus.ts", "../../@aurelia/runtime-html/src/resources/template-controllers/portal.ts", "../../@aurelia/runtime-html/src/resources/custom-elements/au-slot.ts", "../../@aurelia/runtime-html/src/resources/custom-elements/au-compose.ts", "../../@aurelia/runtime-html/src/resources/value-converters/sanitize.ts", "../../@aurelia/runtime-html/src/resources/custom-attributes/show.ts", "../../@aurelia/runtime-html/src/configuration.ts", "../../@aurelia/runtime-html/src/templating/children.ts", "../../aurelia/src/index.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * TODO: add description.\n * References:\n * - https://github.com/tc39/proposal-decorator-metadata\n * - https://github.com/microsoft/TypeScript/issues/55788\n */\nexport function initializeTC39Metadata() {\n  // We need the any-coercion here because the metadata in Symbol is marked as unique symbol.\n  // And the symbol we are creating here is not assignable to the unique symbol.\n  // More info: https://github.com/Microsoft/TypeScript/issues/23388\n  (Symbol as any).metadata ??= Symbol.for(\"Symbol.metadata\");\n}\n\nexport const Metadata = {\n  get<T>(key: string, type: any): T | undefined {\n    return type[Symbol.metadata]?.[key];\n  },\n  define(value: any, type: any,...keys: string[]): void {\n    // Define metadata on the type, when absent.\n    // Note that TS also does exactly that when decorators are used.\n    // This avoids the problem of children inheriting and overwriting metadata from their parents.\n    let metadata = Object.getOwnPropertyDescriptor(type, Symbol.metadata)?.value;\n    if (metadata == null) {\n      Object.defineProperty(type, Symbol.metadata, { value: metadata = Object.create(null), enumerable: true, configurable: true, writable: true });\n    }\n    const length = keys.length;\n    switch (length) {\n      case 0: throw new Error('At least one key must be provided');\n      case 1: metadata[keys[0]] = value; return;\n      case 2: metadata[keys[0]] = metadata[keys[1]] = value; return;\n      default: {\n        for (let i = 0; i < length; ++i) {\n          metadata[keys[i]] = value;\n        }\n        return;\n      }\n    }\n  },\n  has(key: string, type: any): boolean {\n    const metadata = type[Symbol.metadata];\n    return metadata == null\n      ? false\n      : key in metadata;\n  },\n  delete(key: string, type: any): void {\n    const metadata = type[Symbol.metadata];\n    if (metadata == null) return;\n    Reflect.deleteProperty(metadata, key);\n    return;\n  },\n};\n", "import { Metadata } from '@aurelia/metadata';\n\n/** @internal */ export const objectFreeze = Object.freeze;\n/** @internal */ export const objectAssign = Object.assign;\n/** @internal */ export const safeString = String;\n/** @internal */ export const getMetadata = Metadata.get;\n/** @internal */ export const hasMetadata = Metadata.has;\n/** @internal */ export const defineMetadata = Metadata.define;\n\n/**\n * Returns true if the value is a Promise via checking if it's an instance of Promise.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isPromise = <T>(v: unknown): v is Promise<T> => v instanceof Promise;\n\n/**\n * Returns true if the value is an Array via checking if it's an instance of Array.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isArray = <T>(v: unknown): v is T[] => v instanceof Array;\n\n/**\n * Returns true if the value is a Set via checking if it's an instance of Set.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isSet = <T>(v: unknown): v is Set<T> => v instanceof Set;\n\n/**\n * Returns true if the value is a Map via checking if it's an instance of Map.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages for better size optimization\n */\nexport const isMap = <T, K>(v: unknown): v is Map<T, K> => v instanceof Map;\n\n/**\n * Returns true if the value is an object via checking if it's an instance of Object.\n * This does not work for objects across different realms (e.g., iframes).\n * An utility to be shared among core packages only for better size optimization\n *\n * This is semi private to core packages and applications should not depend on this.\n */\nexport const isObject = (v: unknown): v is object => v instanceof Object;\n\n/**\n * IMPORTANT: This is semi private to core packages and applications should not depend on this.\n *\n * Determine whether a value is an object.\n *\n * Uses `typeof` to guarantee this works cross-realm, which is where `instanceof Object` might fail.\n *\n * Some environments where these issues are known to arise:\n * - same-origin iframes (accessing the other realm via `window.top`)\n * - `jest`.\n *\n * The exact test is:\n * ```ts\n * typeof value === 'object' && value !== null || typeof value === 'function'\n * ```\n *\n * @param value - The value to test.\n * @returns `true` if the value is an object, otherwise `false`.\n * Also performs a type assertion that defaults to `value is Object | Function` which, if the input type is a union with an object type, will infer the correct type.\n * This can be overridden with the generic type argument.\n *\n * @example\n *\n * ```ts\n * class Foo {\n *   bar = 42;\n * }\n *\n * function doStuff(input?: Foo | null) {\n *   input.bar; // Object is possibly 'null' or 'undefined'\n *\n *   // input has an object type in its union (Foo) so that type will be extracted for the 'true' condition\n *   if (isObject(input)) {\n *     input.bar; // OK (input is now typed as Foo)\n *   }\n * }\n *\n * function doOtherStuff(input: unknown) {\n *   input.bar; // Object is of type 'unknown'\n *\n *   // input is 'unknown' so there is no union type to match and it will default to 'Object | Function'\n *   if (isObject(input)) {\n *     input.bar; // Property 'bar' does not exist on type 'Object | Function'\n *   }\n *\n *   // if we know for sure that, if input is an object, it must be a specific type, we can explicitly tell the function to assert that for us\n *   if (isObject<Foo>(input)) {\n *    input.bar; // OK (input is now typed as Foo)\n *   }\n * }\n * ```\n *\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isObjectOrFunction<T extends object = Object | Function>(value: unknown): value is T {\n  return typeof value === 'object' && value !== null || typeof value === 'function';\n}\n\n/**\n * Returns true if the value is a function\n * An utility to be shared among core packages for better size optimization\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const isFunction = <T extends Function>(v: unknown): v is T => typeof v === 'function';\n\n/**\n * Returns true if the value is a string\n * An utility to be shared among core packages for better size optimization\n */\nexport const isString = (v: unknown): v is string => typeof v === 'string';\n\n/**\n * Returns true if the value is a symbol\n * An utility to be shared among core packages for better size optimization\n */\nexport const isSymbol = (v: unknown): v is string => typeof v === 'symbol';\n\n/**\n * Returns true if the value is a number\n * An utility to be shared among core packages for better size optimization\n */\nexport const isNumber = (v: unknown): v is number => typeof v === 'number';\n\n/**\n * Create an object with no prototype to be used as a record\n * An utility to be shared among core packages for better size optimization\n */\nexport const createLookup = <T>() => Object.create(null) as Record<string, T>;\n\n/**\n * Compare the 2 values without pitfall of JS ===, including NaN and +0/-0\n * An utility to be shared among core packages for better size optimization\n */\nexport const areEqual = Object.is;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyFunction = (...args: any) => any;\nexport type FunctionPropNames<T> = {\n  [K in keyof T]: K extends 'constructor' ? never : NonNullable<T[K]> extends AnyFunction ? K : never;\n}[keyof T];\nexport type MaybePromise<T> = T | Promise<T>;\n", "/* eslint-disable prefer-template */\n\nimport { safeString } from './utilities';\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => {\n    const paddedCode = safeString(code).padStart(4, '0');\n    const message = getMessageByCode(code, ...details);\n    const link = `https://docs.aurelia.io/developer-guides/error-messages/0001-to-0023/aur${paddedCode}`;\n    return new Error(`AUR${paddedCode}: ${message}\\\\n\\\\nFor more information, see: ${link}`);\n  }\n  : (code: ErrorNames, ...details: unknown[]) => {\n    const paddedCode = safeString(code).padStart(4, '0');\n    return new Error(`AUR${paddedCode}:${details.map(safeString)}`);\n  };\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  no_registration_for_interface = 1,\n  none_resolver_found = 2,\n  cyclic_dependency = 3,\n  no_factory = 4,\n  invalid_resolver_strategy = 5,\n  unable_auto_register = 6,\n  resource_already_exists = 7,\n  unable_resolve_key = 8,\n  unable_jit_non_constructor = 9,\n  no_jit_intrinsic_type = 10,\n  null_resolver_from_register = 11,\n  no_jit_interface = 12,\n  no_instance_provided = 13,\n  null_undefined_key = 14,\n  no_construct_native_fn = 15,\n  no_active_container_for_resolve = 16,\n  invalid_new_instance_on_interface = 17,\n  event_aggregator_publish_invalid_event_name = 18,\n  event_aggregator_subscribe_invalid_event_name = 19,\n  first_defined_no_value = 20,\n  invalid_module_transform_input = 21,\n  invalid_inject_decorator_usage = 22,\n  resource_key_already_registered = 23,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string>  = {\n  [ErrorNames.no_registration_for_interface]: `No registration for interface: '{{0}}'`,\n  [ErrorNames.none_resolver_found]: `'{{0}}' was registered with \"none\" resolver, are you injecting the right key?`,\n  [ErrorNames.cyclic_dependency]: `Cyclic dependency found: {{0}}`,\n  [ErrorNames.no_factory]: `Resolver for {{0}} returned a null factory`,\n  [ErrorNames.invalid_resolver_strategy]: `Invalid resolver strategy specified: {{0}}. Did you assign an invalid strategy value?`,\n  [ErrorNames.unable_auto_register]: `Unable to autoregister dependency: {{0}}`,\n  [ErrorNames.resource_already_exists]: `Resource key \"{{0}}\" already registered`,\n  [ErrorNames.unable_resolve_key]: `Unable to resolve key: {{0}}`,\n  [ErrorNames.unable_jit_non_constructor]: `Attempted to jitRegister something that is not a constructor: '{{0}}'. Did you forget to register this resource?`,\n  [ErrorNames.no_jit_intrinsic_type]: `Attempted to jitRegister an intrinsic type: \"{{0}}\". Did you forget to add @inject(Key)`,\n  [ErrorNames.null_resolver_from_register]: `Invalid resolver, null/undefined returned from the static register method.`,\n  [ErrorNames.no_jit_interface]: `Attempted to jitRegister an interface: {{0}}`,\n  [ErrorNames.no_instance_provided]: `Cannot call resolve '{{0}}' before calling prepare or after calling dispose.`,\n  [ErrorNames.null_undefined_key]: `Key cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?` +\n    `A common cause is circular dependency with bundler, did you accidentally introduce circular dependency into your module graph?`,\n  [ErrorNames.no_construct_native_fn]: `'{{0}}' is a native function and cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`,\n  [ErrorNames.no_active_container_for_resolve]: `There is not a currently active container to resolve \"{{0}}\". Are you trying to \"new Class(...)\" that has a resolve(...) call?`,\n  [ErrorNames.invalid_new_instance_on_interface]: `Failed to instantiate '{{0}}' via @newInstanceOf/@newInstanceForScope, there's no registration and no default implementation,`\n    + ` or the default implementation does not result in factory for constructing the instances.`,\n  [ErrorNames.event_aggregator_publish_invalid_event_name]: `Invalid channel name or instance: '{{0}}'.`,\n  [ErrorNames.event_aggregator_subscribe_invalid_event_name]: `Invalid channel name or type: {{0}}.`,\n  [ErrorNames.first_defined_no_value]: `No defined value found when calling firstDefined()`,\n  [ErrorNames.invalid_module_transform_input]: `Invalid module transform input: {{0}}. Expected Promise or Object.`,\n  [ErrorNames.invalid_inject_decorator_usage]: `The @inject decorator on the target ('{{0}}') type '{{1}}' is not supported.`,\n  [ErrorNames.resource_key_already_registered]: `Resource key '{{0}}' has already been registered.`,\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    cooked = cooked.replace(`{{${i}}}`, String(details[i]));\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n\n/** @internal */\n// eslint-disable-next-line\nexport const logError = (...args: unknown[]) => (globalThis as any).console.error(...args);\n\n/** @internal */\n// eslint-disable-next-line\nexport const logWarn = (...args: unknown[]) => (globalThis as any).console.warn(...args);\n", "import { ErrorNames, createMappedError } from './errors';\nimport { Constructable, Overwrite } from './interfaces';\nimport { createLookup, isPromise, MaybePromise, objectAssign } from './utilities';\n\n/**\n * Efficiently determine whether the provided property key is numeric\n * (and thus could be an array indexer) or not.\n *\n * Always returns true for values of type `'number'`.\n *\n * Otherwise, only returns true for strings that consist only of positive integers.\n *\n * Results are cached.\n */\nexport const isArrayIndex = (() => {\n  const isNumericLookup: Record<string, boolean> = {};\n  let result: boolean | undefined = false;\n  let length = 0;\n  let ch = 0;\n  let i = 0;\n  return (value: unknown): value is number | string => {\n    switch (typeof value) {\n      case 'number':\n        return value >= 0 && (value | 0) === value;\n      case 'string':\n        result = isNumericLookup[value];\n        if (result !== void 0) {\n          return result;\n        }\n        length = value.length;\n        if (length === 0) {\n          return isNumericLookup[value] = false;\n        }\n        ch = 0;\n        i = 0;\n        for (; i < length; ++i) {\n          ch = value.charCodeAt(i);\n          if (i === 0 && ch === 0x30 && length > 1 /* must not start with 0 */ || ch < 0x30 /* 0 */ || ch > 0x39/* 9 */) {\n            return isNumericLookup[value] = false;\n          }\n        }\n        return isNumericLookup[value] = true;\n      default:\n        return false;\n    }\n  };\n})();\n\n/**\n * Base implementation of camel and kebab cases\n */\nconst baseCase = /*@__PURE__*/(function () {\n  _START_CONST_ENUM();\n  const enum CharKind {\n    none  = 0,\n    digit = 1,\n    upper = 2,\n    lower = 3,\n  }\n  _END_CONST_ENUM();\n\n  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n  const isDigit = objectAssign(createLookup(), {\n    '0': true,\n    '1': true,\n    '2': true,\n    '3': true,\n    '4': true,\n    '5': true,\n    '6': true,\n    '7': true,\n    '8': true,\n    '9': true,\n  } as Record<string, true | undefined>);\n\n  const charToKind = (char: string): CharKind => {\n    if (char === '') {\n      // We get this if we do charAt() with an index out of range\n      return CharKind.none;\n    }\n\n    if (char !== char.toUpperCase()) {\n      return CharKind.lower;\n    }\n\n    if (char !== char.toLowerCase()) {\n      return CharKind.upper;\n    }\n\n    if (isDigit[char] === true) {\n      return CharKind.digit;\n    }\n\n    return CharKind.none;\n  };\n\n  return (input: string, cb: (char: string, sep: boolean) => string): string => {\n    const len = input.length;\n    if (len === 0) {\n      return input;\n    }\n\n    let sep = false;\n    let output = '';\n\n    let prevKind: CharKind;\n\n    let curChar = '';\n    let curKind = CharKind.none;\n\n    let nextChar = input.charAt(0);\n    let nextKind = charToKind(nextChar);\n\n    let i = 0;\n    for (; i < len; ++i) {\n      prevKind = curKind;\n\n      curChar = nextChar;\n      curKind = nextKind;\n\n      nextChar = input.charAt(i + 1);\n      nextKind = charToKind(nextChar);\n\n      if (curKind === CharKind.none) {\n        if (output.length > 0) {\n          // Only set sep to true if it's not at the beginning of output.\n          sep = true;\n        }\n      } else {\n        if (!sep && output.length > 0 && curKind === CharKind.upper) {\n          // Separate UAFoo into UA Foo.\n          // Separate uaFOO into ua FOO.\n          sep = prevKind === CharKind.lower || nextKind === CharKind.lower;\n        }\n\n        output += cb(curChar, sep);\n        sep = false;\n      }\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to camelCase.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert DOM attribute names to ViewModel property names.\n *\n * Results are cached.\n */\nexport const camelCase = /*@__PURE__*/(function () {\n  const cache = createLookup<string | undefined>();\n\n  const callback = (char: string, sep: boolean): string => {\n    return sep ? char.toUpperCase() : char.toLowerCase();\n  };\n\n  return (input: string): string => {\n    let output = cache[input];\n    if (output === void 0) {\n      output = cache[input] = baseCase(input, callback);\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to PascalCase.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert element names to class names for synthetic types.\n *\n * Results are cached.\n */\nexport const pascalCase = /*@__PURE__*/(function () {\n  const cache = createLookup<string | undefined>();\n\n  return (input: string): string => {\n    let output = cache[input];\n    if (output === void 0) {\n      output = camelCase(input);\n      if (output.length > 0) {\n        output = output[0].toUpperCase() + output.slice(1);\n      }\n      cache[input] = output;\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently convert a string to kebab-case.\n *\n * Non-alphanumeric characters are treated as separators.\n *\n * Primarily used by Aurelia to convert ViewModel property names to DOM attribute names.\n *\n * Results are cached.\n */\nexport const kebabCase = /*@__PURE__*/(function () {\n  const cache = createLookup<string | undefined>();\n\n  const callback = (char: string, sep: boolean): string => {\n    return sep ? `-${char.toLowerCase()}` : char.toLowerCase();\n  };\n\n  return (input: string): string => {\n    let output = cache[input];\n    if (output === void 0) {\n      output = cache[input] = baseCase(input, callback);\n    }\n\n    return output;\n  };\n})();\n\n/**\n * Efficiently (up to 10x faster than `Array.from`) convert an `ArrayLike` to a real array.\n *\n * Primarily used by Aurelia to convert DOM node lists to arrays.\n */\nexport const toArray = <T = unknown>(input: ArrayLike<T>): T[] => {\n  // benchmark: http://jsben.ch/xjsyF\n  const length = input.length;\n  const arr = Array(length) as T[];\n  let i = 0;\n  for (; i < length; ++i) {\n    arr[i] = input[i];\n  }\n  return arr;\n};\n\n/**\n * Decorator. Bind the method to the class instance.\n */\nexport const bound = <\n  TThis extends object,\n  TArgs extends unknown[],\n  TReturn>(\n  originalMethod: (this: TThis, ...args: TArgs) => TReturn,\n  context: ClassMethodDecoratorContext<TThis, (this: TThis, ...args: TArgs) => TReturn>,\n): void => {\n  const methodName = context.name as string;\n  context.addInitializer(function (this: TThis) {\n    Reflect.defineProperty(this, methodName, {\n      value: originalMethod.bind(this),\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    });\n  });\n};\n\nexport const mergeArrays = <T>(...arrays: (readonly T[] | undefined)[]): T[] => {\n  const result: T[] = [];\n  let k = 0;\n  const arraysLen = arrays.length;\n  let arrayLen = 0;\n  let array: readonly T[] | undefined;\n  let i = 0;\n  for (; i < arraysLen; ++i) {\n    array = arrays[i];\n    if (array !== void 0) {\n      arrayLen = array.length;\n      let j = 0;\n      for (; j < arrayLen; ++j) {\n        result[k++] = array[j];\n      }\n    }\n  }\n  return result;\n};\n\nexport const firstDefined = <T>(...values: readonly (T | undefined)[]): T => {\n  const len = values.length;\n  let value: T | undefined;\n  let i = 0;\n  for (; len > i; ++i) {\n    value = values[i];\n    if (value !== void 0) {\n      return value;\n    }\n  }\n  throw createMappedError(ErrorNames.first_defined_no_value);\n};\n\n/**\n * Get the prototypes of a class hierarchy. Es6 classes have their parent class as prototype\n * so this will return a list of constructors\n *\n * @example\n * ```ts\n * class A {}\n * class B extends A {}\n *\n * assert.deepStrictEqual(getPrototypeChain(A), [A])\n * assert.deepStrictEqual(getPrototypeChain(B), [B, A])\n * ```\n */\nexport const getPrototypeChain = /*@__PURE__*/(function () {\n  const functionPrototype = Function.prototype;\n  const getPrototypeOf = Object.getPrototypeOf;\n\n  const cache = new WeakMap<Constructable, [Constructable, ...Constructable[]]>();\n  let proto = functionPrototype as Constructable;\n  let i = 0;\n  let chain: [Constructable, ...Constructable[]] | undefined = void 0;\n\n  return function <T extends Constructable> (Type: T): readonly [T, ...Constructable[]] {\n    chain = cache.get(Type);\n    if (chain === void 0) {\n      cache.set(Type, chain = [proto = Type]);\n      i = 0;\n      while ((proto = getPrototypeOf(proto)) !== functionPrototype) {\n        chain[++i] = proto;\n      }\n    }\n    return chain as [T, ...Constructable[]];\n  };\n})();\n\nexport function toLookup<\n  T1 extends {},\n>(\n  obj1: T1,\n): T1;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n): Overwrite<T1, T2>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n): Overwrite<T1, Overwrite<T1, T2>>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n  T4 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n  obj4: T4,\n): Readonly<T1 & T2 & T3 & T4>;\nexport function toLookup<\n  T1 extends {},\n  T2 extends {},\n  T3 extends {},\n  T4 extends {},\n  T5 extends {},\n>(\n  obj1: T1,\n  obj2: T2,\n  obj3: T3,\n  obj4: T4,\n  obj5: T5,\n): Readonly<T1 & T2 & T3 & T4 & T5>;\n/** @internal */\nexport function toLookup(...objs: {}[]): Readonly<{}> {\n  return objectAssign(createLookup(), ...objs);\n}\n\n/**\n * Determine whether the value is a native function.\n *\n * @param fn - The function to check.\n * @returns `true` is the function is a native function, otherwise `false`\n */\nexport const isNativeFunction = /*@__PURE__*/(() => {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const lookup: WeakMap<Function, boolean> = new WeakMap();\n  let isNative = false as boolean | undefined;\n  let sourceText = '';\n  let i = 0;\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  return (fn: Function) => {\n    isNative = lookup.get(fn);\n    if (isNative == null) {\n      i = (sourceText = fn.toString()).length;\n      isNative = i > 28 && sourceText.indexOf('[native code] }') === i - 15;\n      lookup.set(fn, isNative);\n    }\n    return isNative;\n  };\n})();\n\n/**\n * Normalize a potential promise via a callback, to ensure things stay synchronous when they can.\n *\n * If the value is a promise, it is `then`ed before the callback is invoked. Otherwise the callback is invoked synchronously.\n */\nexport const onResolve: {\n  // used for async code paths\n  <TValue, TRet>(\n    maybePromise: Promise<TValue>,\n    resolveCallback: (value: TValue) => MaybePromise<TRet>,\n  ): Promise<TRet>;\n\n  // used for express synchronous only code paths\n  <TValue, TRet>(\n    maybePromise: TValue extends Promise<unknown> ? never : TValue,\n    resolveCallback: (value: TValue) => TRet,\n  ): TRet extends Promise<infer R> ? Promise<R> : TRet;\n\n  // used for mixed code paths\n  <TValue, TRet>(\n    maybePromise: MaybePromise<TValue>,\n    resolveCallback: (value: TValue) => MaybePromise<TRet>,\n  ): MaybePromise<TRet>;\n\n}\n// implementation\n= (maybePromise, resolveCallback) => {\n  if (isPromise(maybePromise)) {\n    return maybePromise.then(resolveCallback);\n  }\n  return resolveCallback(maybePromise);\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction testOnResolve() {\n  /* eslint-disable @typescript-eslint/no-floating-promises, @typescript-eslint/ban-ts-comment */\n  onResolve(Promise.resolve(1), (value) => value === 1);\n  onResolve(1, value => value === 1);\n\n  // @ts-expect-error\n  onResolve(1, value => value === Promise.resolve(1));\n  // @ts-expect-error\n  onResolve(Promise.resolve(1), value => value === Promise.resolve(1));\n\n  const ret = onResolve(Promise.resolve(1), (value) => value === 1);\n  // @ts-expect-error\n  if (ret === false) {\n    // nothing\n  }\n\n  // @ts-expect-error\n  const ret2 = onResolve(1, value => value === Promise.resolve(1));\n  if (ret2 === false) {\n    // nothing\n  }\n\n  type Component = {\n    canDeactivate?: () => boolean | Promise<boolean>;\n  };\n\n  const cmp: Component = {};\n  onResolve(\n    cmp.canDeactivate?.(),\n    canDeactivate => {\n    if (canDeactivate === false) {\n      // nothing\n    }\n  });\n\n  /* eslint-enable @typescript-eslint/no-floating-promises, @typescript-eslint/ban-ts-comment */\n}\n\n/**\n * Normalize an array of potential promises, to ensure things stay synchronous when they can.\n *\n * If exactly one value is a promise, then that promise is returned.\n *\n * If more than one value is a promise, a new `Promise.all` is returned.\n *\n * If none of the values is a promise, nothing is returned, to indicate that things can stay synchronous.\n */\nexport const onResolveAll = (...maybePromises: unknown[]): void | Promise<void> => {\n  let maybePromise: unknown = void 0;\n  let firstPromise: unknown = void 0;\n  let promises: unknown[] | undefined = void 0;\n  let i = 0;\n  // eslint-disable-next-line\n  let ii = maybePromises.length;\n  for (; i < ii; ++i) {\n    maybePromise = maybePromises[i];\n    if (isPromise(maybePromise = maybePromises[i])) {\n      if (firstPromise === void 0) {\n        firstPromise = maybePromise;\n      } else if (promises === void 0) {\n        promises = [firstPromise, maybePromise];\n      } else {\n        promises.push(maybePromise);\n      }\n    }\n  }\n\n  if (promises === void 0) {\n    return firstPromise as void | Promise<void>;\n  }\n  return Promise.all(promises) as unknown as Promise<void>;\n};\n", "import {\n  type Key,\n  IRegistration,\n  Resolver,\n  ResolverStrategy,\n  type ResolveCallback,\n  type Resolved,\n  type IRegistry,\n  type IContainer,\n  IResolver,\n  ParameterizedRegistry,\n  InterfaceSymbol,\n} from './di';\nimport { Constructable } from './interfaces';\n\n/** @internal */\nexport const instanceRegistration = <T>(key: Key, value: T): IRegistration<T> =>\n  new Resolver(key, ResolverStrategy.instance, value);\n\n/** @internal */\nexport const singletonRegistration = <T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> =>\n  new Resolver(key, ResolverStrategy.singleton, value);\n\n/** @internal */\nexport const transientRegistation = <T extends Constructable>(key: Key, value: T): IRegistration<InstanceType<T>> =>\n  new Resolver(key, ResolverStrategy.transient, value);\n\n/** @internal */\nexport const callbackRegistration = <T>(key: Key, callback: ResolveCallback<T>): IRegistration<Resolved<T>> =>\n  new Resolver(key, ResolverStrategy.callback, callback);\n\n/** @internal */\nexport const cachedCallbackRegistration = <T>(key: Key, callback: ResolveCallback<T>): IRegistration<Resolved<T>> =>\n  new Resolver(key, ResolverStrategy.callback, cacheCallbackResult(callback));\n\n/** @internal */\nexport const aliasToRegistration = <T>(originalKey: T, aliasKey: Key): IRegistration<Resolved<T>> =>\n  new Resolver(aliasKey, ResolverStrategy.alias, originalKey);\n\n/** @internal */\nexport const deferRegistration = (key: Key, ...params: unknown[]): IRegistry =>\n  new ParameterizedRegistry(key, params);\n\ntype ResolverLookup = WeakMap<IResolver, unknown>;\nconst containerLookup = new WeakMap<IContainer, ResolverLookup>();\n\n/** @internal */\nexport const cacheCallbackResult = <T>(fun: ResolveCallback<T>): ResolveCallback<T> => {\n  return (handler: IContainer, requestor: IContainer, resolver: IResolver): T => {\n    let resolverLookup = containerLookup.get(handler);\n    if (resolverLookup === void 0) {\n      containerLookup.set(handler, resolverLookup = new WeakMap());\n    }\n    if (resolverLookup.has(resolver)) {\n      return resolverLookup.get(resolver) as T;\n    }\n    const t = fun(handler, requestor, resolver);\n    resolverLookup.set(resolver, t);\n    return t;\n  };\n};\n\n/**\n * you can use the resulting {@linkcode IRegistration} of any of the factory methods\n * to register with the container, e.g.\n * ```\n * class Foo {}\n * const container = DI.createContainer();\n * container.register(Registration.instance(Foo, new Foo()));\n * container.get(Foo);\n * ```\n */\nexport const Registration = {\n  /**\n   * allows you to pass an instance.\n   * Every time you request this {@linkcode Key} you will get this instance back.\n   * ```\n   * Registration.instance(Foo, new Foo()));\n   * ```\n   *\n   * @param key - key to register the instance with\n   * @param value - the instance associated with the key\n   */\n  instance: instanceRegistration,\n  /**\n   * Creates an instance from the class.\n   * Every time you request this {@linkcode Key} you will get the same one back.\n   * ```\n   * Registration.singleton(Foo, Foo);\n   * ```\n   *\n   * @param key - key to register the singleton class with\n   * @param value - the singleton class to instantiate when a container resolves the associated key\n   */\n  singleton: singletonRegistration,\n  /**\n   * Creates an instance from a class.\n   * Every time you request this {@linkcode Key} you will get a new instance.\n   * ```\n   * Registration.instance(Foo, Foo);\n   * ```\n   *\n   * @param key - key to register the transient class with\n   * @param value - the class to instantiate when a container resolves the associated key\n   */\n  transient: transientRegistation,\n  /**\n   * Creates an instance from the method passed.\n   * Every time you request this {@linkcode Key} you will get a new instance.\n   * ```\n   * Registration.callback(Foo, () => new Foo());\n   * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - key to register the callback with\n   * @param callback - the callback to invoke when a container resolves the associated key\n   */\n  callback: callbackRegistration,\n  /**\n   * Creates an instance from the method passed.\n   * On the first request for the {@linkcode Key} your callback is called and returns an instance.\n   * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.\n   * If you pass the same {@linkcode Registration} to another container the same cached value will be used.\n   * Should all references to the resolver returned be removed, the cache will expire.\n   * ```\n   * Registration.cachedCallback(Foo, () => new Foo());\n   * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));\n   * ```\n   *\n   * @param key - key to register the cached callback with\n   * @param callback - the cache callback to invoke when a container resolves the associated key\n   */\n  cachedCallback: cachedCallbackRegistration,\n  /**\n   * creates an alternate {@linkcode Key} to retrieve an instance by.\n   * Returns the same scope as the original {@linkcode Key}.\n   * ```\n   * Register.singleton(Foo, Foo)\n   * Register.aliasTo(Foo, MyFoos);\n   *\n   * container.getAll(MyFoos) // contains an instance of Foo\n   * ```\n   *\n   * @param originalKey - the real key to resolve the get call from a container\n   * @param aliasKey - the key that a container allows to resolve the real key associated\n   */\n  aliasTo: aliasToRegistration,\n  /**\n   * @internal\n   * @param key - the key to register a defer registration\n   * @param params - the parameters that should be passed to the resolution of the key\n   */\n  defer: deferRegistration,\n};\n\nexport const createImplementationRegister = function<T extends Key>(key: InterfaceSymbol<T>) {\n  return function register<C extends Constructable>(this: C, container: IContainer) {\n    container.register(\n      singletonRegistration(this, this),\n      aliasToRegistration(this, key),\n    );\n  };\n};\n", "import { IContainer } from './di';\nimport { Constructable } from './interfaces';\nimport { defineMetadata, getMetadata, objectFreeze } from './utilities';\n\nexport type StaticResourceType<TDef extends object = object> = {\n  readonly aliases?: string[];\n  readonly $au?: PartialResourceDefinition<{\n    type: string;\n  } & TDef>;\n};\n\nexport type ResourceType<\n  TUserType extends Constructable = Constructable,\n  TResInstance extends {} = {},\n  TResType extends {} = {},\n  TUserInstance extends InstanceType<TUserType> = InstanceType<TUserType>,\n> = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  new (...args: any[]) => TResInstance & TUserInstance\n) & StaticResourceType & TResType & TUserType;\n\nexport type ResourceDefinition<\n  TUserType extends Constructable = Constructable,\n  TResInstance extends {} = {},\n  TDef extends {} = {},\n  TResType extends {} = {},\n  TUserInstance extends InstanceType<TUserType> = InstanceType<TUserType>,\n> = {\n  /**\n   * Unique key to identify the resource.\n   */\n  readonly key: string;\n  /**\n   * A common name for the resource.\n   */\n  readonly name: string;\n  readonly Type: ResourceType<TUserType, TResInstance, TResType, TUserInstance>;\n  readonly aliases?: readonly string[];\n\n  /**\n   * @param aliasName - If provided, the resource will be registered with this alias key.\n   */\n  register(container: IContainer, aliasName?: string): void;\n} & TDef;\n\nexport type PartialResourceDefinition<TDef extends object = object> = {\n  readonly name: string;\n  readonly aliases?: readonly string[];\n} & TDef;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface IResourceKind<TType extends ResourceType, TDef extends ResourceDefinition> {\n  readonly name: string;\n  keyFrom(name: string): string;\n}\n\nconst annoBaseName = 'au:annotation';\n/** @internal */\nexport const getAnnotationKeyFor = (name: string, context?: string): string => {\n  if (context === void 0) {\n    return `${annoBaseName}:${name}`;\n  }\n\n  return `${annoBaseName}:${name}:${context}`;\n};\n/** @internal */\nexport const appendAnnotation = (target: Constructable, key: string): void => {\n  const keys = getMetadata<string[]>(annoBaseName, target);\n  if (keys === void 0) {\n    defineMetadata([key], target, annoBaseName);\n  } else {\n    keys.push(key);\n  }\n};\n\nconst annotation = /*@__PURE__*/ objectFreeze({\n  name: 'au:annotation',\n  appendTo: appendAnnotation,\n  set(target: Constructable, prop: string, value: unknown): void {\n    defineMetadata(value, target, getAnnotationKeyFor(prop));\n  },\n  get: (target: Constructable, prop: string): unknown => getMetadata(getAnnotationKeyFor(prop), target),\n  getKeys(target: Constructable): readonly string[] {\n    let keys = getMetadata<string[]>(annoBaseName, target);\n    if (keys === void 0) {\n      defineMetadata(keys = [], target, annoBaseName);\n    }\n    return keys;\n  },\n  isKey: (key: string): boolean  => key.startsWith(annoBaseName),\n  keyFor: getAnnotationKeyFor,\n});\n\nexport const resourceBaseName = 'au:resource';\n/**\n * Builds a resource key from the provided parts.\n */\nexport const getResourceKeyFor = (type: string, name?: string, context?: string): string => {\n  if (name == null) {\n    return `${resourceBaseName}:${type}`;\n  }\n  if (context == null) {\n    return `${resourceBaseName}:${type}:${name}`;\n  }\n\n  return `${resourceBaseName}:${type}:${name}:${context}`;\n};\n\nexport const Protocol = {\n  annotation,\n};\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n/**\n * The order in which the values are checked:\n * 1. Annotations (usually set by decorators) have the highest priority; they override the definition as well as static properties on the type.\n * 2. Definition properties (usually set by the customElement decorator object literal) come next. They override static properties on the type.\n * 3. Static properties on the type come last. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)\n * 4. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromAnnotationOrDefinitionOrTypeOrDefault<\n  TDef extends PartialResourceDefinition,\n  K extends keyof TDef,\n>(\n  name: K,\n  def: TDef,\n  Type: Constructable,\n  getDefault: () => Required<TDef>[K],\n): Required<TDef>[K] {\n  let value = getMetadata<TDef[K] | undefined>(getAnnotationKeyFor(name as string), Type);\n  if (value === void 0) {\n    value = def[name];\n    if (value === void 0) {\n      value = (Type as Constructable & TDef)[name] as TDef[K] | undefined;\n      if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain\n        return getDefault();\n      }\n      return value;\n    }\n    return value;\n  }\n  return value;\n}\n\n/**\n * The order in which the values are checked:\n * 1. Annotations (usually set by decorators) have the highest priority; they override static properties on the type.\n * 2. Static properties on the typ. Note that this does not look up the prototype chain (bindables are an exception here, but we do that differently anyway)\n * 3. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromAnnotationOrTypeOrDefault<T, K extends keyof T, V>(\n  name: K,\n  Type: T,\n  getDefault: () => V,\n): V {\n  let value = getMetadata<V>(getAnnotationKeyFor(name as string), Type);\n  if (value === void 0) {\n    value = Type[name] as unknown as V;\n    if (value === void 0 || !hasOwn.call(Type, name)) { // First just check the value (common case is faster), but do make sure it doesn't come from the proto chain\n      return getDefault();\n    }\n    return value;\n  }\n  return value;\n}\n\n/**\n * The order in which the values are checked:\n * 1. Definition properties.\n * 2. The default property that is provided last. The function is only called if the default property is needed\n */\nexport function fromDefinitionOrDefault<\n  TDef extends PartialResourceDefinition,\n  K extends keyof TDef,\n>(\n  name: K,\n  def: TDef,\n  getDefault: () => Required<TDef>[K],\n): Required<TDef>[K] {\n  const value = def[name];\n  if (value === void 0) {\n    return getDefault();\n  }\n  return value;\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any */\nimport {\n  IContainer,\n  InterfaceSymbol,\n  Resolver,\n  ResolverStrategy,\n  getDependencies,\n  type IContainerConfiguration,\n  type IFactory,\n  type IRegistry,\n  type IResolver,\n  type Key,\n  type RegisterSelf,\n  type Resolved,\n  type Transformer,\n  IDisposableResolver,\n} from './di';\nimport { aliasToRegistration, singletonRegistration } from './di.registration';\nimport type {\n  IAllResolver,\n  IFactoryResolver,\n  ILazyResolver,\n  INewInstanceResolver,\n  IOptionalResolver,\n  IResolvedFactory,\n  IResolvedLazy,\n} from './di.resolvers';\nimport { ErrorNames, createMappedError, logError } from './errors';\nimport { isNativeFunction } from './functions';\nimport { type Class, type Constructable } from './interfaces';\nimport { emptyArray } from './platform';\nimport { ResourceDefinition, StaticResourceType, resourceBaseName, type ResourceType } from './resource';\nimport { getMetadata, isFunction, isObjectOrFunction, isString } from './utilities';\n\nexport const registrableMetadataKey = Symbol.for('au:registrable');\nexport const DefaultResolver = {\n  none(key: Key): IResolver {\n    throw createMappedError(ErrorNames.none_resolver_found, key);\n  },\n  singleton: (key: Key): IResolver => new Resolver(key, ResolverStrategy.singleton, key),\n  transient: (key: Key): IResolver => new Resolver(key, ResolverStrategy.transient, key),\n};\n\nexport class ContainerConfiguration implements IContainerConfiguration {\n  public static readonly DEFAULT: ContainerConfiguration = ContainerConfiguration.from({});\n\n  private constructor(\n    public readonly inheritParentResources: boolean,\n    public readonly defaultResolver: (\n      key: Key,\n      handler: IContainer\n    ) => IResolver\n  ) {}\n\n  public static from(config?: IContainerConfiguration): ContainerConfiguration {\n    if (\n      config === void 0 ||\n      config === ContainerConfiguration.DEFAULT\n    ) {\n      return ContainerConfiguration.DEFAULT;\n    }\n    return new ContainerConfiguration(\n      config.inheritParentResources ?? false,\n      config.defaultResolver ?? DefaultResolver.singleton,\n    );\n  }\n}\n\n/** @internal */\nexport const createContainer = (config?: Partial<IContainerConfiguration>): IContainer => new Container(null, ContainerConfiguration.from(config));\n\nconst InstrinsicTypeNames = new Set<string>('Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet'.split(' '));\n// const factoryKey = 'di:factory';\n// const factoryAnnotationKey = Protocol.annotation.keyFor(factoryKey);\nlet containerId = 0;\n\nlet currentContainer: IContainer | null = null;\n\n/** @internal */\nexport class Container implements IContainer {\n  public readonly id: number = ++containerId;\n  /** @internal */\n  private _registerDepth: number = 0;\n\n  public get depth(): number {\n    return this._parent === null ? 0 : this._parent.depth + 1;\n  }\n  public readonly root: Container;\n\n  /**\n   * All own resolvers of this container\n   *\n   * @internal\n   */\n  private readonly _resolvers: Map<Key, IResolver>;\n  /**\n   * A map of Factory per Constructor (Type) of this container tree.\n   *\n   * Factories are \"global\" per container tree\n   *\n   * @internal\n   */\n  private readonly _factories: Map<Constructable, Factory>;\n\n  /**\n   * A map of all resources resolver by their key\n   */\n  private res: Record<string, IResolver | undefined>;\n\n  /** @internal */\n  private readonly _disposableResolvers = new Map<Key, IResolver>();\n\n  public get parent(): IContainer | null {\n    return this._parent as (IContainer | null);\n  }\n\n  /** @internal */\n  private readonly _parent: Container | null;\n  /** @internal */\n  private readonly config: ContainerConfiguration;\n\n  public constructor(\n    parent: Container | null,\n    config: ContainerConfiguration\n  ) {\n    this._parent = parent;\n    this.config = config;\n    this._resolvers = new Map();\n    this.res = {};\n\n    if (parent === null) {\n      this.root = this;\n      this._factories = new Map<Constructable, Factory>();\n    } else {\n      this.root = parent.root;\n      this._factories = parent._factories;\n\n      if (config.inheritParentResources) {\n        // todo: when the simplify resource system work is commenced\n        //       this resource inheritance can just be a Object.create() call\n        //       with parent resources as the prototype of the child resources\n        for (const key in parent.res) {\n          this.registerResolver(key, parent.res[key]!);\n        }\n      }\n    }\n\n    this._resolvers.set(IContainer, containerResolver);\n  }\n\n  public register(...params: any[]): IContainer {\n    if (++this._registerDepth === 100) {\n      throw createMappedError(ErrorNames.unable_auto_register, ...params);\n    }\n    let current: IRegistry | Record<string, IRegistry>;\n    let keys: string[];\n    let value: IRegistry;\n    let j: number;\n    let jj: number;\n    let i = 0;\n    // eslint-disable-next-line\n    let ii = params.length;\n    let def: ResourceDefinition;\n\n    for (; i < ii; ++i) {\n      current = params[i];\n      if (!isObjectOrFunction(current)) {\n        continue;\n      }\n      if (isRegistry(current)) {\n        current.register(this);\n      } else if ((def = getMetadata(resourceBaseName, current)!) != null) {\n        def.register(this);\n      } else if (isClass<StaticResourceType>(current)) {\n        const registrable = current[Symbol.metadata]?.[registrableMetadataKey] as IRegistry;\n        if (isRegistry(registrable)) {\n          registrable.register(this);\n        } else if (isString((current).$au?.type)) {\n          const $au = current.$au;\n          const aliases = (current.aliases ?? emptyArray).concat($au.aliases ?? emptyArray);\n          let key = `${resourceBaseName}:${$au.type}:${$au.name}`;\n          if (this.has(key, false)) {\n            if (__DEV__) {\n              // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n              (globalThis as any).console?.warn(createMappedError(ErrorNames.resource_already_exists, key));\n            }\n            continue;\n          }\n          aliasToRegistration(current, key).register(this);\n          if (!this.has(current, false)) {\n            singletonRegistration(current, current).register(this);\n          }\n          j = 0;\n          jj = aliases.length;\n          for (; j < jj; ++j) {\n            key = `${resourceBaseName}:${$au.type}:${aliases[j]}`;\n            if (this.has(key, false)) {\n              if (__DEV__) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n                (globalThis as any).console?.warn(createMappedError(ErrorNames.resource_already_exists, key));\n              }\n              continue;\n            }\n            aliasToRegistration(current, key).register(this);\n          }\n        } else {\n          singletonRegistration(current, current as Constructable).register(this);\n        }\n      } else {\n        keys = Object.keys(current);\n        j = 0;\n        jj = keys.length;\n        for (; j < jj; ++j) {\n          value = current[keys[j]];\n          if (!isObjectOrFunction(value)) {\n            continue;\n          }\n          // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n          if (isRegistry(value)) {\n            value.register(this);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n    --this._registerDepth;\n    return this;\n  }\n\n  public registerResolver<K extends Key, T extends IResolver<K>>(key: K, resolver: T, isDisposable: boolean = false): T {\n    validateKey(key);\n\n    const resolvers = this._resolvers;\n    const result = resolvers.get(key);\n\n    if (result == null) {\n      resolvers.set(key, resolver);\n      if (isResourceKey(key)) {\n        if (this.res[key] !== void 0) {\n          throw createMappedError(ErrorNames.resource_already_exists, key);\n        }\n        this.res[key] = resolver;\n      }\n    } else if (result instanceof Resolver && result._strategy === ResolverStrategy.array) {\n      (result._state as IResolver[]).push(resolver);\n    } else {\n      resolvers.set(key, new Resolver(key, ResolverStrategy.array, [result, resolver]) as IResolver<K>);\n    }\n\n    if (isDisposable) {\n      this._disposableResolvers.set(key, resolver);\n    }\n\n    return resolver;\n  }\n\n  public deregister(key: Key): void {\n    validateKey(key);\n\n    const resolver = this._resolvers.get(key);\n    if (resolver != null) {\n      this._resolvers.delete(key);\n\n      if (isResourceKey(key)) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete this.res[key];\n      }\n\n      if (this._disposableResolvers.has(key)) {\n        (resolver as IDisposableResolver).dispose();\n        this._disposableResolvers.delete(key);\n      }\n    }\n  }\n\n  // public deregisterResolverFor<K extends Key>(key: K, searchAncestors: boolean): void {\n  //   validateKey(key);\n  //   // eslint-disable-next-line @typescript-eslint/no-this-alias\n  //   let current: Container | null = this;\n  //   let resolver: IResolver | undefined;\n  //   while (current != null) {\n  //     resolver = current._resolvers.get(key);\n  //     if (resolver != null) {\n  //       current._resolvers.delete(key);\n  //       break;\n  //     }\n  //     if (current.parent == null) { return; }\n  //     current = searchAncestors ? current.parent : null;\n  //   }\n  //   if (resolver == null) { return; }\n  //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {\n  //     throw createError('Cannot deregister a resolver with array strategy');\n  //   }\n  //   if (this._disposableResolvers.has(resolver as IDisposableResolver<K>)) {\n  //     (resolver as IDisposableResolver<K>).dispose();\n  //   }\n  //   if (isResourceKey(key)) {\n  //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  //     delete this.res[key];\n  //   }\n  // }\n  public registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean {\n    const resolver = this.getResolver(key);\n\n    if (resolver == null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const factory = resolver.getFactory(this);\n\n      if (factory == null) {\n        return false;\n      }\n\n      // This type cast is a bit of a hacky one, necessary due to the duplicity of IResolverLike.\n      // Problem is that that interface's type arg can be of type Key, but the getFactory method only works on\n      // type Constructable. So the return type of that optional method has this additional constraint, which\n      // seems to confuse the type checker.\n      factory.registerTransformer(\n        transformer as unknown as Transformer<Constructable>\n      );\n      return true;\n    }\n\n    return false;\n  }\n\n  public getResolver<K extends Key, T = K>(key: K | Key, autoRegister: boolean = true): IResolver<T> | null {\n    validateKey(key);\n\n    if ((key as unknown as IResolver).resolve !== void 0) {\n      return key as unknown as IResolver;\n    }\n\n    const previousContainer = currentContainer;\n    let current: Container = currentContainer = this;\n    let resolver: IResolver | undefined;\n    let handler: Container;\n\n    try {\n      while (current != null) {\n        resolver = current._resolvers.get(key);\n\n        if (resolver == null) {\n          if (current._parent == null) {\n            handler = (isRegisterInRequester(key as unknown as RegisterSelf<Constructable>)) ? this : current;\n            if (autoRegister) {\n              return this._jitRegister(key, handler);\n            }\n            return null;\n          }\n\n          current = current._parent;\n        } else {\n          return resolver;\n        }\n      }\n    } finally {\n      currentContainer = previousContainer;\n    }\n\n    return null;\n  }\n\n  public has<K extends Key>(key: K, searchAncestors: boolean = false): boolean {\n    return this._resolvers.has(key)\n      || isResourceKey(key) && key in this.res\n      || ((searchAncestors && this._parent?.has(key, true)) ?? false);\n  }\n\n  public get<K extends Key>(key: K): Resolved<K> {\n    validateKey(key);\n\n    if ((key as IResolver).$isResolver) {\n      return (key as IResolver).resolve(this, this);\n    }\n\n    const previousContainer = currentContainer;\n    let current: Container = currentContainer = this;\n    let resolver: IResolver | undefined;\n    let handler: Container;\n    try {\n      while (current != null) {\n        resolver = current._resolvers.get(key);\n\n        if (resolver == null) {\n          if (current._parent == null) {\n            handler = (isRegisterInRequester(key as unknown as RegisterSelf<Constructable>)) ? this : current;\n            resolver = this._jitRegister(key, handler);\n            return resolver.resolve(current, this);\n          }\n          current = current._parent;\n        } else {\n          return resolver.resolve(current, this);\n        }\n      }\n    } finally {\n      currentContainer = previousContainer;\n    }\n\n    throw createMappedError(ErrorNames.unable_resolve_key, key);\n  }\n\n  public getAll<K extends Key>(key: K, searchAncestors: boolean = false): Resolved<K>[] {\n    validateKey(key);\n\n    const previousContainer = currentContainer;\n    const requestor = currentContainer = this;\n    let current: Container | null = requestor;\n    let resolver: IResolver | undefined;\n    let resolutions: Resolved<K>[] = emptyArray;\n\n    try {\n      if (searchAncestors) {\n        while (current != null) {\n          resolver = current._resolvers.get(key);\n          if (resolver != null) {\n            resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));\n          }\n          current = current._parent;\n        }\n        return resolutions;\n      }\n\n      while (current != null) {\n        resolver = current._resolvers.get(key);\n\n        if (resolver == null) {\n          current = current._parent;\n\n          if (current == null) {\n            return emptyArray;\n          }\n        } else {\n          return buildAllResponse(resolver, current, requestor);\n        }\n      }\n    } finally {\n      currentContainer = previousContainer;\n    }\n\n    return emptyArray;\n  }\n\n  public invoke<T extends {}, TDeps extends unknown[] = unknown[]>(Type: Constructable<T>, dynamicDependencies?: TDeps): T {\n    if (isNativeFunction(Type)) {\n      throw createMappedError(ErrorNames.no_construct_native_fn, Type);\n    }\n    const previousContainer = currentContainer;\n    currentContainer = this;\n    if (__DEV__) {\n      let resolvedDeps: unknown[];\n      let dep: Key | undefined;\n\n      try {\n        resolvedDeps = getDependencies(Type).map(_ => this.get(dep = _));\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}, caused by dependency: ${String(dep)}`);\n        currentContainer = previousContainer;\n        throw ex;\n      }\n\n      try {\n        return dynamicDependencies === void 0\n          ? new Type(...resolvedDeps)\n          : new Type(...resolvedDeps, ...dynamicDependencies);\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}`);\n        throw ex;\n      } finally {\n        currentContainer = previousContainer;\n      }\n    }\n    try {\n      return dynamicDependencies === void 0\n        ? new Type(...getDependencies(Type).map(containerGetKey, this))\n        : new Type(...getDependencies(Type).map(containerGetKey, this), ...dynamicDependencies);\n    } finally {\n      currentContainer = previousContainer;\n    }\n  }\n\n  public hasFactory<T extends Constructable>(key: T): boolean {\n    return this._factories.has(key);\n  }\n\n  public getFactory<K extends Constructable>(Type: K): IFactory<K> {\n    let factory = this._factories.get(Type);\n    if (factory === void 0) {\n      if (isNativeFunction(Type)) {\n        throw createMappedError(ErrorNames.no_construct_native_fn, Type);\n      }\n      this._factories.set(Type, factory = new Factory<K>(Type, getDependencies(Type)));\n    }\n    return factory;\n  }\n\n  public registerFactory<K extends Constructable>(key: K, factory: IFactory<K>): void {\n    this._factories.set(key, factory as Factory);\n  }\n\n  public createChild(config?: Partial<IContainerConfiguration>): IContainer {\n    if (config === void 0 && this.config.inheritParentResources) {\n      if (this.config === ContainerConfiguration.DEFAULT) {\n        return new Container(this, this.config);\n      }\n      return new Container(\n        this,\n        ContainerConfiguration.from({\n          ...this.config,\n          inheritParentResources: false,\n        })\n      );\n    }\n    return new Container(this, ContainerConfiguration.from(config ?? this.config));\n  }\n\n  public disposeResolvers(): void {\n    const resolvers = this._resolvers;\n    const disposableResolvers = this._disposableResolvers;\n\n    let disposable: IResolver;\n    let key: Key;\n\n    for ([key, disposable] of disposableResolvers.entries()) {\n      disposable.dispose?.();\n      resolvers.delete(key);\n    }\n    disposableResolvers.clear();\n  }\n\n  public useResources(container: Container): void {\n    const res = container.res;\n    for (const key in res) {\n      this.registerResolver(key, res[key]!);\n    }\n  }\n\n  public find<TResType extends ResourceType>(kind: string, name: string): TResType | null;\n  public find<TResType extends ResourceType>(key: string): TResType | null;\n  public find<TResType extends ResourceType>(keyOrKind: string, name?: string): TResType | null {\n    const key = isString(name) ? `${resourceBaseName}:${keyOrKind}:${name}` : keyOrKind;\n    let container: Container = this;\n    let resolver = container.res[key];\n    if (resolver == null) {\n      container = container.root;\n      resolver = container.res[key];\n    }\n    if (resolver == null) {\n      return null;\n    }\n    return resolver.getFactory?.(container)?.Type as TResType ?? null;\n  }\n\n  public dispose(): void {\n    if (this._disposableResolvers.size > 0) {\n      this.disposeResolvers();\n    }\n    this._resolvers.clear();\n    if (this.root === this) {\n      this._factories.clear();\n      this.res = {};\n    }\n  }\n\n  /** @internal */\n  private _jitRegister(keyAsValue: any, handler: Container): IResolver {\n    const $isRegistry = isRegistry(keyAsValue);\n    if (!isFunction(keyAsValue) && !$isRegistry) {\n      throw createMappedError(ErrorNames.unable_jit_non_constructor, keyAsValue);\n    }\n\n    if (InstrinsicTypeNames.has(keyAsValue.name)) {\n      throw createMappedError(ErrorNames.no_jit_intrinsic_type, keyAsValue);\n    }\n\n    if ($isRegistry) {\n      const registrationResolver = keyAsValue.register(handler, keyAsValue);\n      if (!(registrationResolver instanceof Object) || (registrationResolver as IResolver).resolve == null) {\n        const newResolver = handler._resolvers.get(keyAsValue);\n        if (newResolver != null) {\n          return newResolver;\n        }\n        throw createMappedError(ErrorNames.null_resolver_from_register, keyAsValue);\n      }\n      return registrationResolver as IResolver;\n    }\n\n    // TODO(sayan): remove potential dead code\n    if (keyAsValue.$isInterface) {\n      throw createMappedError(ErrorNames.no_jit_interface, keyAsValue.friendlyName);\n    }\n\n    const resolver = this.config.defaultResolver(keyAsValue, handler);\n    handler._resolvers.set(keyAsValue, resolver);\n    return resolver;\n  }\n}\n\n/** @internal */\nclass Factory<T extends Constructable = any> implements IFactory<T> {\n  private transformers: ((instance: any) => any)[] | null = null;\n  public constructor(\n    public Type: T,\n    private readonly dependencies: Key[],\n  ) { }\n\n  public construct(container: IContainer, dynamicDependencies?: unknown[]): Resolved<T> {\n    const previousContainer = currentContainer;\n    currentContainer = container;\n    let instance: Resolved<T>;\n    /* istanbul ignore next */\n    if (__DEV__) {\n      let resolvedDeps: unknown[];\n      let dep: Key | undefined;\n      try {\n        resolvedDeps = this.dependencies.map(_ => container.get(dep = _));\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}, caused by dependency: ${String(dep)}`);\n        currentContainer = previousContainer;\n        throw ex;\n      }\n\n      try {\n        if (dynamicDependencies === void 0) {\n          instance = new this.Type(...resolvedDeps) as Resolved<T>;\n        } else {\n          instance = new this.Type(...resolvedDeps, ...dynamicDependencies) as Resolved<T>;\n        }\n\n        if (this.transformers == null) {\n          return instance;\n        }\n\n        return this.transformers.reduce(transformInstance, instance);\n      } catch (ex) {\n        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}`);\n        throw ex;\n      } finally {\n        currentContainer = previousContainer;\n      }\n    }\n    try {\n      if (dynamicDependencies === void 0) {\n        instance = new this.Type(...this.dependencies.map(containerGetKey, container)) as Resolved<T>;\n      } else {\n        instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies) as Resolved<T>;\n      }\n\n      if (this.transformers == null) {\n        return instance;\n      }\n\n      return this.transformers.reduce(transformInstance, instance);\n    } finally {\n      currentContainer = previousContainer;\n    }\n  }\n\n  public registerTransformer(transformer: (instance: any) => any): void {\n    (this.transformers ??= []).push(transformer);\n  }\n}\n\nfunction transformInstance<T>(inst: Resolved<T>, transform: (instance: any) => any) {\n  return transform(inst);\n}\n\nfunction validateKey(key: any): void {\n  if (key === null || key === void 0) {\n    throw createMappedError(ErrorNames.null_undefined_key);\n  }\n}\n\nfunction containerGetKey(this: IContainer, d: Key) {\n  return this.get(d);\n}\n\nexport type IResolvedInjection<K extends Key> =\n  K extends IAllResolver<infer R>\n    ? Resolved<R>[]\n    : K extends INewInstanceResolver<infer R>\n      ? Resolved<R>\n      : K extends ILazyResolver<infer R>\n        ? IResolvedLazy<R>\n        : K extends IOptionalResolver<infer R>\n          ? Resolved<R> | undefined\n          : K extends IFactoryResolver<infer R>\n            ? IResolvedFactory<R>\n            : K extends IResolver<infer R>\n              ? Resolved<R>\n              : K extends [infer R1 extends Key, ...infer R2]\n                ? [IResolvedInjection<R1>, ...IResolvedInjection<R2>]\n                : K extends InterfaceSymbol<infer T>\n                  ? T\n                  : Resolved<K>;\n\n/**\n * Retrieve the resolved value of a key, or values of a list of keys from the currently active container.\n *\n * Calling this without an active container will result in an error.\n */\nexport function resolve<K extends Key>(key: K): IResolvedInjection<K>;\nexport function resolve<K extends Key[]>(...keys: K): IResolvedInjection<K>;\nexport function resolve<K extends Key, A extends K[]>(...keys: A): Resolved<K> | Resolved<K>[] {\n  if (currentContainer == null) {\n    throw createMappedError(ErrorNames.no_active_container_for_resolve, ...keys);\n  }\n  /* istanbul ignore next */\n  if (__DEV__) {\n    if (keys.length === 1) {\n      try {\n        return currentContainer.get(keys[0]);\n      } catch (ex) {\n        logError(`[DEV:aurelia] resolve() call error for: ${String(keys[0])}`);\n        throw ex;\n      }\n    } else {\n      let key: Key | undefined;\n      try {\n        return keys.map(_ => currentContainer!.get(key = _));\n      } catch (ex) {\n        logError(`[DEV:aurelia] resolve() call error for: ${String(key)}`);\n        throw ex;\n      }\n    }\n  }\n  return keys.length === 1\n    ? currentContainer.get(keys[0])\n    : keys.map(containerGetKey, currentContainer);\n}\n\nconst buildAllResponse = (resolver: IResolver, handler: IContainer, requestor: IContainer): any[] => {\n  if (resolver instanceof Resolver && resolver._strategy === ResolverStrategy.array) {\n    const state = resolver._state as IResolver[];\n    const ii = state.length;\n    const results = Array(ii);\n    let i = 0;\n\n    for (; i < ii; ++i) {\n      results[i] = state[i].resolve(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n};\n\nconst containerResolver: IResolver = {\n  $isResolver: true,\n  resolve(handler: IContainer, requestor: IContainer): IContainer {\n    return requestor;\n  }\n};\n\nconst isRegistry = (obj: IRegistry | Record<string, IRegistry>): obj is IRegistry =>\n  isFunction(obj?.register);\n\nconst isSelfRegistry = <T extends Constructable>(obj: RegisterSelf<T>): obj is RegisterSelf<T> =>\n  isRegistry(obj) && typeof obj.registerInRequestor === 'boolean';\n\nconst isRegisterInRequester = <T extends Constructable>(obj: RegisterSelf<T>): obj is RegisterSelf<T> =>\n  isSelfRegistry(obj) && obj.registerInRequestor;\n\nconst isClass = <T>(obj: unknown): obj is Class<any, T> =>\n  (obj as { prototype: object }).prototype !== void 0;\n\nconst isResourceKey = (key: Key): key is string =>\n  isString(key) && key.indexOf(':') > 0;\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\nimport { initializeTC39Metadata } from '@aurelia/metadata';\n\nimport { isArrayIndex } from './functions';\nimport { createContainer } from './di.container';\nimport { Constructable, IDisposable } from './interfaces';\nimport { getAnnotationKeyFor, ResourceType } from './resource';\nimport { defineMetadata, getMetadata, isFunction, isString } from './utilities';\nimport { singletonRegistration, cacheCallbackResult, transientRegistation } from './di.registration';\nimport { ErrorNames, createMappedError } from './errors';\nimport type { IAllResolver, ICallableResolver, IFactoryResolver, ILazyResolver, INewInstanceResolver, IOptionalResolver, IResolvedFactory, IResolvedLazy } from './di.resolvers';\n\nexport type ResolveCallback<T = any> = (handler: IContainer, requestor: IContainer, resolver: IResolver<T>) => T;\n\nexport interface InterfaceSymbol<K = any> {\n  // We can activate decorator if the argument decorator proposal will be standardized by TC39 (https://github.com/tc39/proposal-class-method-parameter-decorators)\n  // (target: Injectable | AbstractInjectable, property: string | symbol | undefined, index?: number): void;\n  $isInterface: boolean;\n  friendlyName?: string;\n  register?(container: IContainer, key?: K): IResolver<K>;\n  toString?(): string;\n}\n\n// This interface exists only to break a circular type referencing issue in the IServiceLocator interface.\n// Otherwise IServiceLocator references IResolver, which references IContainer, which extends IServiceLocator.\ninterface IResolverLike<C, K = any> {\n  readonly $isResolver: true;\n  resolve(handler: C, requestor: C): Resolved<K>;\n  getFactory?<T extends K extends Constructable ? IFactory<K> : IFactory<Constructable>>(container: C): T | null;\n}\n\nexport interface IResolver<K = any> extends IResolverLike<IContainer, K>, Partial<IDisposable> { }\nexport interface IDisposableResolver<K = any> extends IResolver<K> {\n  dispose(): void;\n}\n\nexport interface IRegistration<K = any> extends IResolver<K> {\n  register(container: IContainer, key?: Key): IResolver<K>;\n}\n\nexport type Transformer<K> = (instance: Resolved<K>) => Resolved<K>;\n\nexport interface IFactory<T extends Constructable = any> {\n  readonly Type: T;\n  registerTransformer(transformer: Transformer<T>): void;\n  construct(container: IContainer, dynamicDependencies?: unknown[]): Resolved<T>;\n}\n\nexport interface IServiceLocator {\n  readonly root: IServiceLocator;\n  has<K extends Key>(key: K | Key, searchAncestors: boolean): boolean;\n  get<K extends Key>(key: IAllResolver<K>): Resolved<K>[];\n  get<K extends Key>(key: INewInstanceResolver<K>): Resolved<K>;\n  get<K extends Key>(key: ILazyResolver<K>): IResolvedLazy<K>;\n  get<K extends Key>(key: IOptionalResolver<K>): Resolved<K> | undefined;\n  get<K extends Key>(key: IFactoryResolver<K>): IResolvedFactory<K>;\n  get<K extends Key>(key: ICallableResolver<K>): Resolved<K>;\n  get<K extends Key>(key: IResolver<K>): Resolved<K>;\n  get<K extends Key>(key: K): Resolved<K>;\n  get<K extends Key>(key: Key): Resolved<K>;\n  get<K extends Key>(key: K | Key): Resolved<K>;\n  getAll<K extends Key>(key: K, searchAncestors?: boolean): Resolved<K>[];\n  getAll<K extends Key>(key: Key, searchAncestors?: boolean): Resolved<K>[];\n  getAll<K extends Key>(key: K | Key, searchAncestors?: boolean): Resolved<K>[];\n}\n\nexport interface IRegistry {\n  register(container: IContainer, ...params: unknown[]): void | IResolver | IContainer;\n}\n\nexport interface IContainer extends IServiceLocator, IDisposable {\n  readonly id: number;\n  readonly root: IContainer;\n  readonly parent: IContainer | null;\n  register(...params: any[]): IContainer;\n  registerResolver<K extends Key, T extends IResolver<K>>(key: K, resolver: T, isDisposable?: boolean): T;\n  // deregisterResolverFor<K extends Key>(key: K, searchAncestors: boolean): void;\n  registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean;\n  getResolver<K extends Key, T = K>(key: K | Key, autoRegister?: boolean): IResolver<T> | null;\n  registerFactory<T extends Constructable>(key: T, factory: IFactory<T>): void;\n  invoke<T extends {}, TDeps extends unknown[] = unknown[]>(key: Constructable<T>, dynamicDependencies?: TDeps): T;\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  hasFactory<T extends Constructable>(key: any): boolean;\n  getFactory<T extends Constructable>(key: T): IFactory<T>;\n  createChild(config?: IContainerConfiguration): IContainer;\n  disposeResolvers(): void;\n  deregister(key: Key): void;\n  /**\n   * Register resources from another container, an API for manually registering resources\n   *\n   * This is a semi private API, apps should avoid using it directly\n   */\n  useResources(container: IContainer): void;\n  find<TResType extends ResourceType>(kind: string, name: string): TResType | null;\n  find<TResType extends ResourceType>(key: string): TResType | null;\n}\n\nexport class ResolverBuilder<K> {\n  public constructor(\n    /** @internal */ private _container: IContainer,\n    /** @internal */ private _key: Key,\n  ) {}\n\n  public instance(value: K): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.instance, value);\n  }\n\n  public singleton(value: Constructable): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.singleton, value);\n  }\n\n  public transient(value: Constructable): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.transient, value);\n  }\n\n  public callback(value: ResolveCallback<K>): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.callback, value);\n  }\n\n  public cachedCallback(value: ResolveCallback<K>): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.callback, cacheCallbackResult(value));\n  }\n\n  public aliasTo(destinationKey: Key): IResolver<K> {\n    return this._registerResolver(ResolverStrategy.alias, destinationKey);\n  }\n\n  /** @internal */\n  private _registerResolver(strategy: ResolverStrategy, state: unknown): IResolver<K> {\n    const { _container: container, _key: key } = this;\n    this._container = this._key = (void 0)!;\n    return container.registerResolver(key, new Resolver(key, strategy, state)) as IResolver<K>;\n  }\n}\n\nexport type RegisterSelf<T extends Constructable> = {\n  register(container: IContainer): IResolver<InstanceType<T>>;\n  registerInRequestor: boolean;\n};\n\nexport type Key = PropertyKey | object | InterfaceSymbol | Constructable | IResolver;\n\nexport type Resolved<K> = (\n  K extends InterfaceSymbol<infer T>\n    ? T\n    : K extends Constructable\n      ? InstanceType<K>\n      : K extends IResolverLike<any, infer T1>\n        ? T1 extends Constructable\n          ? InstanceType<T1>\n          : T1\n        : K\n);\n\nexport type Injectable<T = {}> = Constructable<T> & { inject?: Key[] };\nexport type AbstractInjectable<T = {}> = (abstract new (...args: any[]) => T) & { inject?: Key[] };\n\nconst cloneArrayWithPossibleProps = <T>(source: readonly T[]): T[] => {\n  const clone = source.slice();\n  const keys = Object.keys(source);\n  const len = keys.length;\n  let key: string;\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (!isArrayIndex(key)) {\n      clone[key] = source[key];\n    }\n  }\n  return clone;\n};\n\nexport interface IContainerConfiguration {\n  /**\n   * If `true`, `createChild` will inherit the resource resolvers from its parent container\n   * instead of only from the root container.\n   *\n   * Setting this flag will not implicitly perpetuate it in the child container hierarchy.\n   * It must be explicitly set on each call to `createChild`.\n   */\n  inheritParentResources?: boolean;\n  defaultResolver?(key: Key, handler: IContainer): IResolver;\n}\n\nconst diParamTypesKeys = getAnnotationKeyFor('di:paramtypes');\nconst getAnnotationParamtypes = (Type: Constructable | Injectable): readonly Key[] | undefined => {\n  return getMetadata(diParamTypesKeys, Type);\n};\n\nconst getDesignParamtypes = (Type: Constructable | Injectable): readonly Key[] | undefined =>\n  getMetadata('design:paramtypes', Type);\n\nconst getOrCreateAnnotationParamTypes = (context: DecoratorContext): Key[] => {\n  return (context.metadata[diParamTypesKeys] ??= []) as Key[];\n};\n\n/** @internal */\nexport const getDependencies = (Type: Constructable | Injectable): Key[] => {\n  // Note: Every detail of this getDependencies method is pretty deliberate at the moment, and probably not yet 100% tested from every possible angle,\n  // so be careful with making changes here as it can have a huge impact on complex end user apps.\n  // Preferably, only make changes to the dependency resolution process via a RFC.\n\n  const key = getAnnotationKeyFor('di:dependencies');\n  let dependencies = getMetadata<Key[] | undefined>(key, Type);\n  if (dependencies === void 0) {\n    // Type.length is the number of constructor parameters. If this is 0, it could mean the class has an empty constructor\n    // but it could also mean the class has no constructor at all (in which case it inherits the constructor from the prototype).\n\n    // Non-zero constructor length + no paramtypes means emitDecoratorMetadata is off, or the class has no decorator.\n    // We're not doing anything with the above right now, but it's good to keep in mind for any future issues.\n\n    const inject = (Type as Injectable).inject;\n    if (inject === void 0) {\n      // design:paramtypes is set by tsc when emitDecoratorMetadata is enabled.\n      const designParamtypes = getDesignParamtypes(Type);\n      // au:annotation:di:paramtypes is set by the parameter decorator from DI.createInterface or by @inject\n      const annotationParamtypes = getAnnotationParamtypes(Type);\n      if (designParamtypes === void 0) {\n        if (annotationParamtypes === void 0) {\n          // Only go up the prototype if neither static inject nor any of the paramtypes is defined, as\n          // there is no sound way to merge a type's deps with its prototype's deps\n          const Proto = Object.getPrototypeOf(Type);\n          if (isFunction(Proto) && Proto !== Function.prototype) {\n            dependencies = cloneArrayWithPossibleProps(getDependencies(Proto));\n          } else {\n            dependencies = [];\n          }\n        } else {\n          // No design:paramtypes so just use the au:annotation:di:paramtypes\n          dependencies = cloneArrayWithPossibleProps(annotationParamtypes);\n        }\n      } else if (annotationParamtypes === void 0) {\n        // No au:annotation:di:paramtypes so just use the design:paramtypes\n        dependencies = cloneArrayWithPossibleProps(designParamtypes);\n      } else {\n        // We've got both, so merge them (in case of conflict on same index, au:annotation:di:paramtypes take precedence)\n        dependencies = cloneArrayWithPossibleProps(designParamtypes);\n        let len = annotationParamtypes.length;\n        let auAnnotationParamtype: Key;\n        let i = 0;\n        for (; i < len; ++i) {\n          auAnnotationParamtype = annotationParamtypes[i];\n          if (auAnnotationParamtype !== void 0) {\n            dependencies[i] = auAnnotationParamtype;\n          }\n        }\n\n        const keys = Object.keys(annotationParamtypes);\n        let key: string;\n        i = 0;\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          key = keys[i];\n          if (!isArrayIndex(key)) {\n            dependencies[key] = annotationParamtypes[key];\n          }\n        }\n      }\n    } else {\n      // Ignore paramtypes if we have static inject\n      dependencies = cloneArrayWithPossibleProps(inject);\n    }\n\n    defineMetadata(dependencies, Type, key);\n  }\n\n  return dependencies;\n};\n\n/**\n * @internal\n *\n * @param configureOrName - Use for improving error messaging\n */\nexport const createInterface = <K extends Key>(configureOrName?: string | ((builder: ResolverBuilder<K>) => IResolver<K>), configuror?: (builder: ResolverBuilder<K>) => IResolver<K>): InterfaceSymbol<K> => {\n  const configure = isFunction(configureOrName) ? configureOrName : configuror;\n  const friendlyName = (isString(configureOrName) ? configureOrName : undefined) ?? '(anonymous)';\n\n  const Interface = {\n    // Old code kept with the hope that the argument decorator proposal will be standardized by TC39 (https://github.com/tc39/proposal-class-method-parameter-decorators)\n    // function(_target: Injectable | AbstractInjectable, _property: string | symbol | undefined, _index: number | undefined): void {\n    //    if (target == null || new.target !== undefined) {\n    //     throw createMappedError(ErrorNames.no_registration_for_interface, friendlyName);\n    //    }\n    //    const annotationParamtypes = getOrCreateAnnotationParamTypes(target as Injectable);\n    //    annotationParamtypes[index!] = Interface;\n    // },\n    $isInterface: true,\n    friendlyName: friendlyName,\n    toString: (): string => `InterfaceSymbol<${friendlyName}>`,\n    register: configure != null\n      ? (container: IContainer, key?: Key): IResolver<K> => configure(new ResolverBuilder(container, key ?? Interface))\n      : void 0,\n  };\n  return Interface;\n};\n\nexport const inject = (...dependencies: Key[]): (decorated: unknown, context: DecoratorContext) => void => {\n  return (decorated: unknown, context: DecoratorContext): void => {\n    switch (context.kind) {\n      case 'class': {\n        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);\n        let dep: Key;\n        let i = 0;\n        for (; i < dependencies.length; ++i) {\n          dep = dependencies[i];\n          if (dep !== void 0) {\n            annotationParamtypes[i] = dep;\n          }\n        }\n        break;\n      }\n      case 'field': {\n        const annotationParamtypes: any = getOrCreateAnnotationParamTypes(context);\n        const dep = dependencies[0];\n        if (dep !== void 0) {\n          annotationParamtypes[context.name] = dep;\n        }\n        break;\n      }\n      // TODO(sayan): support getter injection - new feature\n      // TODO:\n      //    support method parameter injection when the class-method-parameter-decorators proposal (https://github.com/tc39/proposal-class-method-parameter-decorators)\n      //    reaches stage 4 and/or implemented by TS.\n      default:\n        throw createMappedError(ErrorNames.invalid_inject_decorator_usage, String(context.name), context.kind);\n    }\n  };\n};\n\nexport const DI = /*@__PURE__*/ (() => {\n  // putting this function inside this IIFE as we wants to call it without triggering side effect\n  initializeTC39Metadata();\n\n  return {\n    createContainer,\n    getDesignParamtypes,\n    // getAnnotationParamtypes,\n    // getOrCreateAnnotationParamTypes,\n    getDependencies: getDependencies,\n    /**\n     * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.\n     * ```ts\n     * const ILogger = DI.createInterface<Logger>('Logger');\n     * container.register(Registration.singleton(ILogger, getSomeLogger()));\n     * const log = container.get(ILogger);\n     * log.info('hello world');\n     * class Foo {\n     *   constructor( @ILogger log: ILogger ) {\n     *     log.info('hello world');\n     *   }\n     * }\n     * ```\n     * you can also build default registrations into your interface.\n     * ```ts\n     * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));\n     * const log = container.get(ILogger);\n     * log.info('hello world');\n     * class Foo {\n     *   constructor( @ILogger log: ILogger ) {\n     *     log.info('hello world');\n     *   }\n     * }\n     * ```\n     * but these default registrations won't work the same with other decorators that take keys, for example\n     * ```ts\n     * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));\n     * class Foo {\n     *   constructor( @optional(MyStr) public readonly str: string ) {\n     *   }\n     * }\n     * container.get(Foo).str; // returns undefined\n     * ```\n     * to fix this add this line somewhere before you do a `get`\n     * ```ts\n     * container.register(MyStr);\n     * container.get(Foo).str; // returns 'somestring'\n     * ```\n     *\n     * - @param configureOrName - supply a string to improve error messaging\n     */\n    createInterface,\n    inject,\n    /**\n     * Registers the `target` class as a transient dependency; each time the dependency is resolved\n     * a new instance will be created.\n     *\n     * @param target - The class / constructor function to register as transient.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     *\n     * @example ```ts\n     * // On an existing class\n     * class Foo { }\n     * DI.transient(Foo);\n     *\n     * // Inline declaration\n     * const Foo = DI.transient(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     */\n    transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T> {\n      target.register = function (container: IContainer): IResolver<InstanceType<T>> {\n        const registration = transientRegistation(target as T, target as T);\n        return registration.register(container, target);\n      };\n      target.registerInRequestor = false;\n      return target as T & RegisterSelf<T>;\n    },\n    /**\n     * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n     * consecutive time the dependency is resolved, the same instance will be returned.\n     *\n     * @param target - The class / constructor function to register as a singleton.\n     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.\n     * @example ```ts\n     * // On an existing class\n     * class Foo { }\n     * DI.singleton(Foo);\n     *\n     * // Inline declaration\n     * const Foo = DI.singleton(class { });\n     * // Foo is now strongly typed with register\n     * Foo.register(container);\n     * ```\n     */\n    singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, options: SingletonOptions = defaultSingletonOptions):\n      T & RegisterSelf<T> {\n      target.register = function (container: IContainer): IResolver<InstanceType<T>> {\n        const registration = singletonRegistration(target, target);\n        return registration.register(container, target);\n      };\n      target.registerInRequestor = options.scoped;\n      return target as T & RegisterSelf<T>;\n    },\n  };\n})();\n\nexport const IContainer = /*@__PURE__*/createInterface<IContainer>('IContainer');\nexport const IServiceLocator = IContainer as unknown as InterfaceSymbol<IServiceLocator>;\n\nfunction transientDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext):\n  T & RegisterSelf<T> {\n  return DI.transient(target);\n}\n/**\n * Registers the decorated class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @example ```ts\n * &#64;transient()\n * class Foo { }\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function transient<T extends Constructable>(): typeof transientDecorator;\n/**\n * Registers the `target` class as a transient dependency; each time the dependency is resolved\n * a new instance will be created.\n *\n * @param target - The class / constructor function to register as transient.\n *\n * @example ```ts\n * &#64;transient()\n * class Foo { }\n * ```\n */\nexport function transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext): T & RegisterSelf<T>;\nexport function transient<T extends Constructable>(target?: T & Partial<RegisterSelf<T>>, context?: ClassDecoratorContext): T & RegisterSelf<T> | typeof transientDecorator {\n  return  target == null ? transientDecorator : transientDecorator(target, context!);\n}\n\ntype SingletonOptions = { scoped: boolean };\nconst defaultSingletonOptions = { scoped: false };\nconst decorateSingleton = DI.singleton;\n\ntype SingletonDecorator = <T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext) => T & RegisterSelf<T>;\n/**\n * Registers the decorated class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @example ```ts\n * &#64;singleton()\n * class Foo { }\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function singleton<T extends Constructable>(): SingletonDecorator;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function singleton<T extends Constructable>(options?: SingletonOptions): SingletonDecorator;\n/**\n * Registers the `target` class as a singleton dependency; the class will only be created once. Each\n * consecutive time the dependency is resolved, the same instance will be returned.\n *\n * @param target - The class / constructor function to register as a singleton.\n *\n * @example ```ts\n * &#64;singleton()\n * class Foo { }\n * ```\n */\nexport function singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>, context: ClassDecoratorContext): T & RegisterSelf<T>;\nexport function singleton<T extends Constructable>(targetOrOptions?: (T & Partial<RegisterSelf<T>>) | SingletonOptions, _context?: ClassDecoratorContext): T & RegisterSelf<T> | SingletonDecorator {\n  return isFunction(targetOrOptions)\n    // The decorator is applied without options. Example: `@singleton()` or `@singleton`\n    ? decorateSingleton(targetOrOptions)\n    : function <T extends Constructable>($target: T, _ctx: ClassDecoratorContext) {\n      return decorateSingleton($target, targetOrOptions);\n    };\n}\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ResolverStrategy {\n  instance = 0,\n  singleton = 1,\n  transient = 2,\n  callback = 3,\n  array = 4,\n  alias = 5,\n}\n_END_CONST_ENUM();\n\n/** @internal */\nexport class Resolver<K extends Key = any> implements IResolver<K> {\n  /** @internal */\n  public _key: Key;\n  /** @internal */\n  public _strategy: ResolverStrategy;\n  /** @internal */\n  public _state: any;\n\n  public get $isResolver(): true { return true; }\n\n  /** @internal */\n  private _resolving: boolean = false;\n\n  public constructor(\n    key: K,\n    strategy: ResolverStrategy,\n    state: any,\n  ) {\n    this._key = key;\n    this._strategy = strategy;\n    this._state = state;\n  }\n\n  /**\n   * When resolving a singleton, the internal state is changed,\n   * so cache the original constructable factory for future requests\n   * @internal\n   */\n  private _cachedFactory: IFactory | null = null;\n\n  public register(container: IContainer, key?: Key): IResolver {\n    return container.registerResolver(key || this._key, this as IResolver<K>);\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): any {\n    switch (this._strategy) {\n      case ResolverStrategy.instance:\n        return this._state;\n      case ResolverStrategy.singleton: {\n        if (this._resolving) {\n          throw createMappedError(ErrorNames.cyclic_dependency, this._state.name);\n        }\n        this._resolving = true;\n        this._state = (this._cachedFactory = handler.getFactory(this._state as Constructable)).construct(requestor);\n        this._strategy = ResolverStrategy.instance;\n        this._resolving = false;\n        return this._state;\n      }\n      case ResolverStrategy.transient: {\n        // Always create transients from the requesting container\n        const factory = handler.getFactory(this._state as Constructable);\n        if (factory === null) {\n          throw createMappedError(ErrorNames.no_factory, this._key);\n        }\n        return factory.construct(requestor);\n      }\n      case ResolverStrategy.callback:\n        return (this._state as ResolveCallback)(handler, requestor, this as IResolver<K>);\n      case ResolverStrategy.array:\n        return (this._state as IResolver[])[0].resolve(handler, requestor);\n      case ResolverStrategy.alias:\n        return requestor.get(this._state);\n      default:\n        throw createMappedError(ErrorNames.invalid_resolver_strategy, this._strategy);\n    }\n  }\n\n  public getFactory<T extends K extends Constructable ? IFactory<K> : IFactory<Constructable>>(container: IContainer): T | null {\n    switch (this._strategy) {\n      case ResolverStrategy.singleton:\n      case ResolverStrategy.transient:\n        return container.getFactory(this._state as Constructable) as T;\n      case ResolverStrategy.alias:\n        return container.getResolver(this._state)?.getFactory?.(container) ?? null;\n      case ResolverStrategy.instance:\n        return this._cachedFactory as T;\n      default:\n        return null;\n    }\n  }\n}\n\n/** @internal */\nexport interface IInvoker<T extends Constructable = any> {\n  invoke(container: IContainer, fn: T, dependencies: Key[]): Resolved<T>;\n  invokeWithDynamicDependencies(\n    container: IContainer,\n    fn: T,\n    staticDependencies: Key[],\n    dynamicDependencies: Key[]\n  ): Resolved<T>;\n}\n\nexport class InstanceProvider<K extends Key> implements IDisposableResolver<K> {\n  /** @internal */ private _instance: Resolved<K> | null;\n  /** @internal */ private readonly _name?: string;\n  /** @internal */ private readonly _Type: Constructable | null;\n\n  public get friendlyName() {\n    return this._name;\n  }\n\n  public constructor(\n    name?: string,\n    /**\n     * if not undefined, then this is the value this provider will resolve to\n     * until overridden by explicit prepare call\n     */\n    instance: Resolved<K> | null = null,\n    Type: Constructable | null = null,\n  ) {\n    this._name = name;\n    this._instance = instance;\n    this._Type = Type;\n  }\n\n  public prepare(instance: Resolved<K>): void {\n    this._instance = instance;\n  }\n\n  public get $isResolver(): true {return true;}\n\n  public resolve(): Resolved<K> {\n    if (this._instance == null) {\n      throw createMappedError(ErrorNames.no_instance_provided, this._name);\n    }\n    return this._instance;\n  }\n\n  public getFactory<T extends K extends Constructable ? IFactory<K> : IFactory<Constructable>>(container: IContainer): T | null {\n    return this._Type == null ? null : container.getFactory(this._Type) as T;\n  }\n\n  public dispose(): void {\n    this._instance = null;\n  }\n}\n\n/**\n * An implementation of IRegistry that delegates registration to a\n * separately registered class. The ParameterizedRegistry facilitates the\n * passing of parameters to the final registry.\n */\nexport class ParameterizedRegistry implements IRegistry {\n  public constructor(\n    private readonly key: Key,\n    private readonly params: unknown[]\n  ) {}\n\n  public register(container: IContainer): void {\n    if (container.has(this.key, true)) {\n      const registry = container.get<IRegistry>(this.key);\n      registry.register(container, ...this.params);\n    } else {\n      container.register(...this.params.filter(x => typeof x === 'object'));\n    }\n  }\n}\n", "import { Platform } from '@aurelia/platform';\nimport { createInterface } from './di';\nimport { objectFreeze } from './utilities';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const emptyArray: any[] = objectFreeze<any>([]);\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const emptyObject: any = objectFreeze({}) as any;\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport function noop(): void {}\n\nexport interface IPlatform extends Platform {}\nexport const IPlatform = /*@__PURE__*/createInterface<IPlatform>('IPlatform');\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { IContainer, IFactory, IRegistry, IResolver, InstanceProvider, InterfaceSymbol, Key, Resolved, inject } from './di';\nimport { createContainer } from './di.container';\nimport { ErrorNames, createMappedError } from './errors';\nimport { Constructable } from './interfaces';\nimport { isFunction, objectAssign, safeString } from './utilities';\n\nexport type ICallableResolver<T> = IResolver<T> & ((...args: unknown[]) => any);\n\n/**\n * ! Semi private API to avoid repetitive work creating resolvers.\n *\n * Naming isn't entirely correct, but it's good enough for internal usage.\n */\nexport function createResolver<T extends Key>(getter: (key: T, handler: IContainer, requestor: IContainer) => any): ((key: T) => ICallableResolver<T>) {\n  return function (key: any) {\n    function Resolver(target: any, context: DecoratorContext): void {\n      inject(Resolver)(target, context);\n    }\n\n    Resolver.$isResolver = true;\n    Resolver.resolve = function (handler: IContainer, requestor: IContainer): any {\n      return getter(key, handler, requestor);\n    };\n\n    return Resolver as ICallableResolver<T>;\n  };\n}\n\n/**\n * Create a resolver that will resolve all values of a key from resolving container\n */\nexport const all = <T extends Key>(key: T, searchAncestors: boolean = false): IAllResolver<T> => {\n  function resolver(decorated: unknown, context: DecoratorContext): void {\n    inject(resolver)(decorated, context);\n  }\n\n  resolver.$isResolver = true;\n  resolver.resolve = (handler: IContainer, requestor: IContainer) => requestor.getAll(key, searchAncestors);\n\n  return resolver as IAllResolver<T>;\n};\nexport type IAllResolver<T> = IResolver<readonly Resolved<T>[]> &\n  // any for decorator\n  ((decorated: unknown, context: DecoratorContext) => any);\n\n/**\n * Create a resolver that will resolve the last instance of a key from the resolving container\n *\n * - @param key [[`Key`]]\n */\nexport const last = <T extends Key>(key: T): IResolver<T | undefined> => ({\n  $isResolver: true,\n  resolve: handler => {\n    const allInstances = handler.getAll(key);\n    return allInstances.length > 0 ? allInstances[allInstances.length - 1] : undefined;\n  }\n});\n\n/**\n * Lazily inject a dependency depending on whether the [[`Key`]] is present at the time of function call.\n *\n * You need to make your argument a function that returns the type, for example\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => number )\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * foo.random(); // throws\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a\n * new [['Math.random()']] number each time.\n * ```ts\n * class Foo {\n *   constructor( @lazy('random') public random: () => random )\n * }\n * container.register(Registration.callback('random', Math.random ));\n * container.get(Foo).random(); // some random number\n * container.get(Foo).random(); // another random number\n * ```\n * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * - @param key [[`Key`]]\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const lazy = /*@__PURE__*/createResolver((key: Key, handler: IContainer, requestor: IContainer) =>  {\n  return () => requestor.get(key);\n}) as <K extends Key>(key: K) => ILazyResolver<K>;\nexport type ILazyResolver<K extends Key = Key> = IResolver<() => K>\n  // type only hack\n  & { __isLazy: undefined }\n  // any is needed for decorator usages\n  & ((...args: unknown[]) => any);\nexport type IResolvedLazy<K> = () => Resolved<K>;\n\n/**\n * Allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example\n * ```ts\n * class Foo {\n *   constructor( @inject('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo); // throws\n * ```\n * would fail\n * ```ts\n * class Foo {\n *   constructor( @optional('mystring') public str: string = 'somestring' )\n * }\n * container.get(Foo).str // somestring\n * ```\n * if you use it without a default it will inject `undefined`, so rember to mark your input type as\n * possibly `undefined`!\n *\n * - @param key: [[`Key`]]\n *\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const optional = /*@__PURE__*/createResolver((key: Key, handler: IContainer, requestor: IContainer) =>  {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return undefined;\n  }\n}) as <K extends Key>(key: K) => IOptionalResolver<K>;\nexport type IOptionalResolver<K extends Key = Key> = IResolver<K | undefined> & {\n  // type only hack\n  __isOptional: undefined;\n  // any is needed for decorator usages\n  (...args: unknown[]): any;\n};\n\n/**\n * ignore tells the container not to try to inject a dependency\n */\nexport const ignore: IResolver<undefined> = /*@__PURE__*/objectAssign((decorated: unknown, context: DecoratorContext): void => {\n  inject(ignore)(decorated, context);\n}, {$isResolver: true, resolve: () => void 0} as const);\n\n/**\n * Inject a function that will return a resolved instance of the [[key]] given.\n * Also supports passing extra parameters to the invocation of the resolved constructor of [[key]]\n *\n * For typings, it's a function that take 0 or more arguments and return an instance. Example:\n * ```ts\n * class Foo {\n *   constructor( @factory(MyService) public createService: (...args: unknown[]) => MyService)\n * }\n * const foo = container.get(Foo); // instanceof Foo\n * const myService_1 = foo.createService('user service')\n * const myService_2 = foo.createService('content service')\n * ```\n *\n * ```ts\n * class Foo {\n *   constructor( @factory('random') public createRandomizer: () => Randomizer)\n * }\n * container.get(Foo).createRandomizer(); // create a randomizer\n * ```\n * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a\n * new instance of Randomizer each time.\n *\n * `@factory` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a\n * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.\n *\n * - @param key [[`Key`]]\n * see { @link DI.createInterface } on interactions with interfaces\n */\nexport const factory = /*@__PURE__*/createResolver((key: any, handler: IContainer, requestor: IContainer) => {\n  return (...args: unknown[]) => handler.getFactory(key).construct(requestor, args);\n}) as <K>(key: K) => IFactoryResolver<K>;\nexport type IFactoryResolver<K = any> = IResolver<K>\n  // type only hack\n  & { __isFactory: undefined }\n  // any is needed for decorator usage\n  & ((...args: unknown[]) => any);\nexport type IResolvedFactory<K> = (...args: unknown[]) => Resolved<K>;\n\n/**\n * Create a resolver that will only resolve if the requesting container has the key pre-registered\n */\nexport const own = /*@__PURE__*/createResolver((key: any, handler: IContainer, requestor: IContainer) => {\n  return requestor.has(key, false) ? requestor.get(key) : void 0;\n}) as <T extends Key>(key: T) => IOptionalResolver<T>;\n\n/**\n * Create a resolver that will resolve a key based on resource semantic (leaf + root + ignore middle layer container)\n * Will resolve at the root level if the key is not registered in the requestor container\n */\nexport const resource = /*@__PURE__*/createResolver((key, handler, requestor) =>\n  requestor.has(key, false)\n    ? requestor.get(key)\n    : requestor.root.get(key)\n) as <K extends Key>(key: K) => ICallableResolver<K>;\n\n/**\n * Create a resolver that will resolve a key based on resource semantic (leaf + root + ignore middle layer container)\n * only if the key is registered either in the requestor container or in the root container\n *\n * Returns `undefined` if the key is not registered in either container\n */\nexport const optionalResource = /*@__PURE__*/createResolver((key, handler, requestor) =>\n  requestor.has(key, false)\n    ? requestor.get(key)\n    : requestor.root.has(key, false)\n      ? requestor.root.get(key)\n      : void 0\n) as <K extends Key>(key: K) => IOptionalResolver<K>;\n\n/**\n * Create a resolver for resolving all registrations of a key with resource semantic (leaf + root + ignore middle layer container)\n */\nexport const allResources = /*@__PURE__*/createResolver((key, handler, requestor) =>\n  // prevent duplicate retrieval\n  requestor === requestor.root\n    ? requestor.getAll(key, false)\n    : requestor.has(key, false)\n      ? requestor.getAll(key, false).concat(requestor.root.getAll(key, false))\n      : requestor.root.getAll(key, false)\n) as <T>(key: T) => IAllResolver<T>;\n\n/**\n * Create a resolver that will resolve a new instance of a key, and register the newly created instance with the requestor container\n */\nexport const newInstanceForScope = /*@__PURE__*/createResolver(\n  (key: any, handler: IContainer, requestor: IContainer) => {\n    const instance = createNewInstance(key, handler, requestor);\n    const instanceProvider = new InstanceProvider<{}>(safeString(key), instance);\n    /**\n     * By default the new instances for scope are disposable.\n     * If need be, we can always enhance the `createNewInstance` to support a 'injection' context, to make a non/disposable registration here.\n     */\n    requestor.registerResolver(key, instanceProvider, true);\n\n    return instance;\n  }) as <K>(key: K) => INewInstanceResolver<K>;\n\n/**\n * Create a resolver that will resolve a new instance of a key\n */\nexport const newInstanceOf = /*@__PURE__*/createResolver(\n  (key: any, handler: IContainer, requestor: IContainer) => createNewInstance(key, handler, requestor)\n) as <K>(key: K) => INewInstanceResolver<K>;\n\nexport type INewInstanceResolver<T> = IResolver<T> & {\n  // type only hack\n  __newInstance: undefined;\n  // any is needed for decorator usage\n  (...args: unknown[]): any;\n};\n\nconst createNewInstance = (key: any, handler: IContainer, requestor: IContainer) => {\n  // 1. if there's a factory registration for the key\n  if (handler.hasFactory(key)) {\n    return handler.getFactory(key).construct(requestor);\n  }\n  // 2. if key is an interface\n  if (isInterface(key)) {\n    const hasDefault = isFunction((key as unknown as IRegistry).register);\n    const resolver = handler.getResolver(key, false) as IResolver<Constructable<typeof key>>;\n    let factory: IFactory | null | undefined;\n    if (resolver == null) {\n      if (hasDefault) {\n        // creating a new container as we do not want to pollute the resolver registry\n        factory = (newInstanceContainer ??= createContainer()).getResolver(key, true)?.getFactory?.(handler);\n      }\n      newInstanceContainer.dispose();\n    } else {\n      factory = resolver.getFactory?.(handler);\n    }\n    // 2.1 and has resolvable factory\n    if (factory != null) {\n      return factory.construct(requestor);\n    }\n    // 2.2 cannot instantiate a dummy interface\n    throw createMappedError(ErrorNames.invalid_new_instance_on_interface, key);\n  }\n  // 3. jit factory, in case of newInstanceOf(SomeClass)\n  return handler.getFactory(key).construct(requestor);\n};\n\nconst isInterface = <K>(key: any): key is InterfaceSymbol<K> => (key as {$isInterface?: boolean})?.$isInterface === true;\n\nlet newInstanceContainer: IContainer;\n", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n", "import { createInterface, IContainer, IRegistry } from './di';\nimport { instanceRegistration, singletonRegistration } from './di.registration';\nimport { bound, toLookup } from './functions';\nimport { Class, Constructable } from './interfaces';\nimport { IPlatform } from './platform';\nimport { getAnnotationKeyFor } from './resource';\nimport { createLookup, defineMetadata, getMetadata, isFunction, objectFreeze } from './utilities';\nimport { resolve } from './di.container';\nimport { all, optional } from './di.resolvers';\n\n/** @internal */ export const trace = 0;\n/** @internal */ export const debug = 1;\n/** @internal */ export const info = 2;\n/** @internal */ export const warn = 3;\n/** @internal */ export const error = 4;\n/** @internal */ export const fatal = 5;\n/** @internal */ export const none = 6;\n\nexport const LogLevel = objectFreeze({\n  /**\n   * The most detailed information about internal app state.\n   *\n   * Disabled by default and should never be enabled in a production environment.\n   */\n  trace,\n  /**\n   * Information that is useful for debugging during development and has no long-term value.\n   */\n  debug,\n  /**\n   * Information about the general flow of the application that has long-term value.\n   */\n  info,\n  /**\n   * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   */\n  warn,\n  /**\n   * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   */\n  error,\n  /**\n   * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   */\n  fatal,\n  /**\n   * No messages should be written.\n   */\n  none,\n} as const);\nexport type LogLevel = typeof LogLevel[keyof typeof LogLevel];\n\n/**\n * Flags to enable/disable color usage in the logging output.\n * - `no-colors`: Do not use ASCII color codes in logging output.\n * - `colors`: Use ASCII color codes in logging output. By default, timestamps and the TRC and DBG prefix are colored grey. INF white, WRN yellow, and ERR and FTL red.\n */\nexport type ColorOptions = 'no-colors' | 'colors';\n\n/**\n * The global logger configuration.\n *\n * Properties on this object can be changed during runtime and will affect logging of all components that are housed under the same root DI container as the logger.\n */\nexport interface ILogConfig {\n  /**\n   * The global color options.\n   */\n  colorOptions: ColorOptions;\n  /**\n   * The global log level. Only log calls with the same level or higher are emitted.\n   */\n  level: LogLevel;\n}\n\ninterface ILoggingConfigurationOptions extends ILogConfig {\n  $console: IConsoleLike;\n  sinks: (Class<ISink> | IRegistry)[];\n}\n\n/**\n * Component that creates log event objects based on raw inputs sent to `ILogger`.\n *\n * To customize what data is sent to the sinks, replace the implementation for this interface with your own.\n *\n * @example\n *\n * ```ts\n * export class MyLogEventFactory {\n *   public createLogEvent(logger: ILogger, logLevel: LogLevel, message: string, optionalParams: unknown[]): ILogEvent {\n *     return {\n *       logLevel,\n *       optionalParams,\n *       toString() {\n *         return `[${logger.scope.join('.')}] ${message} ${optionalParams.join(', ')}`;\n *       }\n *     };\n *   }\n * }\n *\n * container.register(Registration.singleton(ILogEventFactory, MyLogEventFactory));\n * ```\n */\nexport interface ILogEventFactory {\n  /**\n   * Create a log event object based on the input parameters sent to `ILogger`.\n   *\n   * @param logger - The `ILogger` that received the message.\n   * @param logLevel - The `LogLevel` associated with the `ILogger` method that the message was passed into. E.g. `logger.debug` will result in `LogLevel.debug`\n   * @param message - The message (first parameter) that was passed into the logger. If a function was passed into the logger, this will be the return value of that function.\n   * @param optionalParams - Additional optional parameters there were passed into the logger, if any.\n   *\n   * @returns An `ILogEvent` object that, by default, only has a `.toString()` method.\n   *\n   * This is called by the default console sink to get the message to emit to the console.\n   * It could be any object of any shape, as long as the registered sinks understand that shape.\n   */\n  createLogEvent(logger: ILogger, logLevel: LogLevel, message: string | Error, optionalParams: unknown[]): ILogEvent;\n}\n\n/**\n * A logging sink that emits `ILogEvent` objects to any kind of output. This can be the console, a database, a web api, a file, etc.\n *\n * Multiple sinks can be registered, and all events will be emitted to all of them.\n *\n * @example\n * // A buffered file sink that writes once per second:\n *\n * ```ts\n * export class BufferedFileSink {\n *   private readonly buffer: ILogEvent[] = [];\n *\n *   constructor() {\n *     setInterval(() => {\n *       const events = this.buffer.splice(0);\n *       if (events.length > 0) {\n *         fs.appendFileSync('my-log.txt', events.map(e => e.toString()).join('\\n'));\n *       }\n *     }, 1000);\n *   }\n *\n *   public emit(event: ILogEvent): void {\n *     this.buffer.push(event);\n *   }\n * }\n *\n * container.register(Registration.singleton(ISink, BufferedFileSink));\n * ```\n */\nexport interface ISink {\n  /**\n   * Handle the provided `ILogEvent` to the output interface wrapped by this sink.\n   *\n   * @param event - The event object to emit. Built-in sinks will call `.toString()` on the event object but custom sinks can do anything they like with the event.\n   */\n  handleEvent(event: ILogEvent): void;\n}\n\n/**\n * The main interface to the logging API.\n *\n * Inject this as a dependency in your components to add centralized, configurable logging capabilities to your application.\n */\nexport interface ILogger extends DefaultLogger {}\n\nexport const ILogConfig = /*@__PURE__*/createInterface<ILogConfig>('ILogConfig', x => x.instance(new LogConfig('no-colors', warn)));\nexport const ISink = /*@__PURE__*/createInterface<ISink>('ISink');\nexport const ILogEventFactory = /*@__PURE__*/createInterface<ILogEventFactory>('ILogEventFactory', x => x.singleton(DefaultLogEventFactory));\nexport const ILogger = /*@__PURE__*/createInterface<ILogger>('ILogger', x => x.singleton(DefaultLogger));\nexport const ILogScopes = /*@__PURE__*/createInterface<string[]>('ILogScope');\n\ninterface SinkDefinition {\n  handles: Exclude<LogLevel, typeof none>[];\n}\n\nexport const LoggerSink = /*@__PURE__*/objectFreeze({\n  key: getAnnotationKeyFor('logger-sink-handles'),\n  define<TSink extends Constructable<ISink>>(target: TSink, definition: SinkDefinition) {\n    defineMetadata(definition.handles, target, this.key);\n  },\n  getHandles<TSink extends ISink>(target: TSink): Exclude<LogLevel, typeof none>[] | undefined {\n    return getMetadata(this.key, target.constructor);\n  },\n});\n\nexport const sink = (definition: SinkDefinition) => {\n  return <TSink extends Constructable<ISink>>(_target: TSink, context: ClassDecoratorContext<TSink>): void =>\n    context.addInitializer(function (this) {\n      LoggerSink.define(this, definition);\n    });\n};\n\nexport interface IConsoleLike {\n  debug(message: string, ...optionalParams: unknown[]): void;\n  info(message: string, ...optionalParams: unknown[]): void;\n  warn(message: string, ...optionalParams: unknown[]): void;\n  error(message: string, ...optionalParams: unknown[]): void;\n}\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\nexport const format = toLookup({\n  red<T extends string>(str: T): T {\n    return `\\u001b[31m${str}\\u001b[39m` as T;\n  },\n  green<T extends string>(str: T): T {\n    return `\\u001b[32m${str}\\u001b[39m` as T;\n  },\n  yellow<T extends string>(str: T): T {\n    return `\\u001b[33m${str}\\u001b[39m` as T;\n  },\n  blue<T extends string>(str: T): T {\n    return `\\u001b[34m${str}\\u001b[39m` as T;\n  },\n  magenta<T extends string>(str: T): T {\n    return `\\u001b[35m${str}\\u001b[39m` as T;\n  },\n  cyan<T extends string>(str: T): T {\n    return `\\u001b[36m${str}\\u001b[39m` as T;\n  },\n  white<T extends string>(str: T): T {\n    return `\\u001b[37m${str}\\u001b[39m` as T;\n  },\n  grey<T extends string>(str: T): T {\n    return `\\u001b[90m${str}\\u001b[39m` as T;\n  },\n} as const);\n\nexport interface ILogEvent {\n  readonly severity: LogLevel;\n  readonly message: string | Error;\n  readonly optionalParams?: readonly unknown[];\n  readonly scope: readonly string[];\n  readonly colorOptions: ColorOptions;\n  readonly timestamp: number;\n  toString(): string;\n  getFormattedLogInfo(forConsole?: boolean): [string, ...unknown[]];\n}\n\nexport class LogConfig implements ILogConfig {\n  public constructor(\n    public readonly colorOptions: ColorOptions,\n    public readonly level: LogLevel,\n  ) {}\n}\n\nconst getLogLevelString = (function () {\n  const logLevelString = {\n    'no-colors': toLookup({\n      TRC: 'TRC',\n      DBG: 'DBG',\n      INF: 'INF',\n      WRN: 'WRN',\n      ERR: 'ERR',\n      FTL: 'FTL',\n      QQQ: '???',\n    } as const),\n    'colors': toLookup({\n      TRC: format.grey('TRC'),\n      DBG: format.grey('DBG'),\n      INF: format.white('INF'),\n      WRN: format.yellow('WRN'),\n      ERR: format.red('ERR'),\n      FTL: format.red('FTL'),\n      QQQ: format.grey('???'),\n    } as const),\n  } as const;\n\n  return (level: LogLevel, colorOptions: ColorOptions): string => {\n    if (level <= trace) {\n      return logLevelString[colorOptions].TRC;\n    }\n    if (level <= debug) {\n      return logLevelString[colorOptions].DBG;\n    }\n    if (level <= info) {\n      return logLevelString[colorOptions].INF;\n    }\n    if (level <= warn) {\n      return logLevelString[colorOptions].WRN;\n    }\n    if (level <= error) {\n      return logLevelString[colorOptions].ERR;\n    }\n    if (level <= fatal) {\n      return logLevelString[colorOptions].FTL;\n    }\n    return logLevelString[colorOptions].QQQ;\n  };\n})();\n\nconst getScopeString = (scope: readonly string[], colorOptions: ColorOptions): string => {\n  if (colorOptions === 'no-colors') {\n    return scope.join('.');\n  }\n  return scope.map(format.cyan).join('.');\n};\n\nconst getIsoString = (timestamp: number, colorOptions: ColorOptions): string => {\n  if (colorOptions === 'no-colors') {\n    return new Date(timestamp).toISOString();\n  }\n  return format.grey(new Date(timestamp).toISOString());\n};\n\nexport class DefaultLogEvent implements ILogEvent {\n  public constructor(\n    public readonly severity: LogLevel,\n    public readonly message: string | Error,\n    public readonly optionalParams: unknown[],\n    public readonly scope: readonly string[],\n    public readonly colorOptions: ColorOptions,\n    public readonly timestamp: number,\n  ) {}\n\n  public toString(): string {\n    const { severity, message, scope, colorOptions, timestamp } = this;\n\n    if (scope.length === 0) {\n      return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;\n    }\n    return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;\n  }\n\n  public getFormattedLogInfo(forConsole: boolean = false): [string, ...unknown[]] {\n    const { severity, message: messageOrError, scope, colorOptions, timestamp, optionalParams } = this;\n    let error: Error|null = null;\n    let message: string = '';\n    if (forConsole && messageOrError instanceof Error) {\n      error = messageOrError;\n    } else {\n      message = messageOrError as string;\n    }\n\n    const scopeInfo = scope.length === 0 ? '' : ` ${getScopeString(scope, colorOptions)}`;\n    let msg = `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}${scopeInfo}] ${message}`;\n\n    if (optionalParams === void 0 || optionalParams.length === 0) {\n      return error === null ? [msg] : [msg, error];\n    }\n    let offset = 0;\n    while (msg.includes('%s')) {\n      msg = msg.replace('%s', String(optionalParams[offset++]));\n    }\n    return error !== null ? [msg, error, ...optionalParams.slice(offset)] : [msg, ...optionalParams.slice(offset)];\n  }\n}\n\nexport class DefaultLogEventFactory implements ILogEventFactory {\n  public readonly config = resolve(ILogConfig);\n\n  public createLogEvent(logger: ILogger, level: LogLevel, message: string | Error, optionalParams: unknown[]): ILogEvent {\n    return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());\n  }\n}\n\nexport class ConsoleSink implements ISink {\n  public static register(container: IContainer) {\n    singletonRegistration(ISink, ConsoleSink).register(container);\n  }\n\n  public readonly handleEvent: (event: ILogEvent) => void;\n\n  public constructor(\n    p = resolve(IPlatform),\n  ) {\n    const $console = p.console as {\n      debug(...args: unknown[]): void;\n      info(...args: unknown[]): void;\n      warn(...args: unknown[]): void;\n      error(...args: unknown[]): void;\n    };\n    this.handleEvent = function emit(event: ILogEvent): void {\n      const _info = event.getFormattedLogInfo(true);\n      switch (event.severity) {\n        case trace:\n        case debug:\n          return $console.debug(..._info);\n        case info:\n          return $console.info(..._info);\n        case warn:\n          return $console.warn(..._info);\n        case error:\n        case fatal:\n          return $console.error(..._info);\n      }\n    };\n  }\n}\n\nexport class DefaultLogger {\n  /**\n   * The root `ILogger` instance. On the root logger itself, this property circularly references the root. It is never null.\n   *\n   * When using `.scopeTo`, a new `ILogger` is created. That new logger will have the `root` property set to the global (non-scoped) logger.\n   */\n  public readonly root: ILogger;\n\n  public readonly config: ILogConfig;\n\n  public readonly sinks: readonly ISink[];\n  /**\n   * The parent `ILogger` instance. On the root logger itself, this property circularly references the root. It is never null.\n   *\n   * When using `.scopeTo`, a new `ILogger` is created. That new logger will have the `parent` property set to the logger that it was created from.\n   */\n  private readonly parent: ILogger;\n  /** @internal */\n  private readonly _traceSinks: ISink[];\n  /** @internal */\n  private readonly _debugSinks: ISink[];\n  /** @internal */\n  private readonly _infoSinks: ISink[];\n  /** @internal */\n  private readonly _warnSinks: ISink[];\n  /** @internal */\n  private readonly _errorSinks: ISink[];\n  /** @internal */\n  private readonly _fatalSinks: ISink[];\n\n  /** @internal */\n  private readonly _scopedLoggers = createLookup<ILogger | undefined>();\n\n  /** @internal */\n  private readonly _factory: ILogEventFactory;\n\n  /* eslint-disable default-param-last */\n  public constructor(\n    /**\n     * The global logger configuration.\n     */\n    config = resolve(ILogConfig),\n    factory = resolve(ILogEventFactory),\n    sinks = resolve(all(ISink)),\n    /**\n     * The scopes that this logger was created for, if any.\n     */\n    public readonly scope: string[] = resolve(optional(ILogScopes)) ?? [],\n    parent: DefaultLogger | null = null,\n  ) {\n  /* eslint-enable default-param-last */\n    let traceSinks: ISink[];\n    let debugSinks: ISink[];\n    let infoSinks: ISink[];\n    let warnSinks: ISink[];\n    let errorSinks: ISink[];\n    let fatalSinks: ISink[];\n    this.config = config;\n    this._factory = factory;\n    this.sinks = sinks;\n    if (parent === null) {\n      this.root = this;\n      this.parent = this;\n\n      traceSinks = this._traceSinks = [];\n      debugSinks = this._debugSinks = [];\n      infoSinks = this._infoSinks = [];\n      warnSinks = this._warnSinks = [];\n      errorSinks = this._errorSinks = [];\n      fatalSinks = this._fatalSinks = [];\n      for (const $sink of sinks) {\n        const handles = LoggerSink.getHandles($sink);\n        if (handles?.includes(trace) ?? true) {\n          traceSinks.push($sink);\n        }\n        if (handles?.includes(debug) ?? true) {\n          debugSinks.push($sink);\n        }\n        if (handles?.includes(info) ?? true) {\n          infoSinks.push($sink);\n        }\n        if (handles?.includes(warn) ?? true) {\n          warnSinks.push($sink);\n        }\n        if (handles?.includes(error) ?? true) {\n          errorSinks.push($sink);\n        }\n        if (handles?.includes(fatal) ?? true) {\n          fatalSinks.push($sink);\n        }\n      }\n    } else {\n      this.root = parent.root;\n      this.parent = parent;\n\n      traceSinks = this._traceSinks = parent._traceSinks;\n      debugSinks = this._debugSinks = parent._debugSinks;\n      infoSinks = this._infoSinks = parent._infoSinks;\n      warnSinks = this._warnSinks = parent._warnSinks;\n      errorSinks = this._errorSinks = parent._errorSinks;\n      fatalSinks = this._fatalSinks = parent._fatalSinks;\n    }\n  }\n\n  /**\n   * Write to TRC output, if the configured `LogLevel` is set to `trace`.\n   *\n   * Intended for the most detailed information about internal app state.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public trace(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to TRC output, if the configured `LogLevel` is set to `trace`.\n   *\n   * Intended for the most detailed information about internal app state.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public trace(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public trace(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= trace) {\n      this._emit(this._traceSinks, trace, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to DBG output, if the configured `LogLevel` is set to `debug` or lower.\n   *\n   * Intended for information that is useful for debugging during development and has no long-term value.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public debug(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to DBG output, if the configured `LogLevel` is set to `debug` or lower.\n   *\n   * Intended for information that is useful for debugging during development and has no long-term value.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public debug(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public debug(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= debug) {\n      this._emit(this._debugSinks, debug, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to trace UBF, if the configured `LogLevel` is set to `info` or lower.\n   *\n   * Intended for information about the general flow of the application that has long-term value.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public info(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to trace UBF, if the configured `LogLevel` is set to `info` or lower.\n   *\n   * Intended for information about the general flow of the application that has long-term value.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public info(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public info(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= info) {\n      this._emit(this._infoSinks, info, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to WRN output, if the configured `LogLevel` is set to `warn` or lower.\n   *\n   * Intended for unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public warn(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to WRN output, if the configured `LogLevel` is set to `warn` or lower.\n   *\n   * Intended for unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public warn(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public warn(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= warn) {\n      this._emit(this._warnSinks, warn, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to ERR output, if the configured `LogLevel` is set to `error` or lower.\n   *\n   * Intended for unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public error(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to ERR output, if the configured `LogLevel` is set to `error` or lower.\n   *\n   * Intended for unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public error(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public error(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= error) {\n      this._emit(this._errorSinks, error, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Write to FTL output, if the configured `LogLevel` is set to `fatal` or lower.\n   *\n   * Intended for unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   *\n   * @param getMessage - A function to build the message to pass to the `ILogEventFactory`.\n   * Only called if the configured `LogLevel` dictates that these messages be emitted.\n   * Use this when creating the log message is potentially expensive and should only be done if the log is actually emitted.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public fatal(getMessage: () => unknown, ...optionalParams: unknown[]): void;\n  /**\n   * Write to FTL output, if the configured `LogLevel` is set to `fatal` or lower.\n   *\n   * Intended for unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.\n   *\n   * @param message - The message to pass to the `ILogEventFactory`.\n   * @param optionalParams - Any additional, optional params that should be passed to the `ILogEventFactory`\n   */\n  public fatal(message: unknown, ...optionalParams: unknown[]): void;\n  @bound\n  public fatal(messageOrGetMessage: unknown, ...optionalParams: unknown[]): void {\n    if (this.config.level <= fatal) {\n      this._emit(this._fatalSinks, fatal, messageOrGetMessage, optionalParams);\n    }\n  }\n\n  /**\n   * Create a new logger with an additional permanent prefix added to the logging outputs.\n   * When chained, multiple scopes are separated by a dot.\n   *\n   * This is preliminary API and subject to change before alpha release.\n   *\n   * @example\n   *\n   * ```ts\n   * export class MyComponent {\n   *   constructor(@ILogger private logger: ILogger) {\n   *     this.logger.debug('before scoping');\n   *     // console output: '[DBG] before scoping'\n   *     this.logger = logger.scopeTo('MyComponent');\n   *     this.logger.debug('after scoping');\n   *     // console output: '[DBG MyComponent] after scoping'\n   *   }\n   *\n   *   public doStuff(): void {\n   *     const logger = this.logger.scopeTo('doStuff()');\n   *     logger.debug('doing stuff');\n   *     // console output: '[DBG MyComponent.doStuff()] doing stuff'\n   *   }\n   * }\n   * ```\n   */\n  public scopeTo(name: string): ILogger {\n    const scopedLoggers = this._scopedLoggers;\n    let scopedLogger = scopedLoggers[name];\n    if (scopedLogger === void 0) {\n      scopedLogger = scopedLoggers[name] = new DefaultLogger(this.config, this._factory, null!, this.scope.concat(name), this);\n    }\n    return scopedLogger;\n  }\n\n  /** @internal */\n  private _emit(sinks: ISink[], level: LogLevel, msgOrGetMsg: unknown, optionalParams: unknown[]): void {\n    const message = (isFunction(msgOrGetMsg) ? msgOrGetMsg() : msgOrGetMsg) as string;\n    const event = this._factory.createLogEvent(this, level, message, optionalParams);\n    for (let i = 0, ii = sinks.length; i < ii; ++i) {\n      sinks[i].handleEvent(event);\n    }\n  }\n}\n\n/**\n * A basic `ILogger` configuration that configures a single `console` sink based on provided options.\n *\n * NOTE: You *must* register the return value of `.create` with the container / au instance, not this `LoggerConfiguration` object itself.\n *\n * @example\n * ```ts\n * container.register(LoggerConfiguration.create());\n *\n * container.register(LoggerConfiguration.create({sinks: [ConsoleSink]}))\n *\n * container.register(LoggerConfiguration.create({sinks: [ConsoleSink], level: LogLevel.debug}))\n *\n * ```\n */\nexport const LoggerConfiguration = /*@__PURE__*/ toLookup({\n  /**\n   * @param $console - The `console` object to use. Can be the native `window.console` / `global.console`, but can also be a wrapper or mock that implements the same interface.\n   * @param level - The global `LogLevel` to configure. Defaults to `warn` or higher.\n   * @param colorOptions - Whether to use colors or not. Defaults to `noColors`. Colors are especially nice in nodejs environments but don't necessarily work (well) in all environments, such as browsers.\n   */\n  create(\n    {\n      level = warn,\n      colorOptions = 'no-colors',\n      sinks = [],\n    }: Partial<ILoggingConfigurationOptions> = {}\n  ): IRegistry {\n    return toLookup({\n      register(container: IContainer): IContainer {\n        container.register(\n          instanceRegistration(ILogConfig, new LogConfig(colorOptions, level)),\n        );\n        for (const $sink of sinks) {\n          if (isFunction($sink)) {\n            container.register(singletonRegistration(ISink, $sink));\n          } else {\n            container.register($sink);\n          }\n        }\n        return container;\n      },\n    });\n  },\n});\n", "import { createInterface } from './di';\nimport { resourceBaseName } from './resource';\nimport { getMetadata, isFunction } from './utilities';\nimport { ErrorNames, createMappedError } from './errors';\n\nimport type { IRegistry } from './di';\nimport type { Constructable, IDisposable, IIndexable } from './interfaces';\nimport type { ResourceDefinition } from './resource';\n\nexport interface IModule {\n  [key: string]: unknown;\n  default?: unknown;\n}\n\nexport interface IModuleLoader extends ModuleLoader {}\nexport const IModuleLoader = /*@__PURE__*/createInterface<IModuleLoader>(x => x.singleton(ModuleLoader));\n\nconst noTransform = <TRet = AnalyzedModule>(m: AnalyzedModule): TRet => m as unknown as TRet;\n\ntype TransformFn<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>> = (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>;\n\nclass ModuleTransformer<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>> {\n  private readonly _promiseCache: Map<Promise<IModule>, unknown> = new Map<Promise<IModule>, unknown>();\n  private readonly _objectCache: Map<IModule, unknown> = new Map<IModule, unknown>();\n  private readonly _transform: TransformFn<TMod, TRet>;\n\n  public constructor(\n    transform: TransformFn<TMod, TRet>,\n  ) {\n    this._transform = transform;\n  }\n\n  public transform(objOrPromise: TMod | Promise<TMod>): Promise<TRet> | TRet {\n    if (objOrPromise instanceof Promise) {\n      return this._transformPromise(objOrPromise);\n    } else if (typeof objOrPromise === 'object' && objOrPromise !== null) {\n      return this._transformObject(objOrPromise);\n    } else {\n      throw createMappedError(ErrorNames.invalid_module_transform_input, objOrPromise);\n    }\n  }\n\n  /** @internal */\n  private _transformPromise(promise: Promise<TMod>): TRet | Promise<TRet> {\n    if (this._promiseCache.has(promise)) {\n      return this._promiseCache.get(promise) as TRet | Promise<TRet>;\n    }\n\n    const ret = promise.then(obj => {\n      return this._transformObject(obj);\n    });\n    this._promiseCache.set(promise, ret);\n    void ret.then(value => {\n      // make it synchronous for future requests\n      this._promiseCache.set(promise, value);\n    });\n    return ret;\n  }\n\n  /** @internal */\n  private _transformObject(obj: TMod): TRet | Promise<TRet> {\n    if (this._objectCache.has(obj)) {\n      return this._objectCache.get(obj) as TRet | Promise<TRet>;\n    }\n\n    const ret = this._transform(this._analyze(obj));\n    this._objectCache.set(obj, ret);\n    if (ret instanceof Promise) {\n      void ret.then(value => {\n        // make it synchronous for future requests\n        this._objectCache.set(obj, value);\n      });\n    }\n    return ret;\n  }\n\n  /** @internal */\n  private _analyze(m: TMod): AnalyzedModule<TMod> {\n    if (m == null) throw createMappedError(ErrorNames.invalid_module_transform_input, m);\n    if (typeof m !== 'object') return new AnalyzedModule(m, []);\n    let value: unknown;\n    let isRegistry: boolean;\n    let isConstructable: boolean;\n    let definition: ResourceDefinition | null;\n    const items: ModuleItem[] = [];\n\n    for (const key in m) {\n      switch (typeof (value = m[key])) {\n        case 'object':\n          if (value === null) {\n            continue;\n          }\n          isRegistry = isFunction((value as IIndexable).register);\n          isConstructable = false;\n          definition = null;\n          break;\n        case 'function':\n          isRegistry = isFunction((value as Constructable & IIndexable).register);\n          isConstructable = (value as Constructable).prototype !== void 0;\n          definition = getMetadata(resourceBaseName, value) ?? null;\n          break;\n        default:\n          continue;\n      }\n\n      items.push(new ModuleItem(\n        key,\n        value,\n        isRegistry,\n        isConstructable,\n        definition,\n      ));\n    }\n\n    return new AnalyzedModule(m, items as ITypedModuleItem_T[]);\n  }\n}\n\nexport class ModuleLoader implements IDisposable {\n  private readonly transformers: Map<TransformFn, ModuleTransformer> = new Map<TransformFn, ModuleTransformer>();\n\n  /**\n   * Await a module promise and then analyzes and transforms it. The result is cached, using the transform function + promise as the cache key.\n   *\n   * @param promise - A promise (returning a module, or an object resembling a module), e.g. the return value of a dynamic `import()` or `require()` call.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(promise: Promise<TMod>, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  /**\n   * Await a module promise and then analyzes it. The result is cached, using the transform function + promise as the cache key.\n   *\n   * @param promise - A promise (returning a module, or an object resembling a module), e.g. the return value of a dynamic `import()` or `require()` call.\n   *\n   * @returns The analyzed module. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule>(promise: Promise<TMod>): Promise<AnalyzedModule<TMod>> | AnalyzedModule<TMod>;\n  /**\n   * Analyzes and transforms a module-like object. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object, e.g. the awaited return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(obj: TMod, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  /**\n   * Analyzes a module-like object. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object, e.g. the awaited return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   *\n   * @returns The analyzed module. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule>(obj: TMod): AnalyzedModule<TMod>;\n  /**\n   * Analyzes and transforms a module-like object or a promise thereof. The result is cached, using the transform function + object as the cache key.\n   *\n   * @param promise - A module-like object or a promise thereof, e.g. the (awaited) return value of a dynamic `import()` or `require()` call, or a statically imported module such as `import * as Module from './my-module';`.\n   * @param transform - A transform function, e.g. to select the appropriate default or first non-default resource export.\n   * Note: The return value of `transform` is cached, so it is recommended to perform any processing here that is intended to happen only once per unique module promise.\n   *\n   * @returns The (cached) transformed result. On subsequent calls, if the original promise resolved, the resolved result will be returned (rather than a promise).\n   */\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(objOrPromise: TMod | Promise<TMod>, transform?: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet>): Promise<TRet> | TRet;\n  public load<TMod extends IModule = IModule, TRet = AnalyzedModule<TMod>>(objOrPromise: TMod | Promise<TMod>, transform: (m: AnalyzedModule<TMod>) => TRet | Promise<TRet> = noTransform): Promise<TRet> | TRet {\n    const transformers = this.transformers as Map<TransformFn, ModuleTransformer> & Map<TransformFn<TMod, TRet>, ModuleTransformer<TMod, TRet>>;\n    let transformer = transformers.get(transform);\n    if (transformer === void 0) {\n      transformers.set(transform, transformer = new ModuleTransformer(transform));\n    }\n\n    return transformer.transform(objOrPromise);\n  }\n\n  public dispose(): void {\n    this.transformers.clear();\n  }\n}\n\nexport class AnalyzedModule<TMod extends IModule = IModule> {\n  public constructor(\n    public readonly raw: TMod,\n    public readonly items: readonly ITypedModuleItem_T[],\n  ) {}\n}\n\nexport interface ITypedModuleItem<\n  TisRegistry extends boolean,\n  TisConstructable extends boolean,\n  TValue\n> {\n  readonly key: string;\n  readonly value: TValue;\n  readonly isRegistry: TisRegistry;\n  readonly isConstructable: TisConstructable;\n  readonly definition: ResourceDefinition | null;\n}\nexport interface ITypedModuleItem_Unknown extends ITypedModuleItem<false, false, unknown> {}\nexport interface ITypedModuleItem_Registry extends ITypedModuleItem<true, false, IRegistry> {}\nexport interface ITypedModuleItem_Constructable extends ITypedModuleItem<false, true, Constructable> {}\nexport interface ITypedModuleItem_ConstructableRegistry extends ITypedModuleItem<true, true, Constructable & IRegistry> {}\nexport type ITypedModuleItem_T = (\n  ITypedModuleItem_Unknown |\n  ITypedModuleItem_Registry |\n  ITypedModuleItem_Constructable |\n  ITypedModuleItem_ConstructableRegistry\n);\nexport class ModuleItem {\n  public constructor(\n    public readonly key: string,\n    public readonly value: unknown,\n    public readonly isRegistry: boolean,\n    public readonly isConstructable: boolean,\n    public readonly definition: ResourceDefinition | null,\n  ) {}\n}\n\n/**\n * Iterate through the exports of a module and register aliases for resources respectively\n */\nexport const aliasedResourcesRegistry = (mod: IModule, mainKeyAlias: string | null | undefined, aliases: Record<string, string> = {}): IRegistry => {\n  return {\n    register(container) {\n      const analyzedModule = container.get(IModuleLoader).load(mod);\n      let mainAliasRegistered = false;\n      analyzedModule.items.forEach((item) => {\n        const definition = item.definition;\n\n        if (definition == null) {\n          container.register(item.value);\n          return;\n        }\n\n        if (!mainAliasRegistered && mainKeyAlias != null) {\n          mainAliasRegistered = true;\n          definition.register(container, mainKeyAlias);\n          return;\n        }\n\n        // cannot use item.key, since it could contain an uppercase letter\n        // while if import as is used in html, then it'll be lowercase letters only\n        // using definition name, however, comes with an issue, which is that it's not guaranteed to be unique\n        //\n        // for example: a module can export both an element and an attribute with the name \"foo\"\n        // but if that's the case, devs can always split the exports into two modules\n        const alias = aliases[definition.name];\n        definition.register(container, alias);\n      });\n    },\n  };\n};\n\n// or extract the registry part into a class?\n//\n// class AliasModuleKeysRegistry implements IRegistry {\n//   /** @internal */ private readonly _mod: IModule;\n//   /** @internal */ private readonly _mainKeyAlias: string | null;\n//   /** @internal */ private readonly _otherAliases: Record<string, string>;\n\n//   public constructor(\n//     mod: IModule,\n//     mainKeyAlias: string | null,\n//     aliases: Record<string, string>,\n//   ) {\n//     this._mod = mod;\n//     this._mainKeyAlias = mainKeyAlias;\n//     this._otherAliases = aliases;\n//   }\n\n//   /** @internal */\n//   private _getAliasedKeyForName(key: string, name: string): string {\n//     // replace the part after the last : with the name\n//     const parts = key.split(':');\n//     parts[parts.length - 1] = name;\n//     return parts.join(':');\n//   }\n\n//   public register(container: IContainer) {\n//     const analyzedModule = container.get(IModuleLoader).load(this._mod);\n//     let mainAliasRegistered = false;\n//     analyzedModule.items.forEach((item) => {\n//       const definition = item.definition;\n\n//       if (definition == null) {\n//         container.register(item.value);\n//         return;\n//       }\n\n//       if (!mainAliasRegistered && this._mainKeyAlias != null) {\n//         mainAliasRegistered = true;\n//         aliasToRegistration(definition.key, this._mainKeyAlias).register(container);\n//         return;\n//       }\n\n//       for (const aliasedExport in this._otherAliases) {\n//         const aliasName = this._otherAliases[aliasedExport];\n//         const aliasKey = this._getAliasedKeyForName(definition.key, aliasName);\n//         if (item.key === aliasedExport) {\n//           aliasToRegistration(definition.key, aliasKey).register(container);\n//         }\n//       }\n//     });\n//   }\n// }\n", "import { createInterface } from './di';\nimport { ErrorNames, createMappedError } from './errors';\nimport { Constructable, IDisposable } from './interfaces';\nimport { isString } from './utilities';\n\n/**\n * Represents a handler for an EventAggregator event.\n */\nclass Handler<T extends Constructable> {\n  public constructor(\n    private readonly type: T,\n    private readonly cb: (message: InstanceType<T>) => void,\n  ) {}\n\n  public handle(message: InstanceType<T>): void {\n    if (message instanceof this.type) {\n      this.cb.call(null, message);\n    }\n  }\n}\n\nexport const IEventAggregator = /*@__PURE__*/createInterface<IEventAggregator>('IEventAggregator', x => x.singleton(EventAggregator));\nexport interface IEventAggregator extends EventAggregator {}\n\n/**\n * Enables loosely coupled publish/subscribe messaging.\n */\nexport class EventAggregator {\n  /** @internal */\n  public readonly eventLookup: Record<string, ((message: unknown, channel: string) => void)[]> = {};\n  /** @internal */\n  public readonly messageHandlers: Handler<Constructable>[] = [];\n\n  /**\n   * Publishes a message.\n   *\n   * @param channel - The channel to publish to.\n   * @param message - The message to publish on the channel.\n   */\n  public publish<C extends string>(channel: C, message?: unknown): void;\n  /**\n   * Publishes a message.\n   *\n   * @param instance - The instance to publish.\n   */\n  public publish<T extends Constructable>(instance: InstanceType<T>): void;\n  public publish<T extends Constructable | string>(\n    channelOrInstance: T extends Constructable ? InstanceType<T> : T,\n    message?: unknown,\n  ): void {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!channelOrInstance) {\n      throw createMappedError(ErrorNames.event_aggregator_publish_invalid_event_name, channelOrInstance);\n    }\n\n    if (isString(channelOrInstance)) {\n      let subscribers = this.eventLookup[channelOrInstance];\n      if (subscribers !== void 0) {\n        subscribers = subscribers.slice();\n        const numSubscribers = subscribers.length;\n\n        for (let i = 0; i < numSubscribers; i++) {\n          subscribers[i](message, channelOrInstance);\n        }\n      }\n    } else {\n      const subscribers = this.messageHandlers.slice();\n      const numSubscribers = subscribers.length;\n\n      for (let i = 0; i < numSubscribers; i++) {\n        subscribers[i].handle(channelOrInstance);\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a message channel.\n   *\n   * @param channel - The event channel.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T, C extends string = string>(\n    channel: C,\n    callback: (message: T, channel: C) => void,\n  ): IDisposable;\n  /**\n   * Subscribes to a message type.\n   *\n   * @param type - The event message type.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribe<T extends Constructable>(\n    type: T,\n    callback: (message: InstanceType<T>) => void,\n  ): IDisposable;\n  public subscribe(\n    channelOrType: string | Constructable,\n    callback: (...args: unknown[]) => void,\n  ): IDisposable {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!channelOrType) {\n      throw createMappedError(ErrorNames.event_aggregator_subscribe_invalid_event_name, channelOrType);\n    }\n\n    let handler: unknown;\n    let subscribers: unknown[];\n\n    if (isString(channelOrType)) {\n      if (this.eventLookup[channelOrType] === void 0) {\n        this.eventLookup[channelOrType] = [];\n      }\n      handler = callback;\n      subscribers = this.eventLookup[channelOrType];\n    } else {\n      handler = new Handler(channelOrType, callback);\n\n      subscribers = this.messageHandlers;\n    }\n\n    subscribers.push(handler);\n\n    return {\n      dispose(): void {\n        const idx = subscribers.indexOf(handler);\n        if (idx !== -1) {\n          subscribers.splice(idx, 1);\n        }\n      }\n    };\n  }\n\n  /**\n   * Subscribes to a message channel, then disposes the subscription automatically after the first message is received.\n   *\n   * @param channel - The event channel.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T, C extends string>(\n    channel: C,\n    callback: (message: T, channel: C) => void,\n  ): IDisposable;\n  /**\n   * Subscribes to a message type, then disposes the subscription automatically after the first message is received.\n   *\n   * @param type - The event message type.\n   * @param callback - The callback to be invoked when the specified message is published.\n   */\n  public subscribeOnce<T extends Constructable>(\n    type: T,\n    callback: (message: InstanceType<T>) => void,\n  ): IDisposable;\n  public subscribeOnce(\n    channelOrType: string | Constructable,\n    callback: (...args: unknown[]) => void,\n  ): IDisposable {\n    const sub = this.subscribe(channelOrType as string, (message, event) => {\n      sub.dispose();\n      callback(message, event);\n    });\n\n    return sub;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\nimport { emptyArray } from '@aurelia/kernel';\nimport type { IVisitor } from './ast.visitor';\n\n/** @internal */ export const ekAccessThis = 'AccessThis';\n/** @internal */ export const ekAccessBoundary = 'AccessBoundary';\n/** @internal */ export const ekAccessGlobal = 'AccessGlobal';\n/** @internal */ export const ekAccessScope = 'AccessScope';\n/** @internal */ export const ekArrayLiteral = 'ArrayLiteral';\n/** @internal */ export const ekObjectLiteral = 'ObjectLiteral';\n/** @internal */ export const ekPrimitiveLiteral = 'PrimitiveLiteral';\n/** @internal */ export const ekNew = 'New';\n/** @internal */ export const ekTemplate = 'Template';\n/** @internal */ export const ekUnary = 'Unary';\n/** @internal */ export const ekCallScope = 'CallScope';\n/** @internal */ export const ekCallMember = 'CallMember';\n/** @internal */ export const ekCallFunction = 'CallFunction';\n/** @internal */ export const ekCallGlobal = 'CallGlobal';\n/** @internal */ export const ekAccessMember = 'AccessMember';\n/** @internal */ export const ekAccessKeyed = 'AccessKeyed';\n/** @internal */ export const ekTaggedTemplate = 'TaggedTemplate';\n/** @internal */ export const ekBinary = 'Binary';\n/** @internal */ export const ekConditional = 'Conditional';\n/** @internal */ export const ekAssign = 'Assign';\n/** @internal */ export const ekArrowFunction = 'ArrowFunction';\n/** @internal */ export const ekValueConverter = 'ValueConverter';\n/** @internal */ export const ekBindingBehavior = 'BindingBehavior';\n/** @internal */ export const ekArrayBindingPattern = 'ArrayBindingPattern';\n/** @internal */ export const ekObjectBindingPattern = 'ObjectBindingPattern';\n/** @internal */ export const ekBindingIdentifier = 'BindingIdentifier';\n/** @internal */ export const ekForOfStatement = 'ForOfStatement';\n/** @internal */ export const ekInterpolation = 'Interpolation';\n/** @internal */ export const ekArrayDestructuring = 'ArrayDestructuring';\n/** @internal */ export const ekObjectDestructuring = 'ObjectDestructuring';\n/** @internal */ export const ekDestructuringAssignmentLeaf = 'DestructuringAssignmentLeaf';\n/** @internal */ export const ekCustom = 'Custom';\n\nexport type ExpressionKind =\n  | 'AccessThis'\n  | 'AccessGlobal'\n  | 'AccessBoundary'\n  | 'AccessScope'\n  | 'ArrayLiteral'\n  | 'ObjectLiteral'\n  | 'PrimitiveLiteral'\n  | 'New'\n  | 'Template'\n  | 'Unary'\n  | 'CallScope'\n  | 'CallMember'\n  | 'CallFunction'\n  | 'CallGlobal'\n  | 'AccessMember'\n  | 'AccessKeyed'\n  | 'TaggedTemplate'\n  | 'Binary'\n  | 'Conditional'\n  | 'Assign'\n  | 'ArrowFunction'\n  | 'ValueConverter'\n  | 'BindingBehavior'\n  | 'ArrayBindingPattern'\n  | 'ObjectBindingPattern'\n  | 'BindingIdentifier'\n  | 'ForOfStatement'\n  | 'Interpolation'\n  | 'ArrayDestructuring'\n  | 'ObjectDestructuring'\n  | 'DestructuringAssignmentLeaf'\n  | 'Custom';\n\nexport type UnaryOperator = 'void' | 'typeof' | '!' | '-' | '+' | '++' | '--';\n\nexport type BinaryOperator = '??' | '&&' | '||' | '==' | '===' | '!=' | '!==' | 'instanceof' | 'in' | '+' | '-' | '*' | '/' | '%' | '**' | '<' | '>' | '<=' | '>=';\nexport type AssignmentOperator = '=' | '/=' | '*=' | '+=' | '-=';\nexport type IsPrimary = AccessThisExpression | AccessBoundaryExpression | AccessScopeExpression | AccessGlobalExpression | ArrayLiteralExpression | ObjectLiteralExpression | PrimitiveLiteralExpression | TemplateExpression | NewExpression;\nexport type IsLiteral = ArrayLiteralExpression | ObjectLiteralExpression | PrimitiveLiteralExpression | TemplateExpression;\nexport type IsLeftHandSide = IsPrimary | CallGlobalExpression | CallFunctionExpression | CallMemberExpression | CallScopeExpression | AccessMemberExpression | AccessKeyedExpression | TaggedTemplateExpression;\nexport type IsUnary = IsLeftHandSide | UnaryExpression;\nexport type IsBinary = IsUnary | BinaryExpression;\nexport type IsConditional = IsBinary | ConditionalExpression;\nexport type IsAssign = IsConditional | AssignExpression | ArrowFunction;\nexport type IsValueConverter = IsAssign | ValueConverterExpression;\nexport type IsBindingBehavior = IsValueConverter | BindingBehaviorExpression;\nexport type IsAssignable = AccessScopeExpression | AccessKeyedExpression | AccessMemberExpression | AssignExpression;\nexport type IsExpression = IsBindingBehavior | Interpolation;\nexport type BindingIdentifierOrPattern = BindingIdentifier | ArrayBindingPattern | ObjectBindingPattern;\nexport type IsExpressionOrStatement = IsExpression | ForOfStatement | BindingIdentifierOrPattern | DestructuringAssignmentExpression | DestructuringAssignmentSingleExpression | DestructuringAssignmentRestExpression;\nexport type AnyBindingExpression<TCustom extends CustomExpression = CustomExpression> = Interpolation | ForOfStatement | TCustom | IsBindingBehavior;\n\nexport class CustomExpression {\n  public readonly $kind = ekCustom;\n  public constructor(\n    public readonly value: unknown,\n  ) {}\n\n  public evaluate(...params: unknown[]): unknown {\n    return this.value;\n  }\n\n  public assign(...params: unknown[]): unknown {\n    return params;\n  }\n\n  public bind(...params: unknown[]): void {\n    // empty\n  }\n\n  public unbind(...params: unknown[]): void {\n    // empty\n  }\n\n  public accept<T>(_visitor: IVisitor<T>): T {\n    return (void 0)!;\n  }\n}\n\nexport class BindingBehaviorExpression {\n  public readonly $kind = ekBindingBehavior;\n  /**\n   * The name of the property to store a binding behavior on the binding when binding\n   */\n  public readonly key: string;\n\n  public constructor(\n    public readonly expression: IsBindingBehavior,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n  ) {\n    this.key = `_bb_${name}`;\n  }\n}\n\nexport class ValueConverterExpression {\n  public readonly $kind = ekValueConverter;\n  public constructor(\n    public readonly expression: IsValueConverter,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n  ) {\n  }\n}\n\nexport class AssignExpression {\n  public readonly $kind = ekAssign;\n\n  public constructor(\n    public readonly target: IsAssignable,\n    public readonly value: IsAssign,\n    public readonly op: AssignmentOperator = '=',\n  ) {}\n}\n\nexport class ConditionalExpression {\n  public readonly $kind = ekConditional;\n  public constructor(\n    public readonly condition: IsBinary,\n    public readonly yes: IsAssign,\n    public readonly no: IsAssign,\n  ) {}\n}\n\nexport class AccessGlobalExpression {\n  public readonly $kind: 'AccessGlobal' = ekAccessGlobal;\n\n  public constructor(\n    public readonly name: string,\n  ) {}\n}\n\nexport class AccessThisExpression {\n  public readonly $kind: 'AccessThis' = ekAccessThis;\n\n  public constructor(\n    public readonly ancestor: number = 0,\n  ) {}\n}\n\nexport class AccessBoundaryExpression {\n  public readonly $kind: 'AccessBoundary' = ekAccessBoundary;\n}\n\nexport class AccessScopeExpression {\n  public readonly $kind = ekAccessScope;\n  public constructor(\n    public readonly name: string,\n    public readonly ancestor: number = 0,\n  ) {}\n}\n\nconst isAccessGlobal = (ast: IsLeftHandSide) => (\n  ast.$kind === ekAccessGlobal ||\n  (\n    ast.$kind === ekAccessMember ||\n    ast.$kind === ekAccessKeyed\n  ) && ast.accessGlobal\n);\n\nexport class AccessMemberExpression {\n  public readonly $kind: 'AccessMember' = ekAccessMember;\n  public readonly accessGlobal: boolean;\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string,\n    public readonly optional: boolean = false,\n  ) {\n    this.accessGlobal = isAccessGlobal(object);\n  }\n}\n\nexport class AccessKeyedExpression {\n  public readonly $kind = ekAccessKeyed;\n  public readonly accessGlobal: boolean;\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly key: IsAssign,\n    public readonly optional: boolean = false,\n  ) {\n    this.accessGlobal = isAccessGlobal(object);\n  }\n}\n\nexport class NewExpression {\n  public readonly $kind = ekNew;\n  public constructor(\n    public readonly func: IsLeftHandSide,\n    public readonly args: readonly IsAssign[],\n  ) {}\n}\n\nexport class CallScopeExpression {\n  public readonly $kind = ekCallScope;\n  public constructor(\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n    public readonly ancestor: number = 0,\n    public readonly optional: boolean = false,\n  ) {}\n}\n\nexport class CallMemberExpression {\n  public readonly $kind = ekCallMember;\n  public constructor(\n    public readonly object: IsLeftHandSide,\n    public readonly name: string,\n    public readonly args: readonly IsAssign[],\n    public readonly optionalMember: boolean = false,\n    public readonly optionalCall: boolean = false,\n  ) {}\n}\n\nexport class CallFunctionExpression {\n  public readonly $kind = ekCallFunction;\n  public constructor(\n    public readonly func: IsLeftHandSide,\n    public readonly args: readonly IsAssign[],\n    public readonly optional: boolean = false,\n  ) {}\n}\n\nexport class CallGlobalExpression {\n  public readonly $kind = ekCallGlobal;\n  public constructor(\n    public readonly name: string,\n    public readonly args: readonly IsAssign[]\n  ) {}\n}\n\nexport class BinaryExpression {\n  public readonly $kind: 'Binary' = ekBinary;\n  public constructor(\n    public readonly operation: BinaryOperator,\n    public readonly left: IsBinary,\n    public readonly right: IsBinary,\n  ) {}\n}\n\nexport class UnaryExpression {\n  public readonly $kind = ekUnary;\n  public constructor(\n    public readonly operation: UnaryOperator,\n    public readonly expression: IsLeftHandSide,\n    public readonly pos: 0 | 1 = 0,\n  ) {}\n}\nexport class PrimitiveLiteralExpression<TValue extends null | undefined | number | boolean | string = null | undefined | number | boolean | string> {\n  public static readonly $undefined: PrimitiveLiteralExpression<undefined> = new PrimitiveLiteralExpression<undefined>(void 0);\n  public static readonly $null: PrimitiveLiteralExpression<null> = new PrimitiveLiteralExpression<null>(null);\n  public static readonly $true: PrimitiveLiteralExpression<true> = new PrimitiveLiteralExpression<true>(true);\n  public static readonly $false: PrimitiveLiteralExpression<false> = new PrimitiveLiteralExpression<false>(false);\n  public static readonly $empty: PrimitiveLiteralExpression<string> = new PrimitiveLiteralExpression<''>('');\n  public readonly $kind = ekPrimitiveLiteral;\n\n  public constructor(\n    public readonly value: TValue,\n  ) {}\n}\n\nexport class ArrayLiteralExpression {\n  public static readonly $empty: ArrayLiteralExpression = new ArrayLiteralExpression(emptyArray);\n  public readonly $kind = ekArrayLiteral;\n  public constructor(\n    public readonly elements: readonly IsAssign[],\n  ) {}\n}\n\nexport class ObjectLiteralExpression {\n  public static readonly $empty: ObjectLiteralExpression = new ObjectLiteralExpression(emptyArray, emptyArray);\n  public readonly $kind = ekObjectLiteral;\n  public constructor(\n    public readonly keys: readonly (number | string)[],\n    public readonly values: readonly IsAssign[],\n  ) {}\n}\n\nexport class TemplateExpression {\n  public static readonly $empty: TemplateExpression = new TemplateExpression(['']);\n  public readonly $kind = ekTemplate;\n  public constructor(\n    public readonly cooked: readonly string[],\n    public readonly expressions: readonly IsAssign[] = emptyArray,\n  ) {}\n}\n\nexport class TaggedTemplateExpression {\n  public readonly $kind = ekTaggedTemplate;\n  public constructor(\n    public readonly cooked: readonly string[] & { raw?: readonly string[] },\n    raw: readonly string[],\n    public readonly func: IsLeftHandSide,\n    public readonly expressions: readonly IsAssign[] = emptyArray,\n  ) {\n    cooked.raw = raw;\n  }\n}\n\nexport class ArrayBindingPattern {\n  public readonly $kind = ekArrayBindingPattern;\n  // We'll either have elements, or keys+values, but never all 3\n  public constructor(\n    public readonly elements: readonly IsAssign[],\n  ) {}\n}\n\nexport class ObjectBindingPattern {\n  public readonly $kind = ekObjectBindingPattern;\n  // We'll either have elements, or keys+values, but never all 3\n  public constructor(\n    public readonly keys: readonly (string | number)[],\n    public readonly values: readonly IsAssign[],\n  ) {}\n}\n\nexport class BindingIdentifier {\n  public readonly $kind = ekBindingIdentifier;\n  public constructor(\n    public readonly name: string,\n  ) {}\n}\n\n// https://tc39.github.io/ecma262/#sec-iteration-statements\n// https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\nexport class ForOfStatement {\n  public readonly $kind = ekForOfStatement;\n  public constructor(\n    public readonly declaration: BindingIdentifierOrPattern | DestructuringAssignmentExpression,\n    public readonly iterable: IsBindingBehavior,\n    public readonly semiIdx: number,\n  ) {}\n}\n\n/*\n* Note: this implementation is far simpler than the one in vCurrent and might be missing important stuff (not sure yet)\n* so while this implementation is identical to Template and we could reuse that one, we don't want to lock outselves in to potentially the wrong abstraction\n* but this class might be a candidate for removal if it turns out it does provide all we need\n*/\nexport class Interpolation {\n  public readonly $kind = ekInterpolation;\n  public readonly isMulti: boolean;\n  public readonly firstExpression: IsBindingBehavior;\n  public constructor(\n    public readonly parts: readonly string[],\n    public readonly expressions: readonly IsBindingBehavior[] = emptyArray,\n  ) {\n    this.isMulti = expressions.length > 1;\n    this.firstExpression = expressions[0];\n  }\n}\n\n// spec: https://tc39.es/ecma262/#sec-destructuring-assignment\n/** This is an internal API */\nexport class DestructuringAssignmentExpression {\n  public constructor(\n    public readonly $kind: 'ArrayDestructuring' | 'ObjectDestructuring',\n    public readonly list: readonly (DestructuringAssignmentExpression | DestructuringAssignmentSingleExpression | DestructuringAssignmentRestExpression)[],\n    public readonly source: AccessMemberExpression | AccessKeyedExpression | undefined,\n    public readonly initializer: IsBindingBehavior | undefined,\n  ) { }\n}\n\n/** This is an internal API */\nexport class DestructuringAssignmentSingleExpression {\n  public readonly $kind = ekDestructuringAssignmentLeaf;\n  public constructor(\n    public readonly target: AccessMemberExpression,\n    public readonly source: AccessMemberExpression | AccessKeyedExpression,\n    public readonly initializer: IsBindingBehavior | undefined,\n  ) { }\n}\n\n/** This is an internal API */\nexport class DestructuringAssignmentRestExpression {\n  public readonly $kind = ekDestructuringAssignmentLeaf;\n  public constructor(\n    public readonly target: AccessMemberExpression,\n    public readonly indexOrProperties: string[] | number,\n  ) { }\n}\n\nexport class ArrowFunction {\n  public readonly $kind = ekArrowFunction;\n  public constructor(\n    public args: BindingIdentifier[],\n    public body: IsAssign,\n    public rest: boolean = false,\n  ) {}\n}\n", "/** @internal */\nexport const createError = (message: string) => new Error(message);\n\n/** @internal */\nexport const isString = (v: unknown): v is string => typeof v === 'string';\n\n// this is used inside template literal, since TS errs without String(...value)\n/** @internal */ export const safeString = String;\n\n/** @internal */ export const createLookup = <T>(): Record<string, T> => Object.create(null) as Record<string, T>;\n", "import {\n  CustomExpression,\n  ekAccessBoundary,\n  ekAccessKeyed,\n  ekAccessMember,\n  ekAccessScope,\n  ekAccessThis,\n  ekArrayBindingPattern,\n  ekArrayDestructuring,\n  ekArrayLiteral,\n  ekArrowFunction,\n  ekAssign,\n  ekBinary,\n  ekBindingBehavior,\n  ekBindingIdentifier,\n  ekCallFunction,\n  ekCallMember,\n  ekCallScope,\n  ekConditional,\n  ekCustom,\n  ekDestructuringAssignmentLeaf,\n  ekForOfStatement,\n  ekInterpolation,\n  ekObjectBindingPattern,\n  ekObjectDestructuring,\n  ekObjectLiteral,\n  ekPrimitiveLiteral,\n  ekTaggedTemplate,\n  ekTemplate,\n  ekUnary,\n  ekValueConverter,\n} from './ast';\nimport {\n  createError,\n  isString,\n  safeString,\n} from './utilities';\n\nimport type {\n  AccessBoundaryExpression,\n  AccessKeyedExpression,\n  AccessMemberExpression,\n  AccessScopeExpression,\n  AccessThisExpression,\n  ArrayBindingPattern,\n  ArrayLiteralExpression,\n  ArrowFunction,\n  AssignExpression,\n  BinaryExpression,\n  BindingBehaviorExpression,\n  BindingIdentifier,\n  CallFunctionExpression,\n  CallMemberExpression,\n  CallScopeExpression,\n  ConditionalExpression,\n  DestructuringAssignmentExpression,\n  DestructuringAssignmentRestExpression,\n  DestructuringAssignmentSingleExpression,\n  ForOfStatement,\n  Interpolation,\n  IsBindingBehavior,\n  IsExpressionOrStatement,\n  ObjectBindingPattern,\n  ObjectLiteralExpression,\n  PrimitiveLiteralExpression,\n  TaggedTemplateExpression,\n  TemplateExpression,\n  UnaryExpression,\n  ValueConverterExpression,\n} from './ast';\n\nexport interface IVisitor<T = unknown, TCustom extends CustomExpression = CustomExpression> {\n  visitAccessKeyed(expr: AccessKeyedExpression): T;\n  visitAccessMember(expr: AccessMemberExpression): T;\n  visitAccessScope(expr: AccessScopeExpression): T;\n  visitAccessThis(expr: AccessThisExpression): T;\n  visitAccessBoundary(expr: AccessBoundaryExpression): T;\n  visitArrayBindingPattern(expr: ArrayBindingPattern): T;\n  visitArrayLiteral(expr: ArrayLiteralExpression): T;\n  visitArrowFunction(expr: ArrowFunction): T;\n  visitAssign(expr: AssignExpression): T;\n  visitBinary(expr: BinaryExpression): T;\n  visitBindingBehavior(expr: BindingBehaviorExpression): T;\n  visitBindingIdentifier(expr: BindingIdentifier): T;\n  visitCallFunction(expr: CallFunctionExpression): T;\n  visitCallMember(expr: CallMemberExpression): T;\n  visitCallScope(expr: CallScopeExpression): T;\n  visitConditional(expr: ConditionalExpression): T;\n  visitForOfStatement(expr: ForOfStatement): T;\n  visitInterpolation(expr: Interpolation): T;\n  visitObjectBindingPattern(expr: ObjectBindingPattern): T;\n  visitObjectLiteral(expr: ObjectLiteralExpression): T;\n  visitPrimitiveLiteral(expr: PrimitiveLiteralExpression): T;\n  visitTaggedTemplate(expr: TaggedTemplateExpression): T;\n  visitTemplate(expr: TemplateExpression): T;\n  visitUnary(expr: UnaryExpression): T;\n  visitValueConverter(expr: ValueConverterExpression): T;\n  visitDestructuringAssignmentExpression(expr: DestructuringAssignmentExpression): T;\n  visitDestructuringAssignmentSingleExpression(expr: DestructuringAssignmentSingleExpression): T;\n  visitDestructuringAssignmentRestExpression(expr: DestructuringAssignmentRestExpression): T;\n  visitCustom(expr: TCustom): T;\n}\n\nexport const astVisit = <T, TCustom extends CustomExpression>(ast: TCustom | IsExpressionOrStatement, visitor: IVisitor<T, TCustom>) => {\n  switch (ast.$kind) {\n    case ekAccessKeyed: return visitor.visitAccessKeyed(ast);\n    case ekAccessMember: return visitor.visitAccessMember(ast);\n    case ekAccessScope: return visitor.visitAccessScope(ast);\n    case ekAccessThis: return visitor.visitAccessThis(ast);\n    case ekAccessBoundary: return visitor.visitAccessBoundary(ast);\n    case ekArrayBindingPattern: return visitor.visitArrayBindingPattern(ast);\n    case ekArrayDestructuring: return visitor.visitDestructuringAssignmentExpression(ast);\n    case ekArrayLiteral: return visitor.visitArrayLiteral(ast);\n    case ekArrowFunction: return visitor.visitArrowFunction(ast);\n    case ekAssign: return visitor.visitAssign(ast);\n    case ekBinary: return visitor.visitBinary(ast);\n    case ekBindingBehavior: return visitor.visitBindingBehavior(ast);\n    case ekBindingIdentifier: return visitor.visitBindingIdentifier(ast);\n    case ekCallFunction: return visitor.visitCallFunction(ast);\n    case ekCallMember: return visitor.visitCallMember(ast);\n    case ekCallScope: return visitor.visitCallScope(ast);\n    case ekConditional: return visitor.visitConditional(ast);\n    case ekDestructuringAssignmentLeaf: return visitor.visitDestructuringAssignmentSingleExpression(ast as DestructuringAssignmentSingleExpression);\n    case ekForOfStatement: return visitor.visitForOfStatement(ast);\n    case ekInterpolation: return visitor.visitInterpolation(ast);\n    case ekObjectBindingPattern: return visitor.visitObjectBindingPattern(ast);\n    case ekObjectDestructuring: return visitor.visitDestructuringAssignmentExpression(ast);\n    case ekObjectLiteral: return visitor.visitObjectLiteral(ast);\n    case ekPrimitiveLiteral: return visitor.visitPrimitiveLiteral(ast);\n    case ekTaggedTemplate: return visitor.visitTaggedTemplate(ast);\n    case ekTemplate: return visitor.visitTemplate(ast);\n    case ekUnary: return visitor.visitUnary(ast);\n    case ekValueConverter: return visitor.visitValueConverter(ast);\n    case ekCustom: return visitor.visitCustom(ast);\n    default: {\n      throw createError(`Trying to visit unknown ast node ${JSON.stringify(ast)}`);\n    }\n  }\n};\n\nexport class Unparser implements IVisitor<void> {\n  public text: string = '';\n\n  public static unparse(expr: IsExpressionOrStatement): string {\n    const visitor = new Unparser();\n    astVisit(expr, visitor);\n    return visitor.text;\n  }\n\n  public visitAccessMember(expr: AccessMemberExpression): void {\n    astVisit(expr.object, this);\n    this.text += `${expr.optional ? '?' : ''}.${expr.name}`;\n  }\n\n  public visitAccessKeyed(expr: AccessKeyedExpression): void {\n    astVisit(expr.object, this);\n    this.text += `${expr.optional ? '?.' : ''}[`;\n    astVisit(expr.key, this);\n    this.text += ']';\n  }\n\n  public visitAccessThis(expr: AccessThisExpression): void {\n    if (expr.ancestor === 0) {\n      this.text += '$this';\n      return;\n    }\n    this.text += '$parent';\n    let i = expr.ancestor - 1;\n    while (i--) {\n      this.text += '.$parent';\n    }\n  }\n\n  public visitAccessBoundary(_expr: AccessBoundaryExpression): void {\n    this.text += 'this';\n  }\n\n  public visitAccessScope(expr: AccessScopeExpression): void {\n    let i = expr.ancestor;\n    while (i--) {\n      this.text += '$parent.';\n    }\n    this.text += expr.name;\n  }\n\n  public visitArrayLiteral(expr: ArrayLiteralExpression): void {\n    const elements = expr.elements;\n    this.text += '[';\n    for (let i = 0, length = elements.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      astVisit(elements[i], this);\n    }\n    this.text += ']';\n  }\n\n  public visitArrowFunction(expr: ArrowFunction): void {\n    const args = expr.args;\n    const ii = args.length;\n    let i = 0;\n    let text = '(';\n    let name: string;\n    for (; i < ii; ++i) {\n      name = args[i].name;\n      if (i > 0) {\n        text += ', ';\n      }\n      if (i < ii - 1) {\n        text += name;\n      } else {\n        text += expr.rest ? `...${name}` : name;\n      }\n    }\n    this.text += `${text}) => `;\n    astVisit(expr.body, this);\n  }\n\n  public visitObjectLiteral(expr: ObjectLiteralExpression): void {\n    const keys = expr.keys;\n    const values = expr.values;\n    this.text += '{';\n    for (let i = 0, length = keys.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      this.text += `'${keys[i]}':`;\n      astVisit(values[i], this);\n    }\n    this.text += '}';\n  }\n\n  public visitPrimitiveLiteral(expr: PrimitiveLiteralExpression): void {\n    this.text += '(';\n    if (isString(expr.value)) {\n      const escaped = expr.value.replace(/'/g, '\\\\\\'');\n      this.text += `'${escaped}'`;\n    } else {\n      this.text += `${expr.value}`;\n    }\n    this.text += ')';\n  }\n\n  public visitCallFunction(expr: CallFunctionExpression): void {\n    this.text += '(';\n    astVisit(expr.func, this);\n    this.text += expr.optional ? '?.' : '';\n    this.writeArgs(expr.args);\n    this.text += ')';\n  }\n\n  public visitCallMember(expr: CallMemberExpression): void {\n    astVisit(expr.object, this);\n    this.text += `${expr.optionalMember ? '?.' : ''}.${expr.name}${expr.optionalCall ? '?.' : ''}`;\n    this.writeArgs(expr.args);\n  }\n\n  public visitCallScope(expr: CallScopeExpression): void {\n    let i = expr.ancestor;\n    while (i--) {\n      this.text += '$parent.';\n    }\n    this.text += `${expr.name}${expr.optional ? '?.' : ''}`;\n    this.writeArgs(expr.args);\n  }\n\n  public visitTemplate(expr: TemplateExpression): void {\n    const { cooked, expressions } = expr;\n    const length = expressions.length;\n    this.text += '`';\n    this.text += cooked[0];\n    for (let i = 0; i < length; i++) {\n      astVisit(expressions[i], this);\n      this.text += cooked[i + 1];\n    }\n    this.text += '`';\n  }\n\n  public visitTaggedTemplate(expr: TaggedTemplateExpression): void {\n    const { cooked, expressions } = expr;\n    const length = expressions.length;\n    astVisit(expr.func, this);\n    this.text += '`';\n    this.text += cooked[0];\n    for (let i = 0; i < length; i++) {\n      astVisit(expressions[i], this);\n      this.text += cooked[i + 1];\n    }\n    this.text += '`';\n  }\n\n  public visitUnary(expr: UnaryExpression): void {\n    this.text += `(${expr.operation}`;\n    if (expr.operation.charCodeAt(0) >= /* a */97) {\n      this.text += ' ';\n    }\n    astVisit(expr.expression, this);\n    this.text += ')';\n  }\n\n  public visitBinary(expr: BinaryExpression): void {\n    this.text += '(';\n    astVisit(expr.left, this);\n    if (expr.operation.charCodeAt(0) === /* i */105) {\n      this.text += ` ${expr.operation} `;\n    } else {\n      this.text += expr.operation;\n    }\n    astVisit(expr.right, this);\n    this.text += ')';\n  }\n\n  public visitConditional(expr: ConditionalExpression): void {\n    this.text += '(';\n    astVisit(expr.condition, this);\n    this.text += '?';\n    astVisit(expr.yes, this);\n    this.text += ':';\n    astVisit(expr.no, this);\n    this.text += ')';\n  }\n\n  public visitAssign(expr: AssignExpression): void {\n    this.text += '(';\n    astVisit(expr.target, this);\n    this.text += '=';\n    astVisit(expr.value, this);\n    this.text += ')';\n  }\n\n  public visitValueConverter(expr: ValueConverterExpression): void {\n    const args = expr.args;\n    astVisit(expr.expression, this);\n    this.text += `|${expr.name}`;\n    for (let i = 0, length = args.length; i < length; ++i) {\n      this.text += ':';\n      astVisit(args[i], this);\n    }\n  }\n\n  public visitBindingBehavior(expr: BindingBehaviorExpression): void {\n    const args = expr.args;\n    astVisit(expr.expression, this);\n    this.text += `&${expr.name}`;\n    for (let i = 0, length = args.length; i < length; ++i) {\n      this.text += ':';\n      astVisit(args[i], this);\n    }\n  }\n\n  public visitArrayBindingPattern(expr: ArrayBindingPattern): void {\n    const elements = expr.elements;\n    this.text += '[';\n    for (let i = 0, length = elements.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      astVisit(elements[i], this);\n    }\n    this.text += ']';\n  }\n\n  public visitObjectBindingPattern(expr: ObjectBindingPattern): void {\n    const keys = expr.keys;\n    const values = expr.values;\n    this.text += '{';\n    for (let i = 0, length = keys.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      this.text += `'${keys[i]}':`;\n      astVisit(values[i], this);\n    }\n    this.text += '}';\n  }\n\n  public visitBindingIdentifier(expr: BindingIdentifier): void {\n    this.text += expr.name;\n  }\n\n  public visitForOfStatement(expr: ForOfStatement): void {\n    astVisit(expr.declaration, this);\n    this.text += ' of ';\n    astVisit(expr.iterable, this);\n  }\n\n  public visitInterpolation(expr: Interpolation): void {\n    const { parts, expressions } = expr;\n    const length = expressions.length;\n    this.text += '${';\n    this.text += parts[0];\n    for (let i = 0; i < length; i++) {\n      astVisit(expressions[i], this);\n      this.text += parts[i + 1];\n    }\n    this.text += '}';\n  }\n\n  public visitDestructuringAssignmentExpression(expr: DestructuringAssignmentExpression): void {\n    const $kind = expr.$kind;\n    const isObjDes = $kind === ekObjectDestructuring;\n    this.text += isObjDes ? '{' : '[';\n    const list = expr.list;\n    const len = list.length;\n    let i: number;\n    let item: DestructuringAssignmentExpression | DestructuringAssignmentSingleExpression | DestructuringAssignmentRestExpression;\n    for(i = 0; i< len; i++) {\n      item = list[i];\n      switch(item.$kind) {\n        case ekDestructuringAssignmentLeaf:\n          astVisit(item, this);\n          break;\n        case ekArrayDestructuring:\n        case ekObjectDestructuring: {\n          const source = item.source;\n          if(source) {\n            astVisit(source, this);\n            this.text += ':';\n          }\n          astVisit(item, this);\n          break;\n        }\n      }\n    }\n    this.text += isObjDes ? '}' : ']';\n  }\n\n  public visitDestructuringAssignmentSingleExpression(expr: DestructuringAssignmentSingleExpression): void {\n    astVisit(expr.source, this);\n    this.text += ':';\n    astVisit(expr.target, this);\n    const initializer = expr.initializer;\n    if(initializer !== void 0) {\n      this.text +='=';\n      astVisit(initializer, this);\n    }\n  }\n\n  public visitDestructuringAssignmentRestExpression(expr: DestructuringAssignmentRestExpression): void {\n    this.text += '...';\n    astVisit(expr.target, this);\n  }\n\n  public visitCustom(expr: CustomExpression): void {\n    this.text += safeString(expr.value);\n  }\n\n  private writeArgs(args: readonly IsBindingBehavior[]): void {\n    this.text += '(';\n    for (let i = 0, length = args.length; i < length; ++i) {\n      if (i !== 0) {\n        this.text += ',';\n      }\n      astVisit(args[i], this);\n    }\n    this.text += ')';\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n\nimport { safeString } from './utilities';\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}: ${getMessageByCode(code, ...details)}`)\n  : (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${safeString(code).padStart(4, '0')}:${details.map(safeString)}`);\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  method_not_implemented = 99,\n\n  ast_behavior_not_found = 101,\n  ast_behavior_duplicated = 102,\n  ast_converter_not_found = 103,\n  ast_$host_not_found = 105,\n  ast_no_assign_$host = 106,\n  ast_not_a_function = 107,\n  ast_unknown_binary_operator = 108,\n  ast_unknown_unary_operator = 109,\n  ast_tagged_not_a_function = 110,\n  ast_name_is_not_a_function = 111,\n  ast_destruct_null = 112,\n\n  parse_invalid_start = 151,\n  parse_no_spread = 152,\n  parse_expected_identifier = 153,\n  parse_invalid_member_expr = 154,\n  parse_unexpected_end = 155,\n  parse_unconsumed_token = 156,\n  parse_invalid_empty = 157,\n  parse_left_hand_side_not_assignable = 158,\n  parse_expected_converter_identifier = 159,\n  parse_expected_behavior_identifier = 160,\n  parse_unexpected_keyword_of = 161,\n  parse_unexpected_keyword_import = 162,\n  parse_invalid_identifier_in_forof = 163,\n  parse_invalid_identifier_object_literal_key = 164,\n  parse_unterminated_string = 165,\n  parse_unterminated_template_string = 166,\n  parse_missing_expected_token = 167,\n  parse_unexpected_character = 168,\n  parse_unexpected_token_destructuring = 170,\n  parse_unexpected_token_optional_chain = 171,\n  parse_invalid_tag_in_optional_chain = 172,\n  parse_invalid_arrow_params = 173,\n  parse_no_arrow_param_default_value = 174,\n  parse_no_arrow_param_destructuring = 175,\n  parse_rest_must_be_last = 176,\n  parse_no_arrow_fn_body = 178,\n  parse_unexpected_double_dot = 179,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string> = {\n  [ErrorNames.method_not_implemented]: 'Method {{0}} not implemented',\n\n  [ErrorNames.ast_behavior_not_found]: `Ast eval error: binding behavior \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_behavior_duplicated]: `Ast eval error: binding behavior \"{{0}}\" already applied.`,\n  [ErrorNames.ast_converter_not_found]: `Ast eval error: value converter \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_$host_not_found]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,\n  [ErrorNames.ast_no_assign_$host]: `Ast eval error: invalid assignment. \"$host\" is a reserved keyword.`,\n  [ErrorNames.ast_not_a_function]: `Ast eval error: expression is not a function.`,\n  [ErrorNames.ast_unknown_unary_operator]: `Ast eval error: unknown unary operator: \"{{0}}\"`,\n  [ErrorNames.ast_unknown_binary_operator]: `Ast eval error: unknown binary operator: \"{{0}}\"`,\n  [ErrorNames.ast_tagged_not_a_function]: `Ast eval error: left-hand side of tagged template expression is not a function.`,\n  [ErrorNames.ast_name_is_not_a_function]: `Ast eval error: expected \"{{0}}\" to be a function`,\n  [ErrorNames.ast_destruct_null]: `Ast eval error: cannot use non-object value for destructuring assignment.`,\n\n  [ErrorNames.parse_invalid_start]: `Expression error: invalid start: \"{{0}}\"`,\n  [ErrorNames.parse_no_spread]: `Expression error: spread operator is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_expected_identifier]: `Expression error: expected identifier: \"{{0}}\"`,\n  [ErrorNames.parse_invalid_member_expr]: `Expression error: invalid member expression: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_end]: `Expression error: unexpected end of expression: \"{{0}}\"`,\n  [ErrorNames.parse_unconsumed_token]: `Expression error: unconsumed token: \"{{0}}\" at position {{1}} of \"{{2}}\"`,\n  [ErrorNames.parse_invalid_empty]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,\n  [ErrorNames.parse_left_hand_side_not_assignable]: `Expression error: left hand side of expression is not assignable: \"{{0}}\"`,\n  [ErrorNames.parse_expected_converter_identifier]: `Expression error: expected identifier to come after value converter operator: \"{{0}}\"`,\n  [ErrorNames.parse_expected_behavior_identifier]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,\n  [ErrorNames.parse_unexpected_keyword_of]: `Expression error: unexpected keyword \"of\": \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_keyword_import]: `Expression error: unexpected keyword \"import\": \"{{0}}\"`,\n  [ErrorNames.parse_invalid_identifier_in_forof]: `Expression error: invalid BindingIdentifier at left hand side of \"of\": \"{{0}}\" | kind: {{1}}`,\n  [ErrorNames.parse_invalid_identifier_object_literal_key]: `Expression error: invalid or unsupported property definition in object literal: \"{{0}}\"`,\n  [ErrorNames.parse_unterminated_string]: `Expression error: unterminated quote in string literal: \"{{0}}\"`,\n  [ErrorNames.parse_unterminated_template_string]: `Expression error: unterminated template string: \"{{0}}\"`,\n  [ErrorNames.parse_missing_expected_token]: `Expression error: missing expected token \"{{0}}\" in \"{{1}}\"`,\n  [ErrorNames.parse_unexpected_character]: `Expression error: unexpected character: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_token_destructuring]: `Expression error: unexpected \"{{0}}\" at position \"{{1}}\" for destructuring assignment in \"{{2}}\"`,\n  [ErrorNames.parse_unexpected_token_optional_chain]: `Expression error: unexpected {{0}} at position \"{{1}}\" for optional chain in \"{{2}}\"`,\n  [ErrorNames.parse_invalid_tag_in_optional_chain]: `Expression error: invalid tagged template on optional chain in \"{{1}}\"`,\n  [ErrorNames.parse_invalid_arrow_params]: `Expression error: invalid arrow parameter list in \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_param_default_value]: `Expression error: arrow function with default parameters is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_param_destructuring]: `Expression error: arrow function with destructuring parameters is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_rest_must_be_last]: `Expression error: rest parameter must be last formal parameter in arrow function: \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_fn_body]: `Expression error: arrow function with function body is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_double_dot]: `Expression error: unexpected token '.' at position \"{{1}}\" in \"{{0}}\"`,\n\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n    let matches = regex.exec(cooked);\n    while (matches != null) {\n      const method = matches[1]?.slice(1);\n      let value = details[i] as any;\n      if (value != null) {\n        switch (method) {\n          case 'toString': value = Object.prototype.toString.call(value); break;\n          case 'join(!=)': value = (value as unknown[]).join('!='); break;\n          case 'element': value = value === '*' ? 'all elements' : `<${value} />`; break;\n          default: {\n            // property access\n            if (method?.startsWith('.')) {\n              value = safeString(value[method.slice(1)]);\n            } else {\n              value = safeString(value);\n            }\n          }\n        }\n      }\n      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);\n      matches = regex.exec(cooked);\n    }\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n", "/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\nimport {\n  AccessKeyedExpression,\n  AccessMemberExpression,\n  AccessScopeExpression,\n  AccessThisExpression,\n  ArrayBindingPattern,\n  ArrayLiteralExpression,\n  AssignExpression,\n  BinaryExpression,\n  BindingBehaviorExpression,\n  BindingIdentifier,\n  CallFunctionExpression,\n  CallMemberExpression,\n  CallScopeExpression,\n  ConditionalExpression,\n  CustomExpression,\n  ForOfStatement,\n  Interpolation,\n  ObjectBindingPattern,\n  ObjectLiteralExpression,\n  PrimitiveLiteralExpression,\n  TaggedTemplateExpression,\n  TemplateExpression,\n  UnaryExpression,\n  ValueConverterExpression,\n  AnyBindingExpression,\n  BinaryOperator,\n  BindingIdentifierOrPattern,\n  IsAssign,\n  IsAssignable,\n  IsBinary,\n  IsBindingBehavior,\n  IsExpressionOrStatement,\n  IsLeftHandSide,\n  IsValueConverter,\n  UnaryOperator,\n  DestructuringAssignmentSingleExpression as DASE,\n  DestructuringAssignmentExpression as DAE,\n  ArrowFunction,\n  AccessGlobalExpression,\n  CallGlobalExpression,\n  type ExpressionKind,\n  ekAccessThis,\n  ekAccessGlobal,\n  ekAccessMember,\n  ekAccessScope,\n  ekArrayDestructuring,\n  ekArrayBindingPattern,\n  ekObjectBindingPattern,\n  ekBindingIdentifier,\n  ekObjectDestructuring,\n  AccessBoundaryExpression,\n  AssignmentOperator,\n  NewExpression,\n} from './ast';\nimport { createLookup } from './utilities';\nimport { ErrorNames, createMappedError } from './errors';\nimport { createImplementationRegister, DI } from '@aurelia/kernel';\n\nexport interface IExpressionParser<TCustom extends CustomExpression = CustomExpression> {\n  parse(expression: string, expressionType: 'IsIterator'): ForOfStatement;\n  parse(expression: string, expressionType: 'Interpolation'): Interpolation;\n  parse(expression: string, expressionType: Exclude<ExpressionType, 'IsIterator' | 'Interpolation'>): IsBindingBehavior;\n  parse(expression: string, expressionType: ExpressionType): AnyBindingExpression<TCustom>;\n}\nexport const IExpressionParser = /*@__PURE__*/DI.createInterface<IExpressionParser>('IExpressionParser');\n\n/**\n * A default implementation of the IExpressionParser interface\n */\nexport class ExpressionParser<TCustom extends CustomExpression = CustomExpression> implements IExpressionParser<TCustom> {\n  public static readonly register = createImplementationRegister(IExpressionParser);\n\n  /** @internal */ private readonly _expressionLookup: Record<string, IsBindingBehavior> = createLookup();\n  /** @internal */ private readonly _forOfLookup: Record<string, ForOfStatement> = createLookup();\n  /** @internal */ private readonly _interpolationLookup: Record<string, Interpolation> = createLookup();\n\n  public parse(expression: string, expressionType: 'IsIterator'): ForOfStatement;\n  public parse(expression: string, expressionType: 'Interpolation'): Interpolation;\n  public parse(expression: string, expressionType: Exclude<ExpressionType, 'IsIterator' | 'Interpolation'>): IsBindingBehavior;\n  public parse(expression: string, expressionType: ExpressionType): AnyBindingExpression;\n  public parse(expression: string, expressionType: ExpressionType): AnyBindingExpression {\n    let found: AnyBindingExpression;\n    switch (expressionType) {\n      case etIsCustom:\n        return new CustomExpression(expression) as AnyBindingExpression;\n      case etInterpolation:\n        found = this._interpolationLookup[expression];\n        if (found === void 0) {\n          found = this._interpolationLookup[expression] = this.$parse(expression, expressionType);\n        }\n        return found;\n      case etIsIterator:\n        found = this._forOfLookup[expression];\n        if (found === void 0) {\n          found = this._forOfLookup[expression] = this.$parse(expression, expressionType);\n        }\n        return found;\n      default: {\n        if (expression.length === 0) {\n          if (expressionType === etIsFunction || expressionType === etIsProperty) {\n            return PrimitiveLiteralExpression.$empty;\n          }\n          throw invalidEmptyExpression();\n        }\n        found = this._expressionLookup[expression];\n        if (found === void 0) {\n          found = this._expressionLookup[expression] = this.$parse(expression, expressionType);\n        }\n        return found;\n      }\n    }\n  }\n\n  /** @internal */\n  private $parse(expression: string, expressionType: 'IsIterator'): ForOfStatement;\n  /** @internal */\n  private $parse(expression: string, expressionType: 'Interpolation'): Interpolation;\n  /** @internal */\n  private $parse(expression: string, expressionType: Exclude<ExpressionType, 'IsIterator' | 'Interpolation'>): IsBindingBehavior;\n  /** @internal */\n  private $parse(expression: string, expressionType: ExpressionType): AnyBindingExpression {\n    $input = expression;\n    $index = 0;\n    $length = expression.length;\n    $scopeDepth = 0;\n    $startIndex = 0;\n    $currentToken = Token.EOF;\n    $tokenValue = '';\n    $currentChar = $charCodeAt(0);\n    $assignable = true;\n    $optional = false;\n    $accessGlobal = true;\n    $semicolonIndex = -1;\n    return parse(Precedence.Variadic, expressionType === void 0 ? etIsProperty : expressionType);\n  }\n}\n\n_START_CONST_ENUM();\nconst enum Char {\n  Null           = 0x00,\n  Backspace      = 0x08,\n  Tab            = 0x09,\n  LineFeed       = 0x0A,\n  VerticalTab    = 0x0B,\n  FormFeed       = 0x0C,\n  CarriageReturn = 0x0D,\n  Space          = 0x20,\n  Exclamation    = 0x21,\n  DoubleQuote    = 0x22,\n  Dollar         = 0x24,\n  Percent        = 0x25,\n  Ampersand      = 0x26,\n  SingleQuote    = 0x27,\n  OpenParen      = 0x28,\n  CloseParen     = 0x29,\n  Asterisk       = 0x2A,\n  Plus           = 0x2B,\n  Comma          = 0x2C,\n  Minus          = 0x2D,\n  Dot            = 0x2E,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Backtick       = 0x60,\n  OpenBracket    = 0x5B,\n  Backslash      = 0x5C,\n  CloseBracket   = 0x5D,\n  Caret          = 0x5E,\n  Underscore     = 0x5F,\n  OpenBrace      = 0x7B,\n  Bar            = 0x7C,\n  CloseBrace     = 0x7D,\n  Colon          = 0x3A,\n  LessThan       = 0x3C,\n  Equals         = 0x3D,\n  GreaterThan    = 0x3E,\n  Question       = 0x3F,\n\n  Zero   = 0x30,\n  One    = 0x31,\n  Two    = 0x32,\n  Three  = 0x33,\n  Four   = 0x34,\n  Five   = 0x35,\n  Six    = 0x36,\n  Seven  = 0x37,\n  Eight  = 0x38,\n  Nine   = 0x39,\n\n  UpperA = 0x41,\n  UpperB = 0x42,\n  UpperC = 0x43,\n  UpperD = 0x44,\n  UpperE = 0x45,\n  UpperF = 0x46,\n  UpperG = 0x47,\n  UpperH = 0x48,\n  UpperI = 0x49,\n  UpperJ = 0x4A,\n  UpperK = 0x4B,\n  UpperL = 0x4C,\n  UpperM = 0x4D,\n  UpperN = 0x4E,\n  UpperO = 0x4F,\n  UpperP = 0x50,\n  UpperQ = 0x51,\n  UpperR = 0x52,\n  UpperS = 0x53,\n  UpperT = 0x54,\n  UpperU = 0x55,\n  UpperV = 0x56,\n  UpperW = 0x57,\n  UpperX = 0x58,\n  UpperY = 0x59,\n  UpperZ = 0x5A,\n\n  LowerA  = 0x61,\n  LowerB  = 0x62,\n  LowerC  = 0x63,\n  LowerD  = 0x64,\n  LowerE  = 0x65,\n  LowerF  = 0x66,\n  LowerG  = 0x67,\n  LowerH  = 0x68,\n  LowerI  = 0x69,\n  LowerJ  = 0x6A,\n  LowerK  = 0x6B,\n  LowerL  = 0x6C,\n  LowerM  = 0x6D,\n  LowerN  = 0x6E,\n  LowerO  = 0x6F,\n  LowerP  = 0x70,\n  LowerQ  = 0x71,\n  LowerR  = 0x72,\n  LowerS  = 0x73,\n  LowerT  = 0x74,\n  LowerU  = 0x75,\n  LowerV  = 0x76,\n  LowerW  = 0x77,\n  LowerX  = 0x78,\n  LowerY  = 0x79,\n  LowerZ  = 0x7A\n}\n_END_CONST_ENUM();\n\nfunction unescapeCode(code: number): number {\n  switch (code) {\n    case Char.LowerB: return Char.Backspace;\n    case Char.LowerT: return Char.Tab;\n    case Char.LowerN: return Char.LineFeed;\n    case Char.LowerV: return Char.VerticalTab;\n    case Char.LowerF: return Char.FormFeed;\n    case Char.LowerR: return Char.CarriageReturn;\n    case Char.DoubleQuote: return Char.DoubleQuote;\n    case Char.SingleQuote: return Char.SingleQuote;\n    case Char.Backslash: return Char.Backslash;\n    default: return code;\n  }\n}\n\n_START_CONST_ENUM();\nconst enum Precedence {\n  Variadic                = 0b0000_111101,\n  Assign                  = 0b0000_111110,\n  Conditional             = 0b0000_111111,\n  Assignment              = 0b0001_000000,\n  NullishCoalescing       = 0b0010_000000,\n  LogicalOR               = 0b0011_000000,\n  LogicalAND              = 0b0100_000000,\n  Equality                = 0b0101_000000,\n  Relational              = 0b0110_000000,\n  Additive                = 0b0111_000000,\n  Multiplicative          = 0b1000_000000,\n  Exponentiation          = 0b1001_000000,\n  Binary                  = 0b1001_000001,\n  Member                  = 0b1001_000010,\n  LeftHandSide            = 0b1001_000011,\n  Primary                 = 0b1001_000100,\n  Unary                   = 0b1001_000101,\n}\n_END_CONST_ENUM();\n\n_START_CONST_ENUM();\nconst enum Token {\n  EOF                     = 0b1100000000000_0000_000000,\n  ExpressionTerminal      = 0b1000000000000_0000_000000,\n  AccessScopeTerminal     = 0b0100000000000_0000_000000,\n  ClosingToken            = 0b0010000000000_0000_000000,\n  OpeningToken            = 0b0001000000000_0000_000000,\n  BinaryOp                = 0b0000100000000_0000_000000,\n  UnaryOp                 = 0b0000010000000_0000_000000,\n  LeftHandSide            = 0b0000001000000_0000_000000,\n  StringOrNumericLiteral  = 0b0000000110000_0000_000000,\n  NumericLiteral          = 0b0000000100000_0000_000000,\n  StringLiteral           = 0b0000000010000_0000_000000,\n  IdentifierName          = 0b0000000001100_0000_000000,\n  // Keyword              = 0b0000000001000_0000_000000,\n  Identifier              = 0b0000000000100_0000_000000,\n  Contextual              = 0b0000000000010_0000_000000,\n  OptionalSuffix          = 0b0000000001101_0000_000000,\n  Precedence              = 0b0000000000000_1111_000000,\n  Type                    = 0b0000000000000_0000_111111,\n  FalseKeyword            = 0b0000000001000_0000_000000,\n  TrueKeyword             = 0b0000000001000_0000_000001,\n  NullKeyword             = 0b0000000001000_0000_000010,\n  UndefinedKeyword        = 0b0000000001000_0000_000011,\n  NewKeyword              = 0b0000000001000_0000_000100,\n  ThisScope               = 0b0000000001100_0000_000101,\n  AccessBoundary          = 0b0000000001100_0000_000110,\n  // HostScope            = 0b0000000001100_0000_000111,\n  ParentScope             = 0b0000000001100_0000_001000,\n  OpenParen               = 0b0101001000001_0000_001001,\n  OpenBrace               = 0b0001000000000_0000_001010,\n  Dot                     = 0b0000001000000_0000_001011,\n  DotDot                  = 0b0000000000000_0000_001100,\n  DotDotDot               = 0b0000000000000_0000_001101,\n  QuestionDot             = 0b0100001000000_0000_001110,\n  CloseBrace              = 0b1110000000000_0000_001111,\n  CloseParen              = 0b1110000000000_0000_010000,\n  Comma                   = 0b1100000000000_0000_010011,\n  OpenBracket             = 0b0101001000001_0000_010100,\n  CloseBracket            = 0b1110000000000_0000_010101,\n  Colon                   = 0b1100000000000_0000_010110,\n  Semicolon               = 0b1100000000000_0000_010111,\n  Question                = 0b1100000000000_0000_011000,\n  Ampersand               = 0b1100000000000_0000_011001,\n  Bar                     = 0b1100000000000_0000_011010,\n  QuestionQuestion        = 0b1100100000000_0010_011011,\n  BarBar                  = 0b1100100000000_0011_011100,\n  AmpersandAmpersand      = 0b1100100000000_0100_011101,\n  EqualsEquals            = 0b1100100000000_0101_011110,\n  ExclamationEquals       = 0b1100100000000_0101_011111,\n  EqualsEqualsEquals      = 0b1100100000000_0101_100000,\n  ExclamationEqualsEquals = 0b1100100000000_0101_100001,\n  LessThan                = 0b1100100000000_0110_100010,\n  GreaterThan             = 0b1100100000000_0110_100011,\n  LessThanEquals          = 0b1100100000000_0110_100100,\n  GreaterThanEquals       = 0b1100100000000_0110_100101,\n  InKeyword               = 0b1100100001000_0110_100110,\n  InstanceOfKeyword       = 0b1100100001000_0110_100111,\n  Plus                    = 0b0100110000000_0111_101000,\n  Minus                   = 0b0100110000000_0111_101001,\n  TypeofKeyword           = 0b0000010001000_0000_101010,\n  VoidKeyword             = 0b0000010001000_0000_101011,\n  Asterisk                = 0b1100100000000_1000_101100,\n  Percent                 = 0b1100100000000_1000_101101,\n  Slash                   = 0b1100100000000_1000_101110,\n  AsteriskAsterisk        = 0b1100100000000_1001_101111,\n  Equals                  = 0b1000000000000_0000_110000,\n  Exclamation             = 0b0000010000000_0000_110001,\n  TemplateTail            = 0b0100001000001_0000_110010,\n  TemplateContinuation    = 0b0100001000001_0000_110011,\n  OfKeyword               = 0b1000000001010_0000_110100,\n  Arrow                   = 0b0000000000000_0000_110101,\n  PlusEquals              = 0b1000000000000_0000_110110,\n  MinusEquals             = 0b1000000000000_0000_110111,\n  AsteriskEquals          = 0b1000000000000_0000_111000,\n  SlashEquals             = 0b1000000000000_0000_111001,\n  PlusPlus                = 0b0100010000000_0000_111010,\n  MinusMinus              = 0b0100010000000_0000_111011,\n}\n_END_CONST_ENUM();\n\nconst $false = PrimitiveLiteralExpression.$false;\nconst $true = PrimitiveLiteralExpression.$true;\nconst $null = PrimitiveLiteralExpression.$null;\nconst $undefined = PrimitiveLiteralExpression.$undefined;\nconst $this = new AccessThisExpression(0);\nconst $parent = new AccessThisExpression(1);\nconst boundary = new AccessBoundaryExpression();\n\nconst etNone = 'None';\nconst etInterpolation = 'Interpolation';\nconst etIsIterator = 'IsIterator';\nconst etIsChainable = 'IsChainable';\nconst etIsFunction = 'IsFunction';\nconst etIsProperty = 'IsProperty';\nconst etIsCustom = 'IsCustom';\nexport type ExpressionType = 'None' | 'Interpolation' | 'IsIterator' | 'IsChainable' | 'IsFunction' | 'IsProperty' | 'IsCustom';\n\nlet $input: string = '';\nlet $index: number = 0;\nlet $length: number = 0;\nlet $scopeDepth: number = 0;\nlet $startIndex: number = 0;\nlet $currentToken: Token = Token.EOF;\nlet $tokenValue: string | number = '';\nlet $currentChar: number;\nlet $assignable: boolean = true;\nlet $optional: boolean = false;\nlet $accessGlobal: boolean = true;\nlet $semicolonIndex: number = -1;\n\nconst stringFromCharCode = String.fromCharCode;\nconst $charCodeAt = (index: number) => $input.charCodeAt(index);\n\nconst $tokenRaw = (): string => $input.slice($startIndex, $index);\n\nconst globalNames =\n  ('Infinity NaN isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent' +\n  ' Array BigInt Boolean Date Map Number Object RegExp Set String JSON Math Intl').split(' ');\n\nexport function parseExpression(input: string, expressionType?: ExpressionType): AnyBindingExpression {\n  $input = input;\n  $index = 0;\n  $length = input.length;\n  $scopeDepth = 0;\n  $startIndex = 0;\n  $currentToken = Token.EOF;\n  $tokenValue = '';\n  $currentChar = $charCodeAt(0);\n  $assignable = true;\n  $optional = false;\n  $accessGlobal = true;\n  $semicolonIndex = -1;\n  return parse(Precedence.Variadic, expressionType === void 0 ? etIsProperty : expressionType);\n}\n\n// This is performance-critical code which follows a subset of the well-known ES spec.\n// Knowing the spec, or parsers in general, will help with understanding this code and it is therefore not the\n// single source of information for being able to figure it out.\n// It generally does not need to change unless the spec changes or spec violations are found, or optimization\n// opportunities are found (which would likely not fix these warnings in any case).\n// It's therefore not considered to have any tangible impact on the maintainability of the code base.\n// For reference, most of the parsing logic is based on: https://tc39.github.io/ecma262/#sec-ecmascript-language-expressions\n// eslint-disable-next-line max-lines-per-function\nexport function parse(minPrecedence: Precedence, expressionType: ExpressionType): AnyBindingExpression {\n  if (expressionType === etIsCustom) {\n    return new CustomExpression($input);\n  }\n\n  if ($index === 0) {\n    if (expressionType === etInterpolation) {\n      return parseInterpolation();\n    }\n    nextToken();\n    if ($currentToken & Token.ExpressionTerminal) {\n      throw invalidStartOfExpression();\n    }\n  }\n\n  $assignable = Precedence.Binary > minPrecedence;\n  $optional = false;\n  $accessGlobal = Precedence.LeftHandSide > minPrecedence;\n  let optionalThisTail = false;\n  let result = void 0 as unknown as IsExpressionOrStatement;\n  let ancestor = 0;\n\n  if ($currentToken & Token.UnaryOp) {\n    /**\n     * parseUnaryExpression\n     *\n     * https://tc39.github.io/ecma262/#sec-unary-operators\n     *\n     * UnaryExpression :\n     * 1. LeftHandSideExpression\n     * 2. void UnaryExpression\n     * 3. typeof UnaryExpression\n     * 4. + UnaryExpression\n     * 5. - UnaryExpression\n     * 6. ! UnaryExpression\n     * 7. ++ UnaryExpression\n     * 8. -- UnaryExpression\n     *\n     * IsValidAssignmentTarget\n     * 2,3,4,5,6,7,8 = false\n     * 1 = see parseLeftHandSideExpression\n     *\n     * Note: technically we should throw on +++ / ---, but there's nothing to gain from that\n     */\n    const op = TokenValues[$currentToken & Token.Type] as UnaryOperator;\n    nextToken();\n    result = new UnaryExpression(op, parse(Precedence.LeftHandSide, expressionType) as IsLeftHandSide);\n    $assignable = false;\n  } else {\n    /**\n     * parsePrimaryExpression\n     *\n     * https://tc39.github.io/ecma262/#sec-primary-expression\n     *\n     * PrimaryExpression :\n     * 1. this\n     * 2. IdentifierName\n     * 3. Literal\n     * 4. ArrayLiteralExpression\n     * 5. ObjectLiteralExpression\n     * 6. TemplateLiteral\n     * 7. ParenthesizedExpression\n     *\n     * Literal :\n     * NullLiteral\n     * BooleanLiteral\n     * NumericLiteral\n     * StringLiteral\n     *\n     * ParenthesizedExpression :\n     * ( AssignmentExpression )\n     *\n     * IsValidAssignmentTarget\n     * 1,3,4,5,6,7 = false\n     * 2 = true\n     */\n    primary: switch ($currentToken) {\n      case Token.ParentScope: // $parent\n        ancestor = $scopeDepth;\n        $assignable = false;\n        $accessGlobal = false;\n        do {\n          nextToken();\n          ++ancestor;\n          switch (($currentToken as Token)) {\n            case Token.Dot:\n              nextToken();\n              if (($currentToken & Token.IdentifierName) === 0) {\n                throw expectedIdentifier();\n              }\n              break;\n            case Token.DotDot:\n            case Token.DotDotDot:\n              throw expectedIdentifier();\n            case Token.QuestionDot:\n              $optional = true;\n              nextToken();\n              if (($currentToken & Token.IdentifierName) === 0) {\n                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);\n                optionalThisTail = true;\n                break primary;\n              }\n              break;\n            default:\n              if ($currentToken & Token.AccessScopeTerminal) {\n                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);\n                break primary;\n              }\n              throw invalidMemberExpression();\n          }\n        } while ($currentToken === Token.ParentScope);\n        // falls through\n      case Token.Identifier: { // identifier\n        const id = $tokenValue as string;\n        if (expressionType === etIsIterator) {\n          result = new BindingIdentifier(id);\n        } else if ($accessGlobal && globalNames.includes(id as (typeof globalNames)[number])) {\n          result = new AccessGlobalExpression(id);\n        } else if ($accessGlobal && id === 'import') {\n          throw unexpectedImportKeyword();\n        } else {\n          result = new AccessScopeExpression(id, ancestor);\n        }\n        $assignable = !$optional;\n        nextToken();\n        if (consumeOpt(Token.Arrow)) {\n          if (($currentToken as Token) === Token.OpenBrace) {\n            throw functionBodyInArrowFn();\n          }\n          const _optional = $optional;\n          const _scopeDepth = $scopeDepth;\n          ++$scopeDepth;\n          const body = parse(Precedence.Assign, etNone) as IsAssign;\n          $optional = _optional;\n          $scopeDepth = _scopeDepth;\n          $assignable = false;\n          result = new ArrowFunction([new BindingIdentifier(id)], body);\n        }\n        break;\n      }\n      case Token.DotDot:\n        throw unexpectedDoubleDot();\n      case Token.DotDotDot:\n        throw invalidSpreadOp();\n      case Token.ThisScope: // $this\n        $assignable = false;\n        nextToken();\n        switch ($scopeDepth) {\n          case 0:\n            result = $this;\n            break;\n          case 1:\n            result = $parent;\n            break;\n          default:\n            result = new AccessThisExpression($scopeDepth);\n            break;\n        }\n        break;\n      case Token.AccessBoundary: // this\n        $assignable = false;\n        nextToken();\n        result = boundary;\n        break;\n      case Token.OpenParen:\n        result = parseCoverParenthesizedExpressionAndArrowParameterList(expressionType);\n        break;\n      case Token.OpenBracket:\n        result = $input.search(/\\s+of\\s+/) > $index ? parseArrayDestructuring() : parseArrayLiteralExpression(expressionType);\n        break;\n      case Token.OpenBrace:\n        result = parseObjectLiteralExpression(expressionType);\n        break;\n      case Token.TemplateTail:\n        result = new TemplateExpression([$tokenValue as string]);\n        $assignable = false;\n        nextToken();\n        break;\n      case Token.TemplateContinuation:\n        result = parseTemplate(expressionType, result as IsLeftHandSide, false);\n        break;\n      case Token.StringLiteral:\n      case Token.NumericLiteral:\n        result = new PrimitiveLiteralExpression($tokenValue);\n        $assignable = false;\n        nextToken();\n        break;\n      case Token.NullKeyword:\n      case Token.UndefinedKeyword:\n      case Token.TrueKeyword:\n      case Token.FalseKeyword:\n        result = TokenValues[$currentToken & Token.Type] as PrimitiveLiteralExpression;\n        $assignable = false;\n        nextToken();\n        break;\n      case Token.NewKeyword: {\n        nextToken();\n        const callee = parse(Precedence.Member, expressionType) as IsLeftHandSide;\n        let args: IsAssign[];\n        if (($currentToken as Token) === Token.OpenParen) {\n          args = parseArguments();\n        } else {\n          args = [];\n          nextToken();\n        }\n        result = new NewExpression(callee, args);\n        $assignable = false;\n        break;\n      }\n      default:\n        if ($index >= $length) {\n          throw unexpectedEndOfExpression();\n        } else {\n          throw unconsumedToken();\n        }\n    }\n\n    if (expressionType === etIsIterator) {\n      return parseForOfStatement(result as BindingIdentifierOrPattern);\n    }\n    switch ($currentToken as Token) {\n      case Token.PlusPlus:\n      case Token.MinusMinus:\n        result = new UnaryExpression(TokenValues[$currentToken & Token.Type] as UnaryOperator, result as IsLeftHandSide, 1);\n        nextToken();\n        $assignable = false;\n        break;\n    }\n    if (Precedence.LeftHandSide < minPrecedence) {\n      return result as any;\n    }\n\n    if (($currentToken as Token) === Token.DotDot || ($currentToken as Token) === Token.DotDotDot) {\n      throw expectedIdentifier();\n    }\n\n    if (result.$kind === ekAccessThis) {\n      switch ($currentToken as Token) {\n        case Token.QuestionDot:\n          $optional = true;\n          $assignable = false;\n          nextToken();\n          if (($currentToken & Token.OptionalSuffix) === 0) {\n            throw unexpectedTokenInOptionalChain();\n          }\n\n          if ($currentToken & Token.IdentifierName) {\n            result = new AccessScopeExpression($tokenValue as string, result.ancestor);\n            nextToken();\n          } else if (($currentToken as Token) === Token.OpenParen) {\n            result = new CallFunctionExpression(result as IsLeftHandSide, parseArguments(), true);\n          } else if (($currentToken as Token) === Token.OpenBracket) {\n            result = parseKeyedExpression(result, true);\n          } else {\n            throw invalidTaggedTemplateOnOptionalChain();\n          }\n          break;\n        case Token.Dot:\n          $assignable = !$optional;\n          nextToken();\n          if (($currentToken & Token.IdentifierName) === 0) {\n            throw expectedIdentifier();\n          }\n          result = new AccessScopeExpression($tokenValue as string, result.ancestor);\n          nextToken();\n          break;\n        case Token.DotDot:\n        case Token.DotDotDot:\n          throw expectedIdentifier();\n        case Token.OpenParen:\n          result = new CallFunctionExpression(result as IsLeftHandSide, parseArguments(), optionalThisTail);\n          break;\n        case Token.OpenBracket:\n          result = parseKeyedExpression(result, optionalThisTail);\n          break;\n        case Token.TemplateTail:\n          result = createTemplateTail(result as IsLeftHandSide);\n          break;\n        case Token.TemplateContinuation:\n          result = parseTemplate(expressionType, result as IsLeftHandSide, true);\n          break;\n      }\n    }\n\n    /**\n     * parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)\n     *\n     * MemberExpression :\n     * 1. PrimaryExpression\n     * 2. MemberExpression [ AssignmentExpression ]\n     * 3. MemberExpression . IdentifierName\n     * 4. MemberExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     * 1,4 = false\n     * 2,3 = true\n     *\n     *\n     * parseCallExpression (Token.OpenParen)\n     * CallExpression :\n     * 1. MemberExpression Arguments\n     * 2. CallExpression Arguments\n     * 3. CallExpression [ AssignmentExpression ]\n     * 4. CallExpression . IdentifierName\n     * 5. CallExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     * 1,2,5 = false\n     * 3,4 = true\n     */\n    while (($currentToken & Token.LeftHandSide) > 0) {\n      switch (($currentToken as Token)) {\n        case Token.QuestionDot:\n          result = parseOptionalChainLHS(result as IsLeftHandSide);\n          break;\n        case Token.Dot:\n          nextToken();\n          if (($currentToken & Token.IdentifierName) === 0) {\n            throw expectedIdentifier();\n          }\n          result = parseMemberExpressionLHS(result as IsLeftHandSide, false);\n          break;\n        case Token.DotDot:\n        case Token.DotDotDot:\n          throw expectedIdentifier();\n        case Token.OpenParen:\n          if (Precedence.Member === minPrecedence) {\n            return result as any;\n          }\n          if (result.$kind === ekAccessScope) {\n            result = new CallScopeExpression(result.name, parseArguments(), result.ancestor, false);\n          } else if (result.$kind === ekAccessMember) {\n            result = new CallMemberExpression(result.object, result.name, parseArguments(), result.optional, false);\n          } else if (result.$kind === ekAccessGlobal) {\n            result = new CallGlobalExpression(result.name, parseArguments());\n          } else {\n            result = new CallFunctionExpression(result as IsLeftHandSide, parseArguments(), false);\n          }\n          break;\n        case Token.OpenBracket:\n          result = parseKeyedExpression(result as IsLeftHandSide, false);\n          break;\n        case Token.TemplateTail:\n          if ($optional) {\n            throw invalidTaggedTemplateOnOptionalChain();\n          }\n          result = createTemplateTail(result as IsLeftHandSide);\n          break;\n        case Token.TemplateContinuation:\n          if ($optional) {\n            throw invalidTaggedTemplateOnOptionalChain();\n          }\n          result = parseTemplate(expressionType, result as IsLeftHandSide, true);\n          break;\n      }\n    }\n  }\n\n  if (($currentToken as Token) === Token.DotDot || ($currentToken as Token) === Token.DotDotDot) {\n    throw expectedIdentifier();\n  }\n\n  if (Precedence.Binary < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseBinaryExpression\n   *\n   * https://tc39.github.io/ecma262/#sec-multiplicative-operators\n   *\n   * MultiplicativeExpression : (local precedence 6)\n   * UnaryExpression\n   * MultiplicativeExpression * / % UnaryExpression\n   *\n   * AdditiveExpression : (local precedence 5)\n   * MultiplicativeExpression\n   * AdditiveExpression + - MultiplicativeExpression\n   *\n   * RelationalExpression : (local precedence 4)\n   * AdditiveExpression\n   * RelationalExpression < > <= >= instanceof in AdditiveExpression\n   *\n   * EqualityExpression : (local precedence 3)\n   * RelationalExpression\n   * EqualityExpression == != === !== RelationalExpression\n   *\n   * LogicalANDExpression : (local precedence 2)\n   * EqualityExpression\n   * LogicalANDExpression && EqualityExpression\n   *\n   * LogicalORExpression : (local precedence 1)\n   * LogicalANDExpression\n   * LogicalORExpression || LogicalANDExpression\n   *\n   * CoalesceExpression :\n   * CoalesceExpressionHead ?? BitwiseORExpression\n   *\n   * CoalesceExpressionHead :\n   * CoelesceExpression\n   * BitwiseORExpression\n   *\n   * ShortCircuitExpression :\n   * LogicalORExpression\n   * CoalesceExpression\n   */\n  while (($currentToken & Token.BinaryOp) > 0) {\n    const opToken = $currentToken;\n    if ((opToken & Token.Precedence) <= minPrecedence) {\n      break;\n    }\n    nextToken();\n    result = new BinaryExpression(TokenValues[opToken & Token.Type] as BinaryOperator, result as IsBinary, parse(opToken & Token.Precedence, expressionType) as IsBinary);\n    $assignable = false;\n  }\n  if (Precedence.Conditional < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseConditionalExpression\n   * https://tc39.github.io/ecma262/#prod-ConditionalExpression\n   *\n   * ConditionalExpression :\n   * 1. ShortCircuitExpression\n   * 2. ShortCircuitExpression ? AssignmentExpression : AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   * 1,2 = false\n   */\n\n  if (consumeOpt(Token.Question)) {\n    const yes = parse(Precedence.Assign, expressionType) as IsAssign;\n    consume(Token.Colon);\n    result = new ConditionalExpression(result as IsBinary, yes, parse(Precedence.Assign, expressionType) as IsAssign);\n    $assignable = false;\n  }\n  if (Precedence.Assign < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseAssignmentExpression\n   *\n   * https://tc39.github.io/ecma262/#prod-AssignmentExpression\n   * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator\n   *\n   * AssignmentExpression :\n   * 1. ConditionalExpression\n   * 2. LeftHandSideExpression = AssignmentExpression\n   * 3. LeftHandSideExpression AssignmentOperator AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   * 1,2 = false\n   */\n\n  switch ($currentToken as Token) {\n    case Token.Equals:\n    case Token.PlusEquals:\n    case Token.MinusEquals:\n    case Token.AsteriskEquals:\n    case Token.SlashEquals: {\n      if (!$assignable) {\n        throw lhsNotAssignable();\n      }\n      const op = TokenValues[$currentToken & Token.Type] as AssignmentOperator;\n      nextToken();\n      result = new AssignExpression(result as IsAssignable, parse(Precedence.Assign, expressionType) as IsAssign, op);\n      break;\n    }\n  }\n  if (Precedence.Variadic < minPrecedence) {\n    return result as any;\n  }\n\n  /**\n   * parseValueConverter\n   */\n  while (consumeOpt(Token.Bar)) {\n    if ($currentToken === Token.EOF) {\n      throw expectedValueConverterIdentifier();\n    }\n    const name = $tokenValue as string;\n    nextToken();\n    const args = new Array<IsAssign>();\n    while (consumeOpt(Token.Colon)) {\n      args.push(parse(Precedence.Assign, expressionType) as IsAssign);\n    }\n    result = new ValueConverterExpression(result as IsValueConverter, name, args);\n  }\n\n  /**\n   * parseBindingBehavior\n   */\n  while (consumeOpt(Token.Ampersand)) {\n    if ($currentToken === Token.EOF) {\n      throw expectedBindingBehaviorIdentifier();\n    }\n    const name = $tokenValue as string;\n    nextToken();\n    const args = new Array<IsAssign>();\n    while (consumeOpt(Token.Colon)) {\n      args.push(parse(Precedence.Assign, expressionType) as IsAssign);\n    }\n    result = new BindingBehaviorExpression(result as IsBindingBehavior, name, args);\n  }\n\n  if ($currentToken !== Token.EOF) {\n    if (expressionType === etInterpolation && $currentToken === Token.CloseBrace) {\n      return result as any;\n    }\n    if (expressionType === etIsChainable && $currentToken === Token.Semicolon) {\n      if ($index === $length) {\n        throw unconsumedToken();\n      }\n      $semicolonIndex = $index - 1;\n      return result as any;\n    }\n    if ($tokenRaw() === 'of') {\n      throw unexpectedOfKeyword();\n    }\n    throw unconsumedToken();\n  }\n  return result as any;\n}\n\n/**\n * [key,]\n * [key]\n * [,value]\n * [key,value]\n */\nfunction parseArrayDestructuring(): DAE {\n  const items: DASE[] = [];\n  const dae = new DAE(ekArrayDestructuring, items, void 0, void 0);\n  let target: string = '';\n  let $continue = true;\n  let index = 0;\n  while ($continue) {\n    nextToken();\n    switch ($currentToken) {\n      case Token.CloseBracket:\n        $continue = false;\n        addItem();\n        break;\n      case Token.Comma:\n        addItem();\n        break;\n      case Token.Identifier:\n        target = $tokenRaw();\n        break;\n      default:\n        throw unexpectedTokenInDestructuring();\n    }\n  }\n  consume(Token.CloseBracket);\n  return dae;\n\n  function addItem() {\n    if (target !== '') {\n      items.push(new DASE(new AccessMemberExpression($this, target), new AccessKeyedExpression($this, new PrimitiveLiteralExpression(index++)), void 0));\n      target = '';\n    } else {\n      index++;\n    }\n  }\n}\n\nfunction parseArguments() {\n  const _optional = $optional;\n\n  nextToken();\n  const args: IsAssign[] = [];\n  while (($currentToken as Token) !== Token.CloseParen) {\n    args.push(parse(Precedence.Assign, etNone) as IsAssign);\n    if (!consumeOpt(Token.Comma)) {\n      break;\n    }\n  }\n  consume(Token.CloseParen);\n\n  $assignable = false;\n  $optional = _optional;\n\n  return args;\n}\n\nfunction parseKeyedExpression(result: IsLeftHandSide, optional: boolean) {\n  const _optional = $optional;\n\n  nextToken();\n  result = new AccessKeyedExpression(result, parse(Precedence.Assign, etNone) as IsAssign, optional);\n  consume(Token.CloseBracket);\n\n  $assignable = !_optional;\n  $optional = _optional;\n\n  return result;\n}\n\nfunction parseOptionalChainLHS(lhs: IsLeftHandSide) {\n  $optional = true;\n  $assignable = false;\n  nextToken();\n  if (($currentToken & Token.OptionalSuffix) === 0) {\n    throw unexpectedTokenInOptionalChain();\n  }\n\n  if ($currentToken & Token.IdentifierName) {\n    return parseMemberExpressionLHS(lhs, true);\n  }\n\n  if (($currentToken as Token) === Token.OpenParen) {\n    if (lhs.$kind === ekAccessScope) {\n      return new CallScopeExpression(lhs.name, parseArguments(), lhs.ancestor, true);\n    } else if (lhs.$kind === ekAccessMember) {\n      return new CallMemberExpression(lhs.object, lhs.name, parseArguments(), lhs.optional, true);\n    } else {\n      return new CallFunctionExpression(lhs, parseArguments(), true);\n    }\n  }\n\n  if (($currentToken as Token) === Token.OpenBracket) {\n    return parseKeyedExpression(lhs, true);\n  }\n\n  throw invalidTaggedTemplateOnOptionalChain();\n}\n\nfunction parseMemberExpressionLHS(lhs: IsLeftHandSide, optional: boolean) {\n  const rhs = $tokenValue as string;\n  switch (($currentToken as Token)) {\n    case Token.QuestionDot: {\n      $optional = true;\n      $assignable = false;\n\n      const indexSave = $index;\n      const startIndexSave = $startIndex;\n      const currentTokenSave = $currentToken;\n      const currentCharSave = $currentChar;\n      const tokenValueSave = $tokenValue;\n      const assignableSave = $assignable;\n      const optionalSave = $optional;\n\n      nextToken();\n      if (($currentToken & Token.OptionalSuffix) === 0) {\n        throw unexpectedTokenInOptionalChain();\n      }\n\n      if (($currentToken as Token) === Token.OpenParen) {\n        return new CallMemberExpression(lhs, rhs, parseArguments(), optional, true);\n      }\n\n      $index = indexSave;\n      $startIndex = startIndexSave;\n      $currentToken = currentTokenSave;\n      $currentChar = currentCharSave;\n      $tokenValue = tokenValueSave;\n      $assignable = assignableSave;\n      $optional = optionalSave;\n\n      return new AccessMemberExpression(lhs, rhs, optional);\n    }\n    case Token.OpenParen: {\n      $assignable = false;\n      return new CallMemberExpression(lhs, rhs, parseArguments(), optional, false);\n    }\n    default: {\n      $assignable = !$optional;\n      nextToken();\n      return new AccessMemberExpression(lhs, rhs, optional);\n    }\n  }\n}\n\n_START_CONST_ENUM();\nconst enum ArrowFnParams {\n  Valid         = 1,\n  Invalid       = 2,\n  Default       = 3,\n  Destructuring = 4,\n}\n_END_CONST_ENUM();\n\n/**\n * https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n * CoverParenthesizedExpressionAndArrowParameterList :\n * ( Expression )\n * ( )\n * ( BindingIdentifier )\n * ( Expression , BindingIdentifier )\n */\nfunction parseCoverParenthesizedExpressionAndArrowParameterList(expressionType: ExpressionType): IsAssign {\n  nextToken();\n\n  const indexSave = $index;\n  const startIndexSave = $startIndex;\n  const currentTokenSave = $currentToken;\n  const currentCharSave = $currentChar;\n  const tokenValueSave = $tokenValue;\n  const optionalSave = $optional;\n\n  const arrowParams: BindingIdentifier[] = [];\n  let paramsState = ArrowFnParams.Valid;\n  let isParamList = false;\n\n  // eslint-disable-next-line no-constant-condition\n  loop: while (true) {\n    if (($currentToken as Token) === Token.DotDotDot) {\n      nextToken();\n      if (($currentToken as Token) !== Token.Identifier) {\n        throw expectedIdentifier();\n      }\n      arrowParams.push(new BindingIdentifier($tokenValue as string));\n\n      nextToken();\n      if (($currentToken as Token) === Token.Comma) {\n        throw restParamsMustBeLastParam();\n      }\n\n      if (($currentToken as Token) !== Token.CloseParen) {\n        throw invalidSpreadOp();\n      }\n\n      nextToken();\n      if (($currentToken as Token) !== Token.Arrow) {\n        throw invalidSpreadOp();\n      }\n\n      nextToken();\n      const _optional = $optional;\n      const _scopeDepth = $scopeDepth;\n      ++$scopeDepth;\n      const body = parse(Precedence.Assign, etNone) as IsAssign;\n      $optional = _optional;\n      $scopeDepth = _scopeDepth;\n      $assignable = false;\n      return new ArrowFunction(arrowParams, body, true);\n    }\n\n    switch ($currentToken as Token) {\n      case Token.Identifier:\n        arrowParams.push(new BindingIdentifier($tokenValue as string));\n        nextToken();\n        break;\n      case Token.CloseParen:\n        // ()     - only valid if followed directly by an arrow\n        nextToken();\n        break loop;\n      /* eslint-disable */\n      case Token.OpenBrace:\n        // ({     - may be a valid parenthesized expression\n      case Token.OpenBracket:\n        // ([     - may be a valid parenthesized expression\n        nextToken();\n        paramsState = ArrowFnParams.Destructuring;\n        break;\n      /* eslint-enable */\n      case Token.Comma:\n        // (,     - never valid\n        // (a,,   - never valid\n        paramsState = ArrowFnParams.Invalid;\n        isParamList = true;\n        break loop;\n      case Token.OpenParen:\n        // ((     - may be a valid nested parenthesized expression or arrow fn\n        // (a,(   - never valid\n        paramsState = ArrowFnParams.Invalid;\n        break loop;\n      default:\n        nextToken();\n        paramsState = ArrowFnParams.Invalid;\n        break;\n    }\n\n    switch ($currentToken) {\n      case Token.Comma:\n        nextToken();\n        isParamList = true;\n        if (paramsState === ArrowFnParams.Valid) {\n          break;\n        }\n        // ([something invalid],   - treat as arrow fn / invalid arrow params\n        break loop;\n      case Token.CloseParen:\n        nextToken();\n        break loop;\n      case Token.Equals:\n        // (a=a     - may be a valid parenthesized expression\n        if (paramsState === ArrowFnParams.Valid) {\n          paramsState = ArrowFnParams.Default;\n        }\n        break loop;\n      case Token.Arrow:\n        // (a,a=>  - never valid\n        if (isParamList) {\n          throw invalidArrowParameterList();\n        }\n        // (a=>    - may be a valid parenthesized expression with nested arrow fn\n        nextToken();\n        paramsState = ArrowFnParams.Invalid;\n        break loop;\n      default:\n        if (paramsState === ArrowFnParams.Valid) {\n          paramsState = ArrowFnParams.Invalid;\n        }\n        break loop;\n    }\n  }\n\n  if ($currentToken === Token.Arrow) {\n    if (paramsState === ArrowFnParams.Valid) {\n      nextToken();\n      if (($currentToken as Token) === Token.OpenBrace) {\n        throw functionBodyInArrowFn();\n      }\n      const _optional = $optional;\n      const _scopeDepth = $scopeDepth;\n      ++$scopeDepth;\n      const body = parse(Precedence.Assign, etNone) as IsAssign;\n      $optional = _optional;\n      $scopeDepth = _scopeDepth;\n      $assignable = false;\n      return new ArrowFunction(arrowParams, body);\n    }\n    throw invalidArrowParameterList();\n  } else if (paramsState === ArrowFnParams.Valid && arrowParams.length === 0) {\n    // ()    - never valid as a standalone expression\n    throw missingExpectedToken(Token.Arrow);\n  }\n\n  if (isParamList) {\n    // ([something invalid],   - treat as arrow fn / invalid arrow params\n    switch (paramsState) {\n      case ArrowFnParams.Invalid:\n        throw invalidArrowParameterList();\n      case ArrowFnParams.Default:\n        throw defaultParamsInArrowFn();\n      case ArrowFnParams.Destructuring:\n        throw destructuringParamsInArrowFn();\n    }\n  }\n\n  $index = indexSave;\n  $startIndex = startIndexSave;\n  $currentToken = currentTokenSave;\n  $currentChar = currentCharSave;\n  $tokenValue = tokenValueSave;\n  $optional = optionalSave;\n\n  const _optional = $optional;\n  const expr = parse(Precedence.Assign, expressionType) as IsAssign;\n  $optional = _optional;\n  consume(Token.CloseParen);\n\n  if ($currentToken === Token.Arrow) {\n    // we only get here if there was a valid parenthesized expression which was not valid as arrow fn params\n    switch (paramsState) {\n      case ArrowFnParams.Invalid:\n        throw invalidArrowParameterList();\n      case ArrowFnParams.Default:\n        throw defaultParamsInArrowFn();\n      case ArrowFnParams.Destructuring:\n        throw destructuringParamsInArrowFn();\n    }\n  }\n\n  return expr;\n}\n\n/**\n * parseArrayLiteralExpression\n * https://tc39.github.io/ecma262/#prod-ArrayLiteralExpression\n *\n * ArrayLiteralExpression :\n * [ Elision(opt) ]\n * [ ElementList ]\n * [ ElementList, Elision(opt) ]\n *\n * ElementList :\n * Elision(opt) AssignmentExpression\n * ElementList, Elision(opt) AssignmentExpression\n *\n * Elision :\n * ,\n * Elision ,\n */\nfunction parseArrayLiteralExpression(expressionType: ExpressionType): ArrayBindingPattern | ArrayLiteralExpression {\n  const _optional = $optional;\n\n  nextToken();\n  const elements = new Array<IsAssign>();\n  while ($currentToken !== Token.CloseBracket) {\n    if (consumeOpt(Token.Comma)) {\n      elements.push($undefined);\n      if (($currentToken as Token) === Token.CloseBracket) {\n        break;\n      }\n    } else {\n      elements.push(parse(Precedence.Assign, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n      if (consumeOpt(Token.Comma)) {\n        if (($currentToken as Token) === Token.CloseBracket) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  $optional = _optional;\n\n  consume(Token.CloseBracket);\n  if (expressionType === etIsIterator) {\n    return new ArrayBindingPattern(elements);\n  } else {\n    $assignable = false;\n    return new ArrayLiteralExpression(elements);\n  }\n}\n\nconst allowedForExprKinds: ExpressionKind[] = [ekArrayBindingPattern, ekObjectBindingPattern, ekBindingIdentifier, ekArrayDestructuring, ekObjectDestructuring];\nfunction parseForOfStatement(result: BindingIdentifierOrPattern): ForOfStatement {\n  if (!allowedForExprKinds.includes(result.$kind)) {\n    throw invalidLHSBindingIdentifierInForOf(result.$kind);\n  }\n  if ($currentToken !== Token.OfKeyword) {\n    throw invalidLHSBindingIdentifierInForOf(result.$kind);\n  }\n  nextToken();\n  const declaration = result;\n  const statement = parse(Precedence.Variadic, etIsChainable);\n  return new ForOfStatement(declaration, statement as IsBindingBehavior, $semicolonIndex);\n}\n\n/**\n * parseObjectLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * ObjectLiteralExpression :\n * { }\n * { PropertyDefinitionList }\n *\n * PropertyDefinitionList :\n * PropertyDefinition\n * PropertyDefinitionList, PropertyDefinition\n *\n * PropertyDefinition :\n * IdentifierName\n * PropertyName : AssignmentExpression\n *\n * PropertyName :\n * IdentifierName\n * StringLiteral\n * NumericLiteral\n */\nfunction parseObjectLiteralExpression(expressionType: ExpressionType): ObjectBindingPattern | ObjectLiteralExpression {\n  const _optional = $optional;\n\n  const keys = new Array<string | number>();\n  const values = new Array<IsAssign>();\n  nextToken();\n  while ($currentToken !== Token.CloseBrace) {\n    keys.push($tokenValue);\n    // Literal = mandatory colon\n    if ($currentToken & Token.StringOrNumericLiteral) {\n      nextToken();\n      consume(Token.Colon);\n      values.push(parse(Precedence.Assign, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n    } else if ($currentToken & Token.IdentifierName) {\n      // IdentifierName = optional colon\n      const currentChar = $currentChar;\n      const currentToken = $currentToken;\n      const index = $index;\n      nextToken();\n      if (consumeOpt(Token.Colon)) {\n        values.push(parse(Precedence.Assign, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n      } else {\n        // Shorthand\n        $currentChar = currentChar;\n        $currentToken = currentToken;\n        $index = index;\n        values.push(parse(Precedence.Primary, expressionType === etIsIterator ? etNone : expressionType) as IsAssign);\n      }\n    } else {\n      throw invalidPropDefInObjLiteral();\n    }\n    if (($currentToken as Token) !== Token.CloseBrace) {\n      consume(Token.Comma);\n    }\n  }\n\n  $optional = _optional;\n\n  consume(Token.CloseBrace);\n  if (expressionType === etIsIterator) {\n    return new ObjectBindingPattern(keys, values);\n  } else {\n    $assignable = false;\n    return new ObjectLiteralExpression(keys, values);\n  }\n}\n\nfunction parseInterpolation(): Interpolation {\n  const parts = [];\n  const expressions: (IsBindingBehavior | Interpolation)[] = [];\n  const length = $length;\n  let result = '';\n  while ($index < length) {\n    switch ($currentChar) {\n      case Char.Dollar:\n        if ($charCodeAt($index + 1) === Char.OpenBrace) {\n          parts.push(result);\n          result = '';\n\n          $index += 2;\n          $currentChar = $charCodeAt($index);\n          nextToken();\n          const expression = parse(Precedence.Variadic, etInterpolation) as IsBindingBehavior | Interpolation;\n          expressions.push(expression);\n          continue;\n        } else {\n          result += '$';\n        }\n        break;\n      case Char.Backslash:\n        result += stringFromCharCode(unescapeCode(nextChar()));\n        break;\n      default:\n        result += stringFromCharCode($currentChar);\n    }\n    nextChar();\n  }\n  if (expressions.length) {\n    parts.push(result);\n    return new Interpolation(parts, expressions as IsBindingBehavior[]);\n  }\n  return null!;\n}\n\n/**\n * parseTemplateLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * TemplateExpression :\n * NoSubstitutionTemplate\n * TemplateHead\n *\n * NoSubstitutionTemplate :\n * ` TemplateCharacters(opt) `\n *\n * TemplateHead :\n * ` TemplateCharacters(opt) ${\n *\n * TemplateSubstitutionTail :\n * TemplateMiddle\n * TemplateTail\n *\n * TemplateMiddle :\n * } TemplateCharacters(opt) ${\n *\n * TemplateTail :\n * } TemplateCharacters(opt) `\n *\n * TemplateCharacters :\n * TemplateCharacter TemplateCharacters(opt)\n *\n * TemplateCharacter :\n * $ [lookahead  {]\n * \\ EscapeSequence\n * SourceCharacter (but not one of ` or \\ or $)\n */\nfunction parseTemplate(expressionType: ExpressionType, result: IsLeftHandSide, tagged: boolean): TaggedTemplateExpression | TemplateExpression {\n  const _optional = $optional;\n\n  const cooked = [$tokenValue as string];\n  // TODO: properly implement raw parts / decide whether we want this\n  consume(Token.TemplateContinuation);\n  const expressions = [parse(Precedence.Assign, expressionType) as IsAssign];\n  while (($currentToken = scanTemplateTail()) !== Token.TemplateTail) {\n    cooked.push($tokenValue as string);\n    consume(Token.TemplateContinuation);\n    expressions.push(parse(Precedence.Assign, expressionType) as IsAssign);\n  }\n  cooked.push($tokenValue as string);\n\n  $assignable = false;\n  $optional = _optional;\n  if (tagged) {\n    nextToken();\n    return new TaggedTemplateExpression(cooked, cooked, result, expressions);\n  } else {\n    nextToken();\n    return new TemplateExpression(cooked, expressions);\n  }\n}\n\nfunction createTemplateTail(result: IsLeftHandSide) {\n  $assignable = false;\n  const strings = [$tokenValue as string];\n  nextToken();\n  return new TaggedTemplateExpression(strings, strings, result);\n}\n\nfunction nextToken(): void {\n  while ($index < $length) {\n    $startIndex = $index;\n    if (($currentToken = (CharScanners[$currentChar]()) as Token) != null) { // a null token means the character must be skipped\n      return;\n    }\n  }\n  $currentToken = Token.EOF;\n}\n\nfunction nextChar(): number {\n  return $currentChar = $charCodeAt(++$index);\n}\n\nfunction scanIdentifier(): Token {\n  // run to the next non-idPart\n  while (IdParts[nextChar()]);\n\n  const token: Token|undefined = KeywordLookup[$tokenValue = $tokenRaw()];\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n  return token === undefined ? Token.Identifier : token;\n}\n\nfunction scanNumber(isFloat: boolean): Token {\n  let char = $currentChar;\n  if (isFloat === false) {\n    do {\n      char = nextChar();\n    } while (char <= Char.Nine && char >= Char.Zero);\n\n    if (char !== Char.Dot) {\n      $tokenValue = parseInt($tokenRaw(), 10);\n      return Token.NumericLiteral;\n    }\n    // past this point it's always a float\n    char = nextChar();\n    if ($index >= $length) {\n      // unless the number ends with a dot - that behaves a little different in native ES expressions\n      // but in our AST that behavior has no effect because numbers are always stored in variables\n      $tokenValue = parseInt($tokenRaw().slice(0, -1), 10);\n      return Token.NumericLiteral;\n    }\n  }\n\n  if (char <= Char.Nine && char >= Char.Zero) {\n    do {\n      char = nextChar();\n    } while (char <= Char.Nine && char >= Char.Zero);\n  } else {\n    $currentChar = $charCodeAt(--$index);\n  }\n\n  $tokenValue = parseFloat($tokenRaw());\n  return Token.NumericLiteral;\n}\n\nfunction scanString(): Token {\n  const quote = $currentChar;\n  nextChar(); // Skip initial quote.\n\n  let unescaped = 0;\n  const buffer = new Array<string>();\n  let marker = $index;\n\n  while ($currentChar !== quote) {\n    if ($currentChar === Char.Backslash) {\n      buffer.push($input.slice(marker, $index));\n      nextChar();\n      unescaped = unescapeCode($currentChar);\n      nextChar();\n      buffer.push(stringFromCharCode(unescaped));\n      marker = $index;\n    } else if ($index >= $length) {\n      throw unterminatedStringLiteral();\n    } else {\n      nextChar();\n    }\n  }\n\n  const last = $input.slice(marker, $index);\n  nextChar(); // Skip terminating quote.\n\n  // Compute the unescaped string value.\n  buffer.push(last);\n  const unescapedStr = buffer.join('');\n\n  $tokenValue = unescapedStr;\n  return Token.StringLiteral;\n}\n\nfunction scanTemplate(): Token {\n  let tail = true;\n  let result = '';\n\n  while (nextChar() !== Char.Backtick) {\n    if ($currentChar === Char.Dollar) {\n      if (($index + 1) < $length && $charCodeAt($index + 1) === Char.OpenBrace) {\n        $index++;\n        tail = false;\n        break;\n      } else {\n        result += '$';\n      }\n    } else if ($currentChar === Char.Backslash) {\n      result += stringFromCharCode(unescapeCode(nextChar()));\n    } else {\n      if ($index >= $length) {\n        throw unterminatedTemplateLiteral();\n      }\n      result += stringFromCharCode($currentChar);\n    }\n  }\n\n  nextChar();\n  $tokenValue = result;\n  if (tail) {\n    return Token.TemplateTail;\n  }\n  return Token.TemplateContinuation;\n}\n\nconst scanTemplateTail = (): Token => {\n  if ($index >= $length) {\n    throw unterminatedTemplateLiteral();\n  }\n  $index--;\n  return scanTemplate();\n};\n\nconst consumeOpt = (token: Token): boolean => {\n  if ($currentToken === token) {\n    nextToken();\n    return true;\n  }\n\n  return false;\n};\n\nconst consume = (token: Token): void => {\n  if ($currentToken === token) {\n    nextToken();\n  } else {\n    throw missingExpectedToken(token);\n  }\n};\n\n// #region errors\n\nconst invalidStartOfExpression = () => createMappedError(ErrorNames.parse_invalid_start, $input);\n\nconst invalidSpreadOp = () => createMappedError(ErrorNames.parse_no_spread, $input);\n\nconst expectedIdentifier = () => createMappedError(ErrorNames.parse_expected_identifier, $input);\n\nconst invalidMemberExpression = () => createMappedError(ErrorNames.parse_invalid_member_expr, $input);\n\nconst unexpectedEndOfExpression = () => createMappedError(ErrorNames.parse_unexpected_end, $input);\n\nconst unconsumedToken = () => createMappedError(ErrorNames.parse_unconsumed_token, $tokenRaw(), $index, $input);\n\nconst invalidEmptyExpression = () => createMappedError(ErrorNames.parse_invalid_empty);\n\nconst lhsNotAssignable = () => createMappedError(ErrorNames.parse_left_hand_side_not_assignable, $input);\n\nconst expectedValueConverterIdentifier = () => createMappedError(ErrorNames.parse_expected_converter_identifier, $input);\n\nconst expectedBindingBehaviorIdentifier = () => createMappedError(ErrorNames.parse_expected_behavior_identifier, $input);\n\nconst unexpectedOfKeyword = () => createMappedError(ErrorNames.parse_unexpected_keyword_of, $input);\n\nconst unexpectedImportKeyword = () => createMappedError(ErrorNames.parse_unexpected_keyword_import, $input);\n\nconst invalidLHSBindingIdentifierInForOf = (kind: unknown) => createMappedError(ErrorNames.parse_invalid_identifier_in_forof, $input, kind);\n\nconst invalidPropDefInObjLiteral = () => createMappedError(ErrorNames.parse_invalid_identifier_object_literal_key, $input);\n\nconst unterminatedStringLiteral = () => createMappedError(ErrorNames.parse_unterminated_string, $input);\n\nconst unterminatedTemplateLiteral = () => createMappedError(ErrorNames.parse_unterminated_template_string, $input);\n\nconst missingExpectedToken = (token: Token) =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_missing_expected_token, TokenValues[token & Token.Type], $input)\n    : createMappedError(ErrorNames.parse_missing_expected_token, $input);\n\nconst unexpectedTokenInDestructuring = () =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_unexpected_token_destructuring, $tokenRaw(), $index, $input)\n    : createMappedError(ErrorNames.parse_unexpected_token_destructuring, $input);\n\nconst unexpectedTokenInOptionalChain = () =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_unexpected_token_optional_chain, $tokenRaw(), $index - 1, $input)\n    : createMappedError(ErrorNames.parse_unexpected_token_optional_chain, $input);\n\nconst invalidTaggedTemplateOnOptionalChain = () => createMappedError(ErrorNames.parse_invalid_tag_in_optional_chain, $input);\n\nconst invalidArrowParameterList = () => createMappedError(ErrorNames.parse_invalid_arrow_params, $input);\n\nconst defaultParamsInArrowFn = () => createMappedError(ErrorNames.parse_no_arrow_param_default_value, $input);\n\nconst destructuringParamsInArrowFn = () => createMappedError(ErrorNames.parse_no_arrow_param_destructuring, $input);\n\nconst restParamsMustBeLastParam = () => createMappedError(ErrorNames.parse_rest_must_be_last, $input);\n\nconst functionBodyInArrowFn = () => createMappedError(ErrorNames.parse_no_arrow_fn_body, $input);\n\nconst unexpectedDoubleDot = () =>\n  __DEV__\n    ? createMappedError(ErrorNames.parse_unexpected_double_dot, $index - 1, $input)\n    : createMappedError(ErrorNames.parse_unexpected_double_dot, $input);\n\n// #endregion\n\n/**\n * Array for mapping tokens to token values. The indices of the values\n * correspond to the token bits 0-38.\n * For this to work properly, the values in the array must be kept in\n * the same order as the token bits.\n * Usage: TokenValues[token & Token.Type]\n */\nconst TokenValues = [\n  $false, $true, $null, $undefined, 'new', 'this', '$this', null/* '$host' */, '$parent',\n\n  '(', '{', '.', '..', '...', '?.', '}', ')', ',', '[', ']', ':', ';', '?', '\\'', '\"',\n\n  '&', '|', '??', '||', '&&', '==', '!=', '===', '!==', '<', '>',\n  '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '**', '=', '!',\n  Token.TemplateTail, Token.TemplateContinuation,\n  'of', '=>', '+=', '-=', '*=', '/=', '++', '--'\n];\n\nconst KeywordLookup: Record<string, Token> = /*@__PURE__*/ Object.assign(createLookup<Token>(), {\n  true: Token.TrueKeyword,\n  null: Token.NullKeyword,\n  false: Token.FalseKeyword,\n  undefined: Token.UndefinedKeyword,\n  new: Token.NewKeyword,\n  this: Token.AccessBoundary,\n  $this: Token.ThisScope,\n  $parent: Token.ParentScope,\n  in: Token.InKeyword,\n  instanceof: Token.InstanceOfKeyword,\n  typeof: Token.TypeofKeyword,\n  void: Token.VoidKeyword,\n  of: Token.OfKeyword,\n});\n\n// Character scanning function lookup\nconst {\n  CharScanners,\n  IdParts,\n} = /*@__PURE__*/ (() => {\n  type CharScanner = (() => Token | null) & { notMapped?: boolean };\n\n  const unexpectedCharacter: CharScanner = () => {\n    throw createMappedError(ErrorNames.parse_unexpected_character, $input);\n  };\n  unexpectedCharacter.notMapped = true;\n\n  /**\n   * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)\n   * Single values are denoted by the second value being a 0\n   *\n   * Copied from output generated with \"node build/generate-unicode.js\"\n   *\n   * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n   */\n  const codes = {\n    /* [$0-9A-Za_a-z] */\n    AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],\n    IdStart: /* IdentifierStart */[0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],\n    Digit: /* DecimalNumber */[0x30, 0x3A],\n    Skip: /* Skippable */[0, 0x21, 0x7F, 0xA1]\n  };\n\n  /**\n   * Decompress the ranges into an array of numbers so that the char code\n   * can be used as an index to the lookup\n   */\n  const decompress = (lookup: (CharScanner | number)[] | null, $set: Set<number> | null, compressed: number[], value: CharScanner | number | boolean): void => {\n    const rangeCount = compressed.length;\n    for (let i = 0; i < rangeCount; i += 2) {\n      const start = compressed[i];\n      let end = compressed[i + 1];\n      end = end > 0 ? end : start + 1;\n      if (lookup) {\n        lookup.fill(value as CharScanner | number, start, end);\n      }\n      if ($set) {\n        for (let ch = start; ch < end; ch++) {\n          $set.add(ch);\n        }\n      }\n    }\n  };\n\n  // // ASCII IdentifierPart lookup\n  // const AsciiIdParts = ((AsciiIdParts) => {\n  //   decompress(null, AsciiIdParts, codes.AsciiIdPart, true);\n  //   return AsciiIdParts;\n  // })(new Set<number>());\n\n  // IdentifierPart lookup\n  const IdParts = /*@__PURE__*/ ((IdParts) => {\n    decompress(IdParts as any, null, codes.IdStart, 1);\n    decompress(IdParts as any, null, codes.Digit, 1);\n    return IdParts;\n  })(new Uint8Array(0xFFFF));\n\n  // CharFuncLookup functions\n  const returnToken = (token: Token): () => Token =>\n    () => {\n      nextChar();\n      return token;\n    };\n\n  const CharScanners = new Array<CharScanner>(0xFFFF);\n  CharScanners.fill(unexpectedCharacter, 0, 0xFFFF);\n\n  decompress(CharScanners, null, codes.Skip, () => {\n    nextChar();\n    return null;\n  });\n  decompress(CharScanners, null, codes.IdStart, scanIdentifier);\n  decompress(CharScanners, null, codes.Digit, () => scanNumber(false));\n\n  CharScanners[Char.DoubleQuote] =\n  CharScanners[Char.SingleQuote] = () => {\n    return scanString();\n  };\n  CharScanners[Char.Backtick] = () => {\n    return scanTemplate();\n  };\n\n  // !, !=, !==\n  CharScanners[Char.Exclamation] = () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.Exclamation;\n    }\n    if (nextChar() !== Char.Equals) {\n      return Token.ExclamationEquals;\n    }\n    nextChar();\n    return Token.ExclamationEqualsEquals;\n  };\n\n  // =, ==, ===, =>\n  CharScanners[Char.Equals] =  () => {\n    if (nextChar() === Char.GreaterThan) {\n      nextChar();\n      return Token.Arrow;\n    }\n    if ($currentChar !== Char.Equals) {\n      return Token.Equals;\n    }\n    if (nextChar() !== Char.Equals) {\n      return Token.EqualsEquals;\n    }\n    nextChar();\n    return Token.EqualsEqualsEquals;\n  };\n\n  // &, &&\n  CharScanners[Char.Ampersand] = () => {\n    if (nextChar() !== Char.Ampersand) {\n      return Token.Ampersand;\n    }\n    nextChar();\n    return Token.AmpersandAmpersand;\n  };\n\n  // |, ||\n  CharScanners[Char.Bar] = () => {\n    if (nextChar() !== Char.Bar) {\n      return Token.Bar;\n    }\n    nextChar();\n    return Token.BarBar;\n  };\n\n  // ?, ??, ?.\n  CharScanners[Char.Question] = () => {\n    if (nextChar() === Char.Dot) {\n      const peek = $charCodeAt($index + 1);\n      if (peek <= Char.Zero || peek >= Char.Nine) {\n        nextChar();\n        return Token.QuestionDot;\n      }\n      return Token.Question;\n    }\n    if ($currentChar !== Char.Question) {\n      return Token.Question;\n    }\n    nextChar();\n    return Token.QuestionQuestion;\n  };\n\n  // ., ...\n  CharScanners[Char.Dot] = () => {\n    if (nextChar() <= Char.Nine && $currentChar >= Char.Zero) {\n      return scanNumber(true);\n    }\n    if ($currentChar === Char.Dot) {\n      if (nextChar() !== Char.Dot) {\n        return Token.DotDot;\n      }\n      nextChar();\n      return Token.DotDotDot;\n    }\n    return Token.Dot;\n  };\n\n  // <, <=\n  CharScanners[Char.LessThan] =  () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.LessThan;\n    }\n    nextChar();\n    return Token.LessThanEquals;\n  };\n\n  // >, >=\n  CharScanners[Char.GreaterThan] =  () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.GreaterThan;\n    }\n    nextChar();\n    return Token.GreaterThanEquals;\n  };\n\n  CharScanners[Char.Percent]      = returnToken(Token.Percent);\n  CharScanners[Char.OpenParen]    = returnToken(Token.OpenParen);\n  CharScanners[Char.CloseParen]   = returnToken(Token.CloseParen);\n\n  // *, *=, **\n  CharScanners[Char.Asterisk] =  () => {\n    if (nextChar() === Char.Equals) {\n      nextChar();\n      return Token.AsteriskEquals;\n    }\n    if ($currentChar === Char.Asterisk) {\n      nextChar();\n      return Token.AsteriskAsterisk;\n    }\n    return Token.Asterisk;\n  };\n\n  // +, +=, ++\n  CharScanners[Char.Plus] =  () => {\n    if (nextChar() === Char.Plus) {\n      nextChar();\n      return Token.PlusPlus;\n    }\n    if ($currentChar !== Char.Equals) {\n      return Token.Plus;\n    }\n    nextChar();\n    return Token.PlusEquals;\n  };\n\n  CharScanners[Char.Comma]        = returnToken(Token.Comma);\n\n  // -, -=, --\n  CharScanners[Char.Minus] =  () => {\n    if (nextChar() === Char.Minus) {\n      nextChar();\n      return Token.MinusMinus;\n    }\n    if ($currentChar !== Char.Equals) {\n      return Token.Minus;\n    }\n    nextChar();\n    return Token.MinusEquals;\n  };\n\n  // /, /=\n  CharScanners[Char.Slash] =  () => {\n    if (nextChar() !== Char.Equals) {\n      return Token.Slash;\n    }\n    nextChar();\n    return Token.SlashEquals;\n  };\n\n  CharScanners[Char.Colon]        = returnToken(Token.Colon);\n  CharScanners[Char.Semicolon]    = returnToken(Token.Semicolon);\n  CharScanners[Char.OpenBracket]  = returnToken(Token.OpenBracket);\n  CharScanners[Char.CloseBracket] = returnToken(Token.CloseBracket);\n  CharScanners[Char.OpenBrace]    = returnToken(Token.OpenBrace);\n  CharScanners[Char.CloseBrace]   = returnToken(Token.CloseBrace);\n\n  return { CharScanners, IdParts };\n})();\n", "import { DI, Registration } from '@aurelia/kernel';\n\n/** @internal */ export const tcCreateInterface = DI.createInterface;\n\n/** @internal */ export const tcObjectFreeze = Object.freeze;\n\n/** @internal */ export const { aliasTo: aliasRegistration, singleton: singletonRegistration } = Registration;\n\n/** ExpressionType */\n/** @internal */ export const etInterpolation = 'Interpolation';\n/** @internal */ export const etIsFunction = 'IsFunction';\n/** @internal */ export const etIsProperty = 'IsProperty';\n\n/** @internal */ export const definitionTypeElement = 'custom-element';\n/** @internal */ export const definitionTypeAttribute = 'custom-attribute';\n", "import { tcObjectFreeze } from './utilities';\n\n// Note: the oneTime binding now has a non-zero value for 2 reasons:\n//  - plays nicer with bitwise operations (more consistent code, more explicit settings)\n//  - allows for potentially having something like BindingMode.oneTime | BindingMode.fromView, where an initial value is set once to the view but updates from the view also propagate back to the view model\n//\n// Furthermore, the \"default\" mode would be for simple \".bind\" expressions to make it explicit for our logic that the default is being used.\n// This essentially adds extra information which binding could use to do smarter things and allows bindingBehaviors that add a mode instead of simply overwriting it\n/**\n * Mode of a binding to operate\n * - 1 / one time - bindings should only update the target once\n * - 2 / to view - bindings should update the target and observe the source for changes to update again\n * - 3 / from view - bindings should update the source and observe the target for changes to update again\n * - 6 / two way - bindings should observe both target and source for changes to update the other side\n * - 0 / default - undecided mode, bindings, depends on the circumstance, may decide what to do accordingly\n */\nexport const BindingMode = /*@__PURE__*/ tcObjectFreeze({\n  /**\n   * Unspecified mode, bindings may act differently with this mode\n   */\n  default: 0,\n  oneTime: 1,\n  toView: 2,\n  fromView: 4,\n  twoWay: 6,\n} as const);\n\nexport type BindingMode = typeof BindingMode[keyof typeof BindingMode];\n\n_START_CONST_ENUM();\n/** @internal */export const enum InternalBindingMode {\n  default = 0,\n  oneTime = 1,\n  toView = 2,\n  fromView = 4,\n  twoWay = 6,\n}\n_END_CONST_ENUM();\n", "import { Constructable, IContainer, IPlatform, Key } from '@aurelia/kernel';\nimport { tcCreateInterface } from './utilities';\nimport { AttrSyntax } from './attribute-pattern';\nimport { IInstruction } from './instructions';\n\nexport interface IElementComponentDefinition<TBindables extends string = string> {\n  name: string;\n  type: 'custom-element';\n  template?: string | Node | null;\n  dependencies?: readonly Key[];\n  instructions?: readonly IInstruction[][];\n  surrogates?: readonly IInstruction[];\n  needsCompile?: boolean;\n  containerless?: boolean;\n  /**\n   * Indicates whether there's a <slot> element in the template of this element\n   */\n  hasSlots?: boolean;\n  shadowOptions?: { mode: 'open' | 'closed' } | null;\n  capture?: boolean | ((attrName: string) => boolean);\n  enhance?: boolean;\n  processContent?: ProcessContentHook | null;\n  bindables?: (TBindables | IComponentBindablePropDefinition)[] | Record<TBindables, Omit<IComponentBindablePropDefinition, 'name'> | true>;\n  Type?: Constructable;\n}\n\nexport type ProcessContentHook = (this: Constructable | undefined, node: HTMLElement, platform: IDomPlatform, data: Record<PropertyKey, unknown>) => boolean | void;\n\nexport type StringBindingMode =\n  | 'default'\n  | 'oneTime'\n  | 'toView'\n  | 'fromView'\n  | 'twoWay';\n\nexport interface IAttributeComponentDefinition<TBindables extends string = string> {\n  name: string;\n  type: 'custom-attribute';\n  noMultiBindings?: boolean;\n  isTemplateController?: boolean;\n  aliases?: readonly string[];\n  defaultBindingMode?: StringBindingMode | number;\n  bindables?: (TBindables | IComponentBindablePropDefinition)[] | Record<TBindables, Omit<IComponentBindablePropDefinition, 'name'> | true>;\n}\n\nexport interface IComponentBindablePropDefinition {\n  name: string;\n  attribute?: string;\n  primary?: boolean;\n  mode?: StringBindingMode | number;\n  set?: (v: any) => any;\n}\n\nexport type ICompiledElementComponentDefinition = IElementComponentDefinition & {\n  instructions: IInstruction[][];\n  surrogates: IInstruction[][];\n  template: HTMLElement | null;\n};\n\n/**\n * An interface describing the template compiler used by Aurelia applicaitons\n */\nexport const ITemplateCompiler = /*@__PURE__*/tcCreateInterface<ITemplateCompiler>('ITemplateCompiler');\nexport interface ITemplateCompiler {\n  /**\n   * Indicates whether this compiler should compile template in debug mode\n   *\n   * For the default compiler, this means all expressions are kept as is on the template\n   */\n  debug: boolean;\n  /**\n   * Experimental API, for optimization.\n   *\n   * `true` to create CustomElement/CustomAttribute instructions\n   * with resolved resources constructor during compilation, instead of name\n   */\n  resolveResources: boolean;\n\n  compile(\n    partialDefinition: IElementComponentDefinition,\n    context: IContainer,\n  ): ICompiledElementComponentDefinition;\n\n  /**\n   * Compile a list of captured attributes as if they are declared in a template\n   *\n   * @param requestor - the context definition where the attributes is compiled\n   * @param attrSyntaxes - the attributes captured\n   * @param container - the container containing information for the compilation\n   * @param host - the host element where the attributes are spreaded on\n   */\n  compileSpread<T extends IElementComponentDefinition>(\n    requestor: T,\n    attrSyntaxes: AttrSyntax[],\n    container: IContainer,\n    target: Element,\n    /**\n     * An associated custom element definition for the target host element\n     * Sometimes spread compilation may occur without the container having all necessary information\n     * about the targeted element that is receiving the spread\n     *\n     * Caller of this method may want to provide this information dynamically instead\n     */\n    targetDef?: T,\n  ): IInstruction[];\n}\n\nexport interface IDomPlatform extends IPlatform {\n  document: Document;\n}\n", "import { tcCreateInterface } from './utilities';\n\n/**\n * An interface describing the API for mapping attributes to properties\n */\nexport const IAttrMapper = /*@__PURE__*/tcCreateInterface<IAttrMapper>('IAttrMapper');\nexport interface IAttrMapper {\n  /**\n   * Allow application to teach Aurelia how to define how to map attributes to properties\n   * based on element tagName\n   */\n  useMapping(config: Record<string, Record<string, PropertyKey>>): void;\n\n  /**\n   * Allow applications to teach Aurelia how to define how to map attributes to properties\n   * for all elements\n   */\n  useGlobalMapping(config: Record<string, PropertyKey>): void;\n\n  /**\n   * Add a given function to a list of fns that will be used\n   * to check if `'bind'` command can be understood as `'two-way'` command.\n   */\n  useTwoWay(fn: IsTwoWayPredicate): void;\n\n  /**\n   * Returns true if an attribute should be two way bound based on an element\n   */\n  isTwoWay(node: Element, attrName: string): boolean;\n\n  /**\n   * Retrieves the mapping information this mapper have for an attribute on an element\n   */\n  map(node: Element, attr: string): string | null;\n}\n\nexport type IsTwoWayPredicate = (element: Element, attribute: string) => boolean;\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => {\n    const paddedCode = String(code).padStart(4, '0');\n    const message = getMessageByCode(code, ...details);\n    const link = `https://docs.aurelia.io/developer-guides/error-messages/0088-to-0723/aur${paddedCode}`;\n    return new Error(`AUR${paddedCode}: ${message}\\n\\nFor more information, see: ${link}`);\n  }\n  : (code: ErrorNames, ...details: unknown[]) => {\n    const paddedCode = String(code).padStart(4, '0');\n    return new Error(`AUR${paddedCode}:${details.map(String)}`);\n  };\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  attribute_pattern_already_initialized = 88,\n  attribute_pattern_duplicate = 89,\n\n  method_not_implemented = 99,\n\n  binding_command_existed = 157,\n\n  compiler_root_is_local = 701,\n  compiler_invalid_surrogate_attr = 702,\n  compiler_no_tc_on_surrogate = 703,\n  compiler_invalid_let_command = 704,\n  compiler_au_slot_on_non_element = 706,\n  compiler_binding_to_non_bindable = 707,\n  compiler_template_only_local_template = 708,\n  compiler_local_el_not_under_root = 709,\n  compiler_local_el_bindable_not_under_root = 710,\n  compiler_local_el_bindable_name_missing = 711,\n  compiler_local_el_bindable_duplicate = 712,\n  compiler_unknown_binding_command = 713,\n  compiler_primary_already_existed = 714,\n  compiler_local_name_empty = 715,\n  compiler_duplicate_local_name = 716,\n  compiler_slot_without_shadowdom = 717,\n  compiler_no_spread_tc = 718,\n  compiler_attr_mapper_duplicate_mapping = 719,\n  compiler_no_reserved_spread_syntax = 720,\n  compiler_no_reserved_$bindable = 721,\n  compiler_no_dom_api = 722,\n  compiler_invalid_class_binding_syntax = 723,\n  no_spread_template_controller = 9998,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string> = {\n  [ErrorNames.attribute_pattern_already_initialized]: 'AttributeParser is already initialized; cannot add patterns after initialization.',\n  [ErrorNames.attribute_pattern_duplicate]: 'Attribute pattern \"{{0}}\" has already been registered.',\n\n  [ErrorNames.method_not_implemented]: 'Method {{0}} not implemented',\n\n  [ErrorNames.binding_command_existed]: `Binding command {{0}} has already been registered.`,\n\n  [ErrorNames.compiler_root_is_local]: `Template compilation error in element \"{{0:name}}\": the root <template> cannot be a local element template.`,\n  [ErrorNames.compiler_invalid_surrogate_attr]: `Template compilation error: attribute \"{{0}}\" is invalid on element surrogate.`,\n  [ErrorNames.compiler_no_tc_on_surrogate]: `Template compilation error: template controller \"{{0}}\" is invalid on element surrogate.`,\n  [ErrorNames.compiler_invalid_let_command]: `Template compilation error: Invalid command \"{{0:.command}}\" for <let>. Only to-view/bind supported.`,\n  [ErrorNames.compiler_au_slot_on_non_element]: `Template compilation error: detected projection with [au-slot=\"{{0}}\"] attempted on a non custom element {{1}}.`,\n  [ErrorNames.compiler_binding_to_non_bindable]: `Template compilation error: creating binding to non-bindable property {{0}} on {{1}}.`,\n  [ErrorNames.compiler_template_only_local_template]: `Template compilation error: the custom element \"{{0}}\" does not have any content other than local template(s).`,\n  [ErrorNames.compiler_local_el_not_under_root]: `Template compilation error: local element template needs to be defined directly under root of element \"{{0}}\".`,\n  [ErrorNames.compiler_local_el_bindable_not_under_root]: `Template compilation error: bindable properties of local element \"{{0}}\" template needs to be defined directly under <template>.`,\n  [ErrorNames.compiler_local_el_bindable_name_missing]: `Template compilation error: the attribute 'property' is missing in {{0:outerHTML}} in local element \"{{1}}\"`,\n  [ErrorNames.compiler_local_el_bindable_duplicate]: `Template compilation error: Bindable property and attribute needs to be unique; found property: {{0}}, attribute: {{1}}`,\n  [ErrorNames.compiler_unknown_binding_command]: `Template compilation error: unknown binding command: \"{{0}}\".{{0:bindingCommandHelp}}`,\n  [ErrorNames.compiler_primary_already_existed]: `Template compilation error: primary already exists on element/attribute \"{{0}}\"`,\n  [ErrorNames.compiler_local_name_empty]: `Template compilation error: the value of \"as-custom-element\" attribute cannot be empty for local element in element \"{{0}}\"`,\n  [ErrorNames.compiler_duplicate_local_name]: `Template compilation error: duplicate definition of the local template named \"{{0}} in element {{1}}\"`,\n  [ErrorNames.compiler_slot_without_shadowdom]: `Template compilation error: detected a usage of \"<slot>\" element without specifying shadow DOM options in element: {{0}}`,\n  [ErrorNames.compiler_no_spread_tc]: `Spreading template controller \"{{0}}\" is not supported.`,\n  [ErrorNames.compiler_attr_mapper_duplicate_mapping]: `Attribute {{0}} has been already registered for {{1:element}}`,\n  [ErrorNames.compiler_no_reserved_spread_syntax]: `Spreading syntax \"...xxx\" is reserved. Encountered \"...{{0}}\"`,\n  [ErrorNames.compiler_no_reserved_$bindable]: `Usage of $bindables is only allowed on custom element. Encountered: <{{0}} {{1}}=\"{{2}}\">`,\n  [ErrorNames.compiler_no_dom_api]: 'Invalid platform object provided to the compilation, no DOM API found.',\n  [ErrorNames.compiler_invalid_class_binding_syntax]: `Template compilation error: Invalid comma-separated class binding syntax in {{0}}. It resulted in no valid class names after parsing.`,\n\n  [ErrorNames.no_spread_template_controller]: 'Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?',\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n    let matches = regex.exec(cooked);\n    while (matches != null) {\n      const method = matches[1]?.slice(1);\n      let value = details[i] as any;\n      if (value != null) {\n        switch (method) {\n          case 'nodeName': value = (value as Node).nodeName.toLowerCase(); break;\n          case 'name': value = (value as { name: string }).name; break;\n          case 'typeof': value = typeof value; break;\n          case 'ctor': value = (value as object).constructor.name; break;\n          case 'controller': value = value.controller.name; break;\n          case 'target@property': value = `${value.target}@${value.targetProperty}`; break;\n          case 'toString': value = Object.prototype.toString.call(value); break;\n          case 'join(!=)': value = (value as unknown[]).join('!='); break;\n          case 'bindingCommandHelp': value = getBindingCommandHelp(value); break;\n          case 'element': value = value === '*' ? 'all elements' : `<${value} />`; break;\n          default: {\n            // property access\n            if (method?.startsWith('.')) {\n              value = String(value[method.slice(1)]);\n            } else {\n              value = String(value);\n            }\n          }\n        }\n      }\n      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);\n      matches = regex.exec(cooked);\n    }\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n\nfunction getBindingCommandHelp(name: string) {\n  switch (name) {\n    case 'delegate':\n      return `\\nThe \".delegate\" binding command has been removed in v2.`\n      + ` Binding command \".trigger\" should be used instead.`\n      + ` If you are migrating v1 application, install compat package`\n      + ` to add back the \".delegate\" binding command for ease of migration.`;\n    case 'call':\n      return `\\nThe \".call\" binding command has been removed in v2.`\n      + ` If you want to pass a callback that preserves the context of the function call,`\n      + ` you can use lambda instead. Refer to lambda expression doc for more details.`;\n    default:\n      return '';\n  }\n}\n", "import type { Constructable, IRegistry, } from '@aurelia/kernel';\nimport { IContainer, registrableMetadataKey, emptyArray, getResourceKeyFor, resolve } from '@aurelia/kernel';\nimport { tcCreateInterface, tcObjectFreeze, singletonRegistration } from './utilities';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface AttributePatternDefinition<T extends string = string> {\n  pattern: T;\n  symbols: string;\n}\n\nexport interface ICharSpec {\n  chars: string;\n  repeat: boolean;\n  isSymbol: boolean;\n  isInverted: boolean;\n  has(char: string): boolean;\n  equals(other: ICharSpec): boolean;\n}\n\nexport class CharSpec implements ICharSpec {\n  public has: (char: string) => boolean;\n\n  public constructor(\n    public chars: string,\n    public repeat: boolean,\n    public isSymbol: boolean,\n    public isInverted: boolean,\n  ) {\n    if (isInverted) {\n      switch (chars.length) {\n        case 0:\n          this.has = this._hasOfNoneInverse;\n          break;\n        case 1:\n          this.has = this._hasOfSingleInverse;\n          break;\n        default:\n          this.has = this._hasOfMultipleInverse;\n      }\n    } else {\n      switch (chars.length) {\n        case 0:\n          this.has = this._hasOfNone;\n          break;\n        case 1:\n          this.has = this._hasOfSingle;\n          break;\n        default:\n          this.has = this._hasOfMultiple;\n      }\n    }\n  }\n\n  public equals(other: ICharSpec): boolean {\n    return this.chars === other.chars\n      && this.repeat === other.repeat\n      && this.isSymbol === other.isSymbol\n      && this.isInverted === other.isInverted;\n  }\n\n  /** @internal */\n  private _hasOfMultiple(char: string): boolean {\n    return this.chars.includes(char);\n  }\n\n  /** @internal */\n  private _hasOfSingle(char: string): boolean {\n    return this.chars === char;\n  }\n\n  /** @internal */\n  private _hasOfNone(_char: string): boolean {\n    return false;\n  }\n\n  /** @internal */\n  private _hasOfMultipleInverse(char: string): boolean {\n    return !this.chars.includes(char);\n  }\n\n  /** @internal */\n  private _hasOfSingleInverse(char: string): boolean {\n    return this.chars !== char;\n  }\n\n  /** @internal */\n  private _hasOfNoneInverse(_char: string): boolean {\n    return true;\n  }\n}\n\nexport class Interpretation {\n  public parts: readonly string[] = emptyArray;\n  public get pattern(): string | null {\n    const value = this._pattern;\n    if (value === '') {\n      return null;\n    } else {\n      return value;\n    }\n  }\n  public set pattern(value: string | null) {\n    if (value == null) {\n      this._pattern = '';\n      this.parts = emptyArray;\n    } else {\n      this._pattern = value;\n      this.parts = this._partsRecord[value];\n    }\n  }\n  /** @internal */\n  private _pattern: string = '';\n  /** @internal */\n  private readonly _currentRecord: Record<string, string> = {};\n  /** @internal */\n  private readonly _partsRecord: Record<string, string[]> = {};\n\n  public append(pattern: string, ch: string): void {\n    const currentRecord = this._currentRecord;\n    if (currentRecord[pattern] === undefined) {\n      currentRecord[pattern] = ch;\n    } else {\n      currentRecord[pattern] += ch;\n    }\n  }\n\n  public next(pattern: string): void {\n    const currentRecord = this._currentRecord;\n    let partsRecord: Interpretation['_partsRecord'];\n\n    if (currentRecord[pattern] !== undefined) {\n      partsRecord = this._partsRecord;\n      if (partsRecord[pattern] === undefined) {\n        partsRecord[pattern] = [currentRecord[pattern]];\n      } else {\n        partsRecord[pattern].push(currentRecord[pattern]);\n      }\n      currentRecord[pattern] = undefined!;\n    }\n  }\n}\n\nclass AttrParsingState {\n  private readonly _nextStates: AttrParsingState[] = [];\n  private readonly _patterns: string[];\n  public _types: SegmentTypes | null = null;\n  public _isEndpoint: boolean = false;\n  public get _pattern(): string | null {\n    return this._isEndpoint ? this._patterns[0] : null;\n  }\n\n  public constructor(\n    public charSpec: ICharSpec,\n    ...patterns: string[]\n  ) {\n    this._patterns = patterns;\n  }\n\n  public findChild(charSpec: ICharSpec): AttrParsingState {\n    const nextStates = this._nextStates;\n    const len = nextStates.length;\n    let child: AttrParsingState = null!;\n    let i = 0;\n    for (; i < len; ++i) {\n      child = nextStates[i];\n      if (charSpec.equals(child.charSpec)) {\n        return child;\n      }\n    }\n    return null!;\n  }\n\n  public append(charSpec: ICharSpec, pattern: string): AttrParsingState {\n    const patterns = this._patterns;\n    if (!patterns.includes(pattern)) {\n      patterns.push(pattern);\n    }\n    let state = this.findChild(charSpec);\n    if (state == null) {\n      state = new AttrParsingState(charSpec, pattern);\n      this._nextStates.push(state);\n      if (charSpec.repeat) {\n        state._nextStates.push(state);\n      }\n    }\n    return state;\n  }\n\n  public findMatches(ch: string, interpretation: Interpretation): AttrParsingState[] {\n    // TODO: reuse preallocated arrays\n    const results = [];\n    const nextStates = this._nextStates;\n    const len = nextStates.length;\n    let childLen = 0;\n    let child: AttrParsingState = null!;\n    let i = 0;\n    let j = 0;\n    for (; i < len; ++i) {\n      child = nextStates[i];\n      if (child.charSpec.has(ch)) {\n        results.push(child);\n        childLen = child._patterns.length;\n        j = 0;\n        if (child.charSpec.isSymbol) {\n          for (; j < childLen; ++j) {\n            interpretation.next(child._patterns[j]);\n          }\n        } else {\n          for (; j < childLen; ++j) {\n            interpretation.append(child._patterns[j], ch);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\nexport interface ISegment {\n  text: string;\n  eachChar(callback: (spec: CharSpec) => void): void;\n}\n\n/** @internal */\nclass StaticSegment implements ISegment {\n  private readonly _len: number;\n  private readonly _specs: CharSpec[];\n\n  public constructor(\n    public text: string,\n  ) {\n    const len = this._len = text.length;\n    const specs = this._specs = [] as CharSpec[];\n    let i = 0;\n    for (; len > i; ++i) {\n      specs.push(new CharSpec(text[i], false, false, false));\n    }\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    const len = this._len;\n    const specs = this._specs;\n    let i = 0;\n    for (; len > i; ++i) {\n      callback(specs[i]);\n    }\n  }\n}\n\n/** @internal */\nclass DynamicSegment implements ISegment {\n  public text: string = 'PART';\n  private readonly _spec: CharSpec;\n\n  public constructor(symbols: string) {\n    this._spec = new CharSpec(symbols, true, false, true);\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    callback(this._spec);\n  }\n}\n\n/** @internal */\nclass SymbolSegment implements ISegment {\n  private readonly _spec: CharSpec;\n\n  public constructor(\n    public text: string,\n  ) {\n    this._spec = new CharSpec(text, false, true, false);\n  }\n\n  public eachChar(callback: (spec: CharSpec) => void): void {\n    callback(this._spec);\n  }\n}\n\nexport class SegmentTypes {\n  public statics: number = 0;\n  public dynamics: number = 0;\n  public symbols: number = 0;\n}\n\nexport interface ISyntaxInterpreter {\n  add(defs: AttributePatternDefinition[]): void;\n  interpret(name: string): Interpretation;\n}\nexport const ISyntaxInterpreter = /*@__PURE__*/tcCreateInterface<ISyntaxInterpreter>('ISyntaxInterpreter', x => x.singleton(SyntaxInterpreter));\n\n/**\n * The default implementation of @see {ISyntaxInterpreter}.\n */\nexport class SyntaxInterpreter implements ISyntaxInterpreter {\n  /** @internal */\n  public _rootState: AttrParsingState = new AttrParsingState(null!);\n  /** @internal */\n  private readonly _initialStates: AttrParsingState[] = [this._rootState];\n\n  // todo: this only works if this method is ever called only once\n  public add(defs: AttributePatternDefinition[]): void {\n    defs = defs.slice(0).sort((d1, d2) => d1.pattern > d2.pattern ? 1 : -1);\n    const ii = defs.length;\n    let currentState: AttrParsingState;\n    let def: AttributePatternDefinition;\n    let pattern: string;\n    let types: SegmentTypes;\n    let segments: ISegment[];\n    let len: number;\n    let charSpecCb: (ch: ICharSpec) => void;\n    let i = 0;\n    let j: number;\n    while (ii > i) {\n      currentState = this._rootState;\n      def = defs[i];\n      pattern = def.pattern;\n      types = new SegmentTypes();\n      segments = this._parse(def, types);\n      len = segments.length;\n      charSpecCb = (ch: ICharSpec) => currentState = currentState.append(ch, pattern);\n      for (j = 0; len > j; ++j) {\n        segments[j].eachChar(charSpecCb);\n      }\n      currentState._types = types;\n      currentState._isEndpoint = true;\n      ++i;\n    }\n  }\n\n  public interpret(name: string): Interpretation {\n    const interpretation = new Interpretation();\n    const len = name.length;\n    let states = this._initialStates;\n    let i = 0;\n    let state: AttrParsingState;\n    for (; i < len; ++i) {\n      states = this._getNextStates(states, name.charAt(i), interpretation);\n      if (states.length === 0) {\n        break;\n      }\n    }\n\n    states = states.filter(isEndpoint);\n\n    if (states.length > 0) {\n      states.sort(sortEndpoint);\n      state = states[0];\n      if (!state.charSpec.isSymbol) {\n        interpretation.next(state._pattern!);\n      }\n      interpretation.pattern = state._pattern;\n    }\n    return interpretation;\n  }\n\n  /** @internal */\n  private _getNextStates(states: AttrParsingState[], ch: string, interpretation: Interpretation): AttrParsingState[] {\n    // TODO: reuse preallocated arrays\n    const nextStates: AttrParsingState[] = [];\n    let state: AttrParsingState = null!;\n    const len = states.length;\n    let i = 0;\n    for (; i < len; ++i) {\n      state = states[i];\n      nextStates.push(...state.findMatches(ch, interpretation));\n    }\n\n    return nextStates;\n  }\n\n  /** @internal */\n  private _parse(def: AttributePatternDefinition, types: SegmentTypes): ISegment[] {\n    const result = [];\n    const pattern = def.pattern;\n    const len = pattern.length;\n    const symbols = def.symbols;\n    let i = 0;\n    let start = 0;\n    let c = '';\n\n    while (i < len) {\n      c = pattern.charAt(i);\n      if (symbols.length === 0 || !symbols.includes(c)) {\n        if (i === start) {\n          if (c === 'P' && pattern.slice(i, i + 4) === 'PART') {\n            start = i = (i + 4);\n            result.push(new DynamicSegment(symbols));\n            ++types.dynamics;\n          } else {\n            ++i;\n          }\n        } else {\n          ++i;\n        }\n      } else if (i !== start) {\n        result.push(new StaticSegment(pattern.slice(start, i)));\n        ++types.statics;\n        start = i;\n      } else {\n        result.push(new SymbolSegment(pattern.slice(start, i + 1)));\n        ++types.symbols;\n        start = ++i;\n      }\n    }\n    if (start !== i) {\n      result.push(new StaticSegment(pattern.slice(start, i)));\n      ++types.statics;\n    }\n\n    return result;\n  }\n}\n\nfunction isEndpoint(a: AttrParsingState) {\n  return a._isEndpoint;\n}\n\nfunction sortEndpoint(a: AttrParsingState, b: AttrParsingState) {\n  // both a and b are endpoints\n  // compare them based on the number of static, then dynamic & symbol fragments\n  const aTypes = a._types!;\n  const bTypes = b._types!;\n  if (aTypes.statics !== bTypes.statics) {\n    return bTypes.statics - aTypes.statics;\n  }\n  if (aTypes.dynamics !== bTypes.dynamics) {\n    return bTypes.dynamics - aTypes.dynamics;\n  }\n  if (aTypes.symbols !== bTypes.symbols) {\n    return bTypes.symbols - aTypes.symbols;\n  }\n  return 0;\n}\n\nexport class AttrSyntax {\n  public constructor(\n    public rawName: string,\n    public rawValue: string,\n    public target: string,\n    public command: string | null,\n    public parts: readonly string[] | null = null\n  ) { }\n}\n\nexport type IAttributePattern<T extends string = string> = Record<T, (rawName: string, rawValue: string, parts: readonly string[]) => AttrSyntax>;\n\nexport const IAttributePattern = /*@__PURE__*/tcCreateInterface<IAttributePattern>('IAttributePattern');\n\nexport interface IAttributeParser {\n  registerPattern(patterns: AttributePatternDefinition[], Type: Constructable<IAttributePattern>): void;\n  parse(name: string, value: string): AttrSyntax;\n}\nexport const IAttributeParser = /*@__PURE__*/tcCreateInterface<IAttributeParser>('IAttributeParser', x => x.singleton(AttributeParser));\n\n/**\n * The default implementation of the @see IAttributeParser interface\n */\nexport class AttributeParser implements IAttributeParser {\n  /** @internal */\n  private readonly _cache: Record<string, Interpretation> = {};\n  /**\n   * A 2 level record with the same key on both levels.\n   * Just a trick to maintain `this` + have simple lookup + support multi patterns per class definition\n   *\n   * @internal\n   */\n  private readonly _patterns: Record<string, { patternType: Constructable<IAttributePattern>; pattern?: IAttributePattern }> = {};\n\n  /** @internal */\n  private readonly _interpreter: ISyntaxInterpreter;\n  /** @internal */\n  private _initialized: boolean = false;\n  /** @internal */\n  private readonly _allDefinitions: AttributePatternDefinition[] = [];\n  /** @internal */\n  private readonly _container: IContainer;\n\n  public constructor() {\n    this._interpreter = resolve(ISyntaxInterpreter);\n    this._container = resolve(IContainer);\n  }\n\n  public registerPattern(patterns: AttributePatternDefinition[], Type: Constructable<IAttributePattern>): void {\n    if (this._initialized) throw createMappedError(ErrorNames.attribute_pattern_already_initialized);\n\n    const $patterns = this._patterns;\n    for (const { pattern } of patterns) {\n      if ($patterns[pattern] != null) throw createMappedError(ErrorNames.attribute_pattern_duplicate, pattern);\n      $patterns[pattern] = { patternType: Type };\n    }\n    this._allDefinitions.push(...patterns);\n  }\n\n  /** @internal */\n  private _initialize(): void {\n    this._interpreter.add(this._allDefinitions);\n    const _container = this._container;\n    for (const [, value] of Object.entries(this._patterns)) {\n      value.pattern = _container.get(value.patternType);\n    }\n  }\n\n  public parse(name: string, value: string): AttrSyntax {\n    // Optimization Idea: move the initialization to an AppTask\n    if (!this._initialized) {\n      this._initialize();\n      this._initialized = true;\n    }\n    let interpretation = this._cache[name];\n    if (interpretation == null) {\n      interpretation = this._cache[name] = this._interpreter.interpret(name);\n    }\n    const pattern = interpretation.pattern;\n    if (pattern == null) {\n      return new AttrSyntax(name, value, name, null, null);\n    } else {\n      return this._patterns[pattern].pattern![pattern](name, value, interpretation.parts as string[]);\n    }\n  }\n}\n\nexport interface AttributePatternKind {\n  readonly name: string;\n  create<const K extends AttributePatternDefinition, P extends Constructable<IAttributePattern<K['pattern']>> = Constructable<IAttributePattern<K['pattern']>>>(patternDefs: K[], Type: P): IRegistry;\n}\n\n/**\n * Decorator to be used on attr pattern classes\n */\nexport function attributePattern<const K extends AttributePatternDefinition>(...patternDefs: K[]): <T extends Constructable<IAttributePattern<K['pattern']>>>(target: T, context: ClassDecoratorContext<T>) => T {\n  return function decorator<T extends Constructable<IAttributePattern<K['pattern']>>>(target: T, context: ClassDecoratorContext<T>): T {\n    const registrable = AttributePattern.create(patternDefs, target);\n    // Decorators are by nature static, so we need to store the metadata on the class itself, assuming only one set of patterns per class.\n    context.metadata[registrableMetadataKey] = registrable;\n    return target;\n  };\n}\n\nexport const AttributePattern = /*@__PURE__*/ tcObjectFreeze<AttributePatternKind>({\n  name: getResourceKeyFor('attribute-pattern'),\n  create(patternDefs, Type) {\n    return {\n      register(container: IContainer) {\n        container.get(IAttributeParser).registerPattern(patternDefs, Type);\n        singletonRegistration(IAttributePattern, Type).register(container);\n      }\n    };\n  },\n});\n\nexport class DotSeparatedAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: /*@__PURE__*/AttributePattern.create(\n      [\n        { pattern: 'PART.PART', symbols: '.' },\n        { pattern: 'PART.PART.PART', symbols: '.' }\n      ],\n      DotSeparatedAttributePattern\n    )\n  };\n  public 'PART.PART'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);\n  }\n\n  public 'PART.PART.PART'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, `${parts[0]}.${parts[1]}`, parts[2]);\n  }\n}\n\nexport class RefAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: /*@__PURE__*/AttributePattern.create(\n      [\n        { pattern: 'ref', symbols: '' },\n        { pattern: 'PART.ref', symbols: '.' }\n      ],\n      RefAttributePattern\n    )\n  };\n  public 'ref'(rawName: string, rawValue: string, _parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, 'element', 'ref');\n  }\n\n  public 'PART.ref'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    let target = parts[0];\n    if (target === 'view-model') {\n      target = 'component';\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`[aurelia] Detected view-model.ref usage: \"${rawName}=${rawValue}\".`\n          + ` This is deprecated and component.ref should be used instead`);\n      }\n    }\n    return new AttrSyntax(rawName, rawValue, target, 'ref');\n  }\n}\n\nexport class EventAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: /*@__PURE__*/AttributePattern.create(\n      [\n        { pattern: 'PART.trigger:PART', symbols: '.:' },\n        { pattern: 'PART.capture:PART', symbols: '.:' },\n      ],\n      EventAttributePattern\n    )\n  };\n  public 'PART.trigger:PART'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'trigger', parts);\n  }\n  public 'PART.capture:PART'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'capture', parts);\n  }\n}\n\nexport class ColonPrefixedBindAttributePattern {\n\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: /*@__PURE__*/AttributePattern.create(\n      [{ pattern: ':PART', symbols: ':' }],\n      ColonPrefixedBindAttributePattern\n    )\n  };\n\n  public ':PART'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'bind');\n  }\n}\n\nexport class AtPrefixedTriggerAttributePattern {\n\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: /*@__PURE__*/AttributePattern.create(\n      [\n        { pattern: '@PART', symbols: '@' },\n        { pattern: '@PART:PART', symbols: '@:' },\n      ], AtPrefixedTriggerAttributePattern\n    )\n  };\n\n  public '@PART'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'trigger');\n  }\n\n  public '@PART:PART'(rawName: string, rawValue: string, parts: readonly string[]): AttrSyntax {\n    return new AttrSyntax(rawName, rawValue, parts[0], 'trigger', [parts[0], 'trigger', ...parts.slice(1)]);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n/* istanbul ignore next */function testAttributePatternDeco() {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error\n  attributePattern({ pattern: 'abc', symbols: '.' })(class Def {});\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-expect-error\n  AttributePattern.create([{ pattern: 'abc', symbols: '.' }], class Def {});\n}\n", "import { Metadata } from '@aurelia/metadata';\n\n/** @internal */ export const getMetadata = Metadata.get;\n/** @internal */ export const hasMetadata = Metadata.has;\n/** @internal */ export const defineMetadata = Metadata.define;\n\n", "import { isString } from '@aurelia/kernel';\nimport {\n  type ForOfStatement,\n  type Interpolation,\n  type IsBindingBehavior,\n} from '@aurelia/expression-parser';\nimport { IAttributeComponentDefinition, IElementComponentDefinition } from './interfaces-template-compiler';\nimport { tcCreateInterface, tcObjectFreeze } from './utilities';\nimport { AttrSyntax } from './attribute-pattern';\nimport { BindingMode } from './binding-mode';\n\n/** @internal */ export const hydrateElement = 'ra';\n/** @internal */ export const hydrateAttribute = 'rb';\n/** @internal */ export const hydrateTemplateController = 'rc';\n/** @internal */ export const hydrateLetElement = 'rd';\n/** @internal */ export const setProperty = 're';\n/** @internal */ export const interpolation = 'rf';\n/** @internal */ export const propertyBinding = 'rg';\n/** @internal */ export const letBinding = 'ri';\n/** @internal */ export const refBinding = 'rj';\n/** @internal */ export const iteratorBinding = 'rk';\n/** @internal */ export const multiAttr = 'rl';\n/** @internal */ export const textBinding = 'ha';\n/** @internal */ export const listenerBinding = 'hb';\n/** @internal */ export const attributeBinding = 'hc';\n/** @internal */ export const stylePropertyBinding = 'hd';\n/** @internal */ export const setAttribute = 'he';\n/** @internal */ export const setClassAttribute = 'hf';\n/** @internal */ export const setStyleAttribute = 'hg';\n/** @internal */ export const spreadTransferedBinding = 'hs';\n/** @internal */ export const spreadElementProp = 'hp';\n/** @internal */ export const spreadValueBinding = 'svb';\n\nexport const InstructionType = /*@__PURE__*/ tcObjectFreeze({\n  hydrateElement,\n  hydrateAttribute,\n  hydrateTemplateController,\n  hydrateLetElement,\n  setProperty,\n  interpolation,\n  propertyBinding,\n  letBinding,\n  refBinding,\n  iteratorBinding,\n  multiAttr,\n  textBinding,\n  listenerBinding,\n  attributeBinding,\n  stylePropertyBinding,\n  setAttribute,\n  setClassAttribute,\n  setStyleAttribute,\n  spreadTransferedBinding,\n  spreadElementProp,\n  spreadValueBinding,\n});\nexport type InstructionType = typeof InstructionType[keyof typeof InstructionType];\n\nexport interface IInstruction {\n  readonly type: string;\n}\nexport const IInstruction = /*@__PURE__*/tcCreateInterface<IInstruction>('Instruction');\n\nexport function isInstruction(value: unknown): value is IInstruction {\n  const type = (value as { type?: string }).type;\n  return isString(type) && type.length === 2;\n}\n\nexport class InterpolationInstruction {\n  public readonly type = interpolation;\n\n  public constructor(\n    public from: string | Interpolation,\n    public to: string,\n  ) {}\n}\n\nexport class PropertyBindingInstruction {\n  public readonly type = propertyBinding;\n\n  public constructor(\n    public from: string | IsBindingBehavior,\n    public to: string,\n    public mode: BindingMode,\n  ) {}\n}\n\nexport class IteratorBindingInstruction {\n  public readonly type = iteratorBinding;\n\n  public constructor(\n    public forOf: string | ForOfStatement,\n    public to: string,\n    public props: MultiAttrInstruction[],\n  ) {}\n}\n\nexport class RefBindingInstruction {\n  public readonly type = refBinding;\n\n  public constructor(\n    public readonly from: string | IsBindingBehavior,\n    public readonly to: string\n  ) {}\n}\n\nexport class SetPropertyInstruction {\n  public readonly type = setProperty;\n\n  public constructor(\n    public value: unknown,\n    public to: string,\n  ) {}\n}\n\nexport class MultiAttrInstruction {\n  public readonly type = multiAttr;\n\n  public constructor(\n    public value: string,\n    public to: string,\n    public command: string | null,\n  ) {}\n}\n\nexport class HydrateElementInstruction<\n  T extends Record<PropertyKey, unknown> = Record<PropertyKey, unknown>,\n  TDef extends IElementComponentDefinition = IElementComponentDefinition,\n> {\n  public readonly type = hydrateElement;\n\n  public constructor(\n    /**\n     * The name of the custom element this instruction is associated with\n     */\n    // in theory, Constructor of resources should be accepted too\n    // though it would be unnecessary right now\n    public res: string | /* Constructable |  */TDef,\n    /**\n     * Bindable instructions for the custom element instance\n     */\n    public props: IInstruction[],\n    /**\n     * Indicates what projections are associated with the element usage\n     */\n    public projections: Record<string, TDef> | null,\n    /**\n     * Indicates whether the usage of the custom element was with a containerless attribute or not\n     */\n    public containerless: boolean,\n    /**\n     * A list of captured attr syntaxes\n     */\n    public captures: AttrSyntax[] | undefined,\n    /**\n     * Any data associated with this instruction\n     */\n    public readonly data: T,\n  ) {\n  }\n}\n\n// the template type gives an opportunity for implementor of resources resolver to provide a more specific type\nexport class HydrateAttributeInstruction<T extends IAttributeComponentDefinition = IAttributeComponentDefinition> {\n  public readonly type = hydrateAttribute;\n\n  public constructor(\n    // in theory, Constructor of resources should be accepted too\n    // though it would be unnecessary right now\n    public res: string | /* Constructable |  */T,\n    public alias: string | undefined,\n    /**\n     * Bindable instructions for the custom attribute instance\n     */\n    public props: IInstruction[],\n  ) {}\n}\n\n// the template type gives an opportunity for implementor of resources resolver to provide a more specific type\nexport class HydrateTemplateController<T extends IAttributeComponentDefinition = IAttributeComponentDefinition> {\n  public readonly type = hydrateTemplateController;\n\n  public constructor(\n    public def: IElementComponentDefinition,\n    // in theory, Constructor of resources should be accepted too\n    // though it would be unnecessary right now\n    public res: string | /* Constructable |  */T,\n    public alias: string | undefined,\n    /**\n     * Bindable instructions for the template controller instance\n     */\n    public props: IInstruction[],\n  ) {}\n}\n\nexport class HydrateLetElementInstruction {\n  public readonly type = hydrateLetElement;\n\n  public constructor(\n    public instructions: LetBindingInstruction[],\n    public toBindingContext: boolean,\n  ) {}\n}\n\nexport class LetBindingInstruction {\n  public readonly type = letBinding;\n\n  public constructor(\n    public from: string | IsBindingBehavior | Interpolation,\n    public to: string,\n  ) {}\n}\n\nexport class TextBindingInstruction {\n  public readonly type = textBinding;\n\n  public constructor(\n    public from: string | IsBindingBehavior,\n  ) {}\n}\n\nexport class ListenerBindingInstruction {\n  public readonly type = listenerBinding;\n\n  public constructor(\n    public from: string | IsBindingBehavior,\n    public to: string,\n    public capture: boolean,\n    public modifier: string | null,\n  ) {}\n}\nexport class StylePropertyBindingInstruction {\n  public readonly type = stylePropertyBinding;\n\n  public constructor(\n    public from: string | IsBindingBehavior,\n    public to: string,\n  ) {}\n}\n\nexport class SetAttributeInstruction {\n  public readonly type = setAttribute;\n\n  public constructor(\n    public value: string,\n    public to: string,\n  ) {}\n}\n\nexport class SetClassAttributeInstruction {\n  public readonly type: typeof InstructionType.setClassAttribute = setClassAttribute;\n\n  public constructor(\n    public readonly value: string,\n  ) {}\n}\n\nexport class SetStyleAttributeInstruction {\n  public readonly type: typeof InstructionType.setStyleAttribute = setStyleAttribute;\n\n  public constructor(\n    public readonly value: string,\n  ) {}\n}\n\nexport class AttributeBindingInstruction {\n  public readonly type = attributeBinding;\n\n  public constructor(\n    /**\n     * `attr` and `to` have the same value on a normal attribute\n     * Will be different on `class` and `style`\n     * on `class`: attr = `class` (from binding command), to = attribute name\n     * on `style`: attr = `style` (from binding command), to = attribute name\n     */\n    public attr: string,\n    public from: string | IsBindingBehavior,\n    public to: string,\n  ) {}\n}\n\nexport class SpreadTransferedBindingInstruction {\n  public readonly type = spreadTransferedBinding;\n}\n\n/**\n * When spreading any attribute bindings onto an element,\n * it's possible that some attributes will be targeting the bindable properties of a custom element\n * This instruction is used to express that\n */\nexport class SpreadElementPropBindingInstruction {\n  public readonly type = spreadElementProp;\n  public constructor(\n    public readonly instruction: IInstruction,\n  ) {}\n}\n\nexport class SpreadValueBindingInstruction {\n  public readonly type = spreadValueBinding;\n  public constructor(\n    public target: '$bindables' | '$element',\n    public from: string,\n  ) {}\n}\n", "import { IExpressionParser } from '@aurelia/expression-parser';\nimport { Protocol, camelCase, emptyArray, firstDefined, getResourceKeyFor, mergeArrays, resolve, resource, resourceBaseName, isString } from '@aurelia/kernel';\nimport { defineMetadata, getMetadata } from './utilities-metadata';\nimport { IAttrMapper } from './attribute-mapper';\nimport {\n  AttributeBindingInstruction,\n  IteratorBindingInstruction,\n  ListenerBindingInstruction,\n  MultiAttrInstruction,\n  PropertyBindingInstruction,\n  RefBindingInstruction,\n  SpreadValueBindingInstruction,\n} from './instructions';\nimport { aliasRegistration, etIsFunction, etIsProperty, tcObjectFreeze, singletonRegistration } from './utilities';\n\nimport type {\n  Constructable,\n  IContainer,\n  IServiceLocator,\n  PartialResourceDefinition,\n  ResourceDefinition,\n  ResourceType,\n  StaticResourceType,\n} from '@aurelia/kernel';\nimport { AttrSyntax, IAttributeParser } from './attribute-pattern';\nimport { ErrorNames, createMappedError } from './errors';\nimport { IAttributeComponentDefinition, IElementComponentDefinition, IComponentBindablePropDefinition } from './interfaces-template-compiler';\nimport type { IInstruction } from './instructions';\nimport { BindingMode, InternalBindingMode } from './binding-mode';\n\nexport type PartialBindingCommandDefinition = PartialResourceDefinition;\nexport type BindingCommandStaticAuDefinition = PartialBindingCommandDefinition & {\n  type: 'binding-command';\n};\n\nexport interface IPlainAttrCommandInfo {\n  readonly node: Element;\n  readonly attr: AttrSyntax;\n  readonly bindable: null;\n  readonly def: null;\n}\n\nexport interface IBindableCommandInfo {\n  readonly node: Element;\n  readonly attr: AttrSyntax;\n  readonly bindable: IComponentBindablePropDefinition;\n  readonly def: IAttributeComponentDefinition | IElementComponentDefinition;\n}\n\nexport type ICommandBuildInfo = IPlainAttrCommandInfo | IBindableCommandInfo;\n\nexport type BindingCommandInstance<T extends {} = {}> = {\n  /**\n   * Characteristics of a binding command.\n   * - `false`: The normal process (check custom attribute -> check bindable -> command.build()) should take place.\n   * - `true`: The binding command wants to take over the processing of an attribute. The template compiler keeps the attribute as is in compilation, instead of executing the normal process.\n   */\n  ignoreAttr: boolean;\n  build(info: ICommandBuildInfo, parser: IExpressionParser, mapper: IAttrMapper): IInstruction;\n} & T;\n\nexport type BindingCommandType<T extends Constructable = Constructable> = ResourceType<T, BindingCommandInstance, PartialBindingCommandDefinition>;\nexport type BindingCommandKind = {\n  readonly name: string;\n  keyFrom(name: string): string;\n  // isType<T>(value: T): value is (T extends Constructable ? BindingCommandType<T> : never);\n  define<T extends Constructable>(name: string, Type: T): BindingCommandType<T>;\n  define<T extends Constructable>(def: PartialBindingCommandDefinition, Type: T): BindingCommandType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialBindingCommandDefinition, Type: T): BindingCommandType<T>;\n  getAnnotation<K extends keyof PartialBindingCommandDefinition>(Type: Constructable, prop: K): PartialBindingCommandDefinition[K] | undefined;\n  find(container: IContainer, name: string): BindingCommandDefinition | null;\n  get(container: IServiceLocator, name: string): BindingCommandInstance;\n};\n\nexport type BindingCommandDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => BindingCommandType<T>;\n\n/**\n * Decorator to describe a class as a binding command resource\n */\nexport function bindingCommand(name: string): BindingCommandDecorator;\nexport function bindingCommand(definition: PartialBindingCommandDefinition): BindingCommandDecorator;\nexport function bindingCommand(nameOrDefinition: string | PartialBindingCommandDefinition): BindingCommandDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext): BindingCommandType<T> {\n    context.addInitializer(function (this) {\n      BindingCommand.define(nameOrDefinition, target);\n    });\n    return target as BindingCommandType<T>;\n  };\n}\n\nexport class BindingCommandDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, BindingCommandInstance> {\n  private constructor(\n    public readonly Type: BindingCommandType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialBindingCommandDefinition,\n    Type: BindingCommandType<T>,\n  ): BindingCommandDefinition<T> {\n\n    let name: string;\n    let def: PartialBindingCommandDefinition;\n    if (isString(nameOrDef)) {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    return new BindingCommandDefinition(\n      Type,\n      firstDefined(getCommandAnnotation(Type, 'name'), name),\n      mergeArrays(getCommandAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      getCommandKeyFrom(name),\n    );\n  }\n\n  public register(container: IContainer, aliasName?: string | undefined): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getCommandKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    if (!container.has(key, false)) {\n      container.register(\n        container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n        aliasRegistration($Type, key),\n        ...aliases.map(alias => aliasRegistration($Type, getCommandKeyFrom(alias))),\n      );\n    } /* istanbul ignore next */ else if (__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV:aurelia] ${createMappedError(ErrorNames.binding_command_existed, this.name)}`);\n    }\n  }\n}\n\nconst bindingCommandTypeName = 'binding-command';\nconst cmdBaseName = /*@__PURE__*/getResourceKeyFor(bindingCommandTypeName);\nconst getCommandKeyFrom = (name: string): string => `${cmdBaseName}:${name}`;\nconst getCommandAnnotation = <K extends keyof PartialBindingCommandDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialBindingCommandDefinition[K] | undefined =>\n  getMetadata<PartialBindingCommandDefinition[K]>(Protocol.annotation.keyFor(prop), Type);\n\nexport const BindingCommand = /*@__PURE__*/ (() => {\n\n  const staticResourceDefinitionMetadataKey = '__au_static_resource__';\n  const getDefinitionFromStaticAu = <Def extends ResourceDefinition, C extends Constructable = Constructable>(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    Type: C | Function,\n    typeName: string,\n    createDef: (au: PartialResourceDefinition<Def>, Type: C) => Def,\n  ): Def => {\n    let def = getMetadata(staticResourceDefinitionMetadataKey, Type) as Def;\n    if (def == null) {\n      if ((Type as StaticResourceType<Def>).$au?.type === typeName) {\n        def = createDef((Type as StaticResourceType<Def>).$au!, Type as C);\n        defineMetadata(def, Type, staticResourceDefinitionMetadataKey);\n      }\n    }\n    return def;\n  };\n\n  return tcObjectFreeze<BindingCommandKind>({\n    name: cmdBaseName,\n    keyFrom: getCommandKeyFrom,\n    // isType<T>(value: T): value is (T extends Constructable ? BindingCommandType<T> : never) {\n    //   return isFunction(value) && hasOwnMetadata(cmdBaseName, value);\n    // },\n    define<T extends Constructable<BindingCommandInstance>>(nameOrDef: string | PartialBindingCommandDefinition, Type: T): T & BindingCommandType<T> {\n      const definition = BindingCommandDefinition.create(nameOrDef, Type as Constructable<BindingCommandInstance>);\n      const $Type = definition.Type as BindingCommandType<T>;\n\n      // registration of resource name is a requirement for the resource system in kernel (module-loader)\n      defineMetadata(definition, $Type, cmdBaseName, resourceBaseName);\n\n      return $Type;\n    },\n    getAnnotation: getCommandAnnotation,\n    find(container, name) {\n      const Type = container.find<BindingCommandType>(bindingCommandTypeName, name);\n      return Type == null\n        ? null\n        : getMetadata<BindingCommandDefinition>(cmdBaseName, Type) ?? getDefinitionFromStaticAu<BindingCommandDefinition, BindingCommandType>(Type, bindingCommandTypeName, BindingCommandDefinition.create) ?? null;\n    },\n    get(container, name) {\n      if (__DEV__) {\n        try {\n          return container.get<BindingCommandInstance>(resource(getCommandKeyFrom(name)));\n        } catch (ex) {\n          // eslint-disable-next-line no-console\n          console.log(`\\n\\n\\n[DEV:aurelia] Cannot retrieve binding command with name\\n\\n\\n\\n\\n`, name);\n          throw ex;\n        }\n      }\n      return container.get<BindingCommandInstance>(resource(getCommandKeyFrom(name)));\n    },\n  });\n})();\n\nexport class OneTimeBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'one-time',\n  };\n\n  public get ignoreAttr() { return false; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser, attrMapper: IAttrMapper): PropertyBindingInstruction {\n    const attr = info.attr;\n    let target = attr.target;\n    let value = info.attr.rawValue;\n    value = value === '' ? camelCase(target) : value;\n    if (info.bindable == null) {\n      target = attrMapper.map(info.node, target)\n        // if the mapper doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(target);\n    } else {\n      target = info.bindable.name;\n    }\n    return new PropertyBindingInstruction(exprParser.parse(value, etIsProperty), target, InternalBindingMode.oneTime);\n  }\n}\n\nexport class ToViewBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'to-view',\n  };\n  public get ignoreAttr() { return false; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser, attrMapper: IAttrMapper): PropertyBindingInstruction {\n    const attr = info.attr;\n    let target = attr.target;\n    let value = info.attr.rawValue;\n    value = value === '' ? camelCase(target) : value;\n    if (info.bindable == null) {\n      target = attrMapper.map(info.node, target)\n        // if the mapper doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(target);\n    } else {\n      target = info.bindable.name;\n    }\n    return new PropertyBindingInstruction(exprParser.parse(value, etIsProperty), target, InternalBindingMode.toView);\n  }\n}\n\nexport class FromViewBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'from-view',\n  };\n  public get ignoreAttr() { return false; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser, attrMapper: IAttrMapper): PropertyBindingInstruction {\n    const attr = info.attr;\n    let target = attr.target;\n    let value = attr.rawValue;\n    value = value === '' ? camelCase(target) : value;\n    if (info.bindable == null) {\n      target = attrMapper.map(info.node, target)\n        // if the mapper doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(target);\n    } else {\n      target = info.bindable.name;\n    }\n    return new PropertyBindingInstruction(exprParser.parse(value, etIsProperty), target, InternalBindingMode.fromView);\n  }\n}\n\nexport class TwoWayBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'two-way',\n  };\n  public get ignoreAttr() { return false; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser, attrMapper: IAttrMapper): PropertyBindingInstruction {\n    const attr = info.attr;\n    let target = attr.target;\n    let value = attr.rawValue;\n    value = value === '' ? camelCase(target) : value;\n    if (info.bindable == null) {\n      target = attrMapper.map(info.node, target)\n        // if the mapper doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(target);\n    } else {\n      target = info.bindable.name;\n    }\n    return new PropertyBindingInstruction(exprParser.parse(value, etIsProperty), target, InternalBindingMode.twoWay);\n  }\n}\n\nexport class DefaultBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'bind',\n  };\n  public get ignoreAttr() { return false; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser, attrMapper: IAttrMapper): PropertyBindingInstruction {\n    const attr = info.attr;\n    const bindable = info.bindable;\n    let value = attr.rawValue;\n    let target = attr.target;\n    let defDefaultMode: string | number;\n    let mode: string | number;\n    value = value === '' ? camelCase(target) : value;\n    if (bindable == null) {\n      mode = attrMapper.isTwoWay(info.node, target) ? InternalBindingMode.twoWay : InternalBindingMode.toView;\n      target = attrMapper.map(info.node, target)\n        // if the mapper doesn't know how to map it\n        // use the default behavior, which is camel-casing\n        ?? camelCase(target);\n    } else {\n      defDefaultMode = (info.def as IAttributeComponentDefinition).defaultBindingMode ?? 0;\n      mode = bindable.mode === 0 || bindable.mode == null\n        ? defDefaultMode == null || defDefaultMode === 0\n          ? InternalBindingMode.toView\n          : defDefaultMode\n        : bindable.mode;\n      target = bindable.name;\n    }\n    return new PropertyBindingInstruction(\n      exprParser.parse(value, etIsProperty),\n      target,\n      isString(mode)\n        ? BindingMode[mode as keyof typeof BindingMode] ?? InternalBindingMode.default\n        : mode as BindingMode\n    );\n  }\n}\n\nexport class ForBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'for',\n  };\n\n  public get ignoreAttr() { return false; }\n\n  /** @internal */\n  private readonly _attrParser = resolve(IAttributeParser);\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser): IInstruction {\n    const target = info.bindable === null\n      ? camelCase(info.attr.target)\n      : info.bindable.name;\n    const forOf = exprParser.parse(info.attr.rawValue, 'IsIterator');\n    let props: MultiAttrInstruction[] = emptyArray;\n    if (forOf.semiIdx > -1) {\n      const attr = info.attr.rawValue.slice(forOf.semiIdx + 1);\n      const i = attr.indexOf(':');\n      if (i > -1) {\n        const attrName = attr.slice(0, i).trim();\n        const attrValue = attr.slice(i + 1).trim();\n        const attrSyntax = this._attrParser.parse(attrName, attrValue);\n        props = [new MultiAttrInstruction(attrValue, attrSyntax.target, attrSyntax.command)];\n      }\n    }\n    return new IteratorBindingInstruction(forOf, target, props);\n  }\n}\n\nexport class TriggerBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'trigger',\n  };\n  public get ignoreAttr() { return true; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser): IInstruction {\n    return new ListenerBindingInstruction(\n      exprParser.parse(info.attr.rawValue, etIsFunction),\n      info.attr.target,\n      false,\n      info.attr.parts?.[2] ?? null\n    );\n  }\n}\n\nexport class CaptureBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'capture',\n  };\n  public get ignoreAttr() { return true; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser): IInstruction {\n    return new ListenerBindingInstruction(\n      exprParser.parse(info.attr.rawValue, etIsFunction),\n      info.attr.target,\n      true,\n      info.attr.parts?.[2] ?? null\n    );\n  }\n}\n\n/**\n * Attr binding command. Compile attr with binding symbol with command `attr` to `AttributeBindingInstruction`\n */\nexport class AttrBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'attr',\n  };\n  public get ignoreAttr() { return true; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser): IInstruction {\n    const attr = info.attr;\n    const target = attr.target;\n    let value = attr.rawValue;\n    value = value === '' ? camelCase(target) : value;\n    return new AttributeBindingInstruction(target, exprParser.parse(value, etIsProperty), target);\n  }\n}\n\n/**\n * Style binding command. Compile attr with binding symbol with command `style` to `AttributeBindingInstruction`\n */\nexport class StyleBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'style',\n  };\n  public get ignoreAttr() { return true; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser): IInstruction {\n    return new AttributeBindingInstruction('style', exprParser.parse(info.attr.rawValue, etIsProperty), info.attr.target);\n  }\n}\n\n/**\n * Class binding command. Compile attr with binding symbol with command `class` to `AttributeBindingInstruction`\n */\nexport class ClassBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'class',\n  };\n  public get ignoreAttr() { return true; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser): IInstruction {\n    let target = info.attr.target;\n\n    if (target.includes(\",\")) {\n      const classes = target\n        .split(\",\")\n        .filter(c => c.length > 0);\n\n      if (classes.length === 0) {\n        throw createMappedError(ErrorNames.compiler_invalid_class_binding_syntax);\n      }\n\n      target = classes.join(' ');\n    }\n\n    return new AttributeBindingInstruction(\"class\", exprParser.parse(info.attr.rawValue, etIsProperty), target);\n  }\n}\n\n/**\n * Binding command to refer different targets (element, custom element/attribute view models, controller) attached to an element\n */\nexport class RefBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'ref',\n  };\n  public get ignoreAttr() { return true; }\n\n  public build(info: ICommandBuildInfo, exprParser: IExpressionParser): IInstruction {\n    return new RefBindingInstruction(exprParser.parse(info.attr.rawValue, etIsProperty), info.attr.target);\n  }\n}\n\nexport class SpreadValueBindingCommand implements BindingCommandInstance {\n  public static readonly $au: BindingCommandStaticAuDefinition = {\n    type: bindingCommandTypeName,\n    name: 'spread',\n  };\n  public get ignoreAttr() { return false; }\n\n  public build(info: ICommandBuildInfo): IInstruction {\n    return new SpreadValueBindingInstruction(info.attr.target as '$bindables' | '$element', info.attr.rawValue);\n  }\n}\n", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n", "import { IPlatform, resolve, isString } from '@aurelia/kernel';\nimport { tcCreateInterface } from './utilities';\nimport { IDomPlatform } from './interfaces-template-compiler';\n\n/**\n * Utility that creates a `HTMLTemplateElement` out of string markup or an existing DOM node.\n *\n * It is idempotent in the sense that passing in an existing template element will simply return that template element,\n * so it is always safe to pass in a node without causing unnecessary DOM parsing or template creation.\n */\nexport interface ITemplateElementFactory {\n  createTemplate(input: string | Node): HTMLTemplateElement;\n}\nexport const ITemplateElementFactory = /*@__PURE__*/tcCreateInterface<ITemplateElementFactory>('ITemplateElementFactory', x => x.singleton(TemplateElementFactory));\n\nconst markupCache: Record<string, HTMLTemplateElement | undefined> = {};\n\nexport class TemplateElementFactory implements ITemplateElementFactory {\n  /** @internal */\n  private readonly p = resolve(IPlatform) as IDomPlatform;\n  /** @internal */\n  private _template = this.t();\n\n  private t() {\n    return this.p.document.createElement('template');\n  }\n\n  public createTemplate(input: string | Node): HTMLTemplateElement {\n    if (isString(input)) {\n      let result = markupCache[input];\n      if (result === void 0) {\n        const template = this._template;\n        template.innerHTML = input;\n        const node = template.content.firstElementChild;\n        // if the input is either not wrapped in a template or there is more than one node,\n        // return the whole template that wraps it/them (and create a new one for the next input)\n        if (needsWrapping(node)) {\n          this._template = this.t();\n          result = template;\n        } else {\n          // the node to return is both a template and the only node, so return just the node\n          // and clean up the template for the next input\n          template.content.removeChild(node!);\n          result = node as HTMLTemplateElement;\n        }\n\n        markupCache[input] = result;\n      }\n\n      return result.cloneNode(true) as HTMLTemplateElement;\n    }\n    if (input.nodeName !== 'TEMPLATE') {\n      // if we get one node that is not a template, wrap it in one\n      const template = this.t();\n      template.content.appendChild(input);\n      return template;\n    }\n    // we got a template element, remove it from the DOM if it's present there and don't\n    // do any other processing\n    input.parentNode?.removeChild(input);\n    return input.cloneNode(true) as HTMLTemplateElement;\n\n    function needsWrapping(node: Element | null | undefined): boolean {\n      if (node == null) return true;\n      if (node.nodeName !== 'TEMPLATE') return true;\n\n      // At this point the node is a template element.\n      // If the template has meaningful siblings, then it needs wrapping.\n\n      // low-hanging fruit: check the next element sibling\n      const nextElementSibling = node.nextElementSibling;\n      if (nextElementSibling != null) return true;\n\n      // check the previous sibling\n      const prevSibling = node.previousSibling;\n      if (prevSibling != null) {\n        switch (prevSibling.nodeType) {\n          // The previous sibling cannot be an element, because the node is the first element in the template.\n          case 3: // Text\n            return prevSibling.textContent!.trim().length > 0;\n        }\n      }\n\n      // the previous sibling was not meaningful, so check the next sibling\n      const nextSibling = node.nextSibling;\n      if (nextSibling != null) {\n        switch (nextSibling.nodeType) {\n          // element is already checked above\n          case 3: // Text\n            return nextSibling.textContent!.trim().length > 0;\n        }\n      }\n\n      // neither the previous nor the next sibling was meaningful, hence the template does not need wrapping\n      return false;\n    }\n  }\n}\n", "export type IRenderLocation<T extends ChildNode = ChildNode> = T & {\n  $start?: IRenderLocation<T>;\n};\n\n/** @internal */\nexport const auLocationStart = 'au-start';\n/** @internal */\nexport const auLocationEnd = 'au-end';\n\n/** @internal */\nexport const insertBefore = <T extends Node>(parent: Node, newChildNode: T, target: Node | null) => {\n  return parent.insertBefore(newChildNode, target);\n};\n\n/** @internal */\nexport const insertManyBefore = (parent: Node | null, target: Node | null, newChildNodes: ArrayLike<Node>) => {\n  if (parent === null) {\n    return;\n  }\n  const ii = newChildNodes.length;\n  let i = 0;\n  while (ii > i) {\n    parent.insertBefore(newChildNodes[i], target);\n    ++i;\n  }\n};\n\n/** @internal */\nexport const appendToTemplate = <T extends Node>(parent: HTMLTemplateElement, child: T) => {\n  return parent.content.appendChild(child);\n};\n\n/** @internal */\nexport const appendManyToTemplate = (parent: HTMLTemplateElement, children: ArrayLike<Node>) => {\n  const ii = children.length;\n  let i = 0;\n  while (ii > i) {\n    parent.content.appendChild(children[i]);\n    ++i;\n  }\n};\n\n/** @internal */\nexport const isElement = (node: Node): node is Element => node.nodeType === 1;\n\n/** @internal */\nexport const isTextNode = (node: Node): node is Text => node.nodeType === 3;\n", "/* eslint-disable @typescript-eslint/prefer-nullish-coalescing */\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport {\n  emptyArray,\n  toArray,\n  ILogger,\n  camelCase,\n  noop,\n  getResourceKeyFor,\n  allResources,\n  IPlatform,\n  pascalCase,\n  createImplementationRegister,\n  registrableMetadataKey,\n  isString,\n} from '@aurelia/kernel';\nimport {\n  IExpressionParser,\n  PrimitiveLiteralExpression,\n} from '@aurelia/expression-parser';\nimport { IAttrMapper } from './attribute-mapper';\nimport { ITemplateElementFactory } from './template-element-factory';\nimport {\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateLetElementInstruction,\n  HydrateTemplateController,\n  InterpolationInstruction,\n  LetBindingInstruction,\n  SetAttributeInstruction,\n  SetClassAttributeInstruction,\n  SetPropertyInstruction,\n  SetStyleAttributeInstruction,\n  TextBindingInstruction,\n  PropertyBindingInstruction,\n  SpreadElementPropBindingInstruction,\n  propertyBinding,\n  IInstruction,\n  SpreadTransferedBindingInstruction,\n  SpreadValueBindingInstruction,\n} from './instructions';\nimport { AttrSyntax, IAttributeParser } from './attribute-pattern';\nimport { BindingCommand, BindingCommandInstance, ICommandBuildInfo } from './binding-command';\nimport { etInterpolation, etIsProperty, tcObjectFreeze, tcCreateInterface, singletonRegistration, definitionTypeElement } from './utilities';\nimport { auLocationStart, auLocationEnd, appendManyToTemplate, appendToTemplate, insertBefore, insertManyBefore, isElement, isTextNode } from './utilities-dom';\n\nimport type {\n  IContainer,\n  Constructable,\n  Writable,\n  Key,\n  IRegistry,\n} from '@aurelia/kernel';\nimport type {\n  AnyBindingExpression,\n  IsBindingBehavior,\n} from '@aurelia/expression-parser';\nimport type {\n  IAttributeComponentDefinition,\n  ICompiledElementComponentDefinition,\n  IComponentBindablePropDefinition,\n  IDomPlatform,\n  IElementComponentDefinition,\n  StringBindingMode,\n} from './interfaces-template-compiler';\nimport { ErrorNames, createMappedError } from './errors';\nimport { ITemplateCompiler } from './interfaces-template-compiler';\n\nconst auslotAttr = 'au-slot';\nconst defaultSlotName = 'default';\nexport const generateElementName = ((id) => () => `anonymous-${++id}`)(0);\n\nexport class TemplateCompiler implements ITemplateCompiler {\n  public static register = /*@__PURE__*/ createImplementationRegister(ITemplateCompiler);\n\n  public debug: boolean = false;\n  public resolveResources: boolean = true;\n\n  public compile(\n    definition: IElementComponentDefinition,\n    container: IContainer,\n  ): ICompiledElementComponentDefinition {\n    if (definition.template == null || definition.needsCompile === false) {\n      return definition as ICompiledElementComponentDefinition;\n    }\n\n    const context = new CompilationContext(definition, container, null, null, void 0);\n    const template = isString(definition.template) || !definition.enhance\n      ? context._templateFactory.createTemplate(definition.template)\n      : definition.template as HTMLElement;\n    const isTemplateElement = template.nodeName === TEMPLATE_NODE_NAME && (template as HTMLTemplateElement).content != null;\n    const content = isTemplateElement ? (template as HTMLTemplateElement).content : template;\n    const hooks = TemplateCompilerHooks.findAll(container);\n    const ii = hooks.length;\n    let i = 0;\n    if (ii > 0) {\n      while (ii > i) {\n        hooks[i].compiling?.(template);\n        ++i;\n      }\n    }\n\n    if (template.hasAttribute(localTemplateIdentifier)) {\n      throw createMappedError(ErrorNames.compiler_root_is_local, definition);\n    }\n    this._compileLocalElement(content, context);\n    this._compileNode(content, context);\n\n    const compiledDef = {\n      ...definition,\n      name: definition.name || generateElementName(),\n      dependencies: (definition.dependencies ?? emptyArray).concat(context.deps ?? emptyArray),\n      instructions: context.rows,\n      surrogates: isTemplateElement\n        ? this._compileSurrogate(template, context)\n        : emptyArray,\n      template,\n      hasSlots: context.hasSlot,\n      needsCompile: false,\n    } satisfies ICompiledElementComponentDefinition;\n\n    return compiledDef;\n  }\n\n  public compileSpread(\n    requestor: IElementComponentDefinition,\n    attrSyntaxs: AttrSyntax[],\n    container: IContainer,\n    target: Element,\n    targetDef?: IElementComponentDefinition,\n  ): IInstruction[] {\n    const context = new CompilationContext(requestor, container, null, null, void 0);\n    const instructions: IInstruction[] = [];\n    const elDef = targetDef ?? context._findElement(target.nodeName.toLowerCase());\n    const isCustomElement = elDef !== null;\n    const exprParser = context._exprParser;\n    const ii = attrSyntaxs.length;\n    let i = 0;\n    let attrSyntax: AttrSyntax;\n    let attrDef: IAttributeComponentDefinition | null = null;\n    let attrInstructions: (HydrateAttributeInstruction | HydrateTemplateController)[] | undefined;\n    let attrBindableInstructions: IInstruction[];\n    let bindablesInfo: IAttributeBindablesInfo | IElementBindablesInfo;\n    let bindable: IComponentBindablePropDefinition;\n    let primaryBindable: IComponentBindablePropDefinition;\n    let bindingCommand: BindingCommandInstance | null = null;\n    let expr: AnyBindingExpression;\n    let isMultiBindings: boolean;\n    let attrTarget: string;\n    let attrValue: string;\n\n    for (; ii > i; ++i) {\n      attrSyntax = attrSyntaxs[i];\n\n      attrTarget = attrSyntax.target;\n      attrValue = attrSyntax.rawValue;\n\n      if (attrTarget === '...$attrs') {\n        instructions.push(new SpreadTransferedBindingInstruction());\n        continue;\n      }\n\n      bindingCommand = context._getCommand(attrSyntax);\n      if (bindingCommand !== null && bindingCommand.ignoreAttr) {\n        // when the binding command overrides everything\n        // just pass the target as is to the binding command, and treat it as a normal attribute:\n        // active.class=\"...\"\n        // background.style=\"...\"\n        // my-attr.attr=\"...\"\n\n        commandBuildInfo.node = target;\n        commandBuildInfo.attr = attrSyntax;\n        commandBuildInfo.bindable = null;\n        commandBuildInfo.def = null;\n        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));\n\n        // to next attribute\n        continue;\n      }\n\n      if (isCustomElement) {\n        // if the element is a custom element\n        // - prioritize bindables on a custom element before plain attributes\n        bindablesInfo = context._getBindables(elDef);\n        bindable = bindablesInfo.attrs[attrTarget];\n        if (bindable !== void 0) {\n          if (bindingCommand == null) {\n            expr = exprParser.parse(attrValue, etInterpolation);\n            instructions.push(\n              new SpreadElementPropBindingInstruction(\n                expr == null\n                  ? new SetPropertyInstruction(attrValue, bindable.name)\n                  : new InterpolationInstruction(expr, bindable.name)\n              )\n            );\n          } else {\n            commandBuildInfo.node = target;\n            commandBuildInfo.attr = attrSyntax;\n            commandBuildInfo.bindable = bindable;\n            commandBuildInfo.def = elDef;\n            instructions.push(new SpreadElementPropBindingInstruction(bindingCommand.build(\n              commandBuildInfo,\n              context._exprParser,\n              context._attrMapper\n            )));\n          }\n          continue;\n        }\n      }\n\n      attrDef = context._findAttr(attrTarget);\n      if (attrDef !== null) {\n        if (attrDef.isTemplateController) {\n          throw createMappedError(ErrorNames.no_spread_template_controller, attrTarget);\n        }\n        bindablesInfo = context._getBindables(attrDef);\n        // Custom attributes are always in multiple binding mode,\n        // except when they can't be\n        // When they cannot be:\n        //        * has explicit configuration noMultiBindings: false\n        //        * has binding command, ie: <div my-attr.bind=\"...\">.\n        //          In this scenario, the value of the custom attributes is required to be a valid expression\n        //        * has no colon: ie: <div my-attr=\"abcd\">\n        //          In this scenario, it's simply invalid syntax.\n        //          Consider style attribute rule-value pair: <div style=\"rule: ruleValue\">\n        isMultiBindings = attrDef.noMultiBindings === false\n          && bindingCommand === null\n          && hasInlineBindings(attrValue);\n        if (isMultiBindings) {\n          attrBindableInstructions = this._compileMultiBindings(target, attrValue, attrDef, context);\n        } else {\n          primaryBindable = bindablesInfo.primary;\n          // custom attribute + single value + WITHOUT binding command:\n          // my-attr=\"\"\n          // my-attr=\"${}\"\n          if (bindingCommand === null) {\n            expr = exprParser.parse(attrValue, etInterpolation);\n            attrBindableInstructions = [\n              expr === null\n                ? new SetPropertyInstruction(attrValue, primaryBindable.name)\n                : new InterpolationInstruction(expr, primaryBindable.name)\n            ];\n          } else {\n            // custom attribute with binding command:\n            // my-attr.bind=\"...\"\n            // my-attr.two-way=\"...\"\n\n            commandBuildInfo.node = target;\n            commandBuildInfo.attr = attrSyntax;\n            commandBuildInfo.bindable = primaryBindable;\n            commandBuildInfo.def = attrDef;\n            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];\n          }\n        }\n\n        (attrInstructions ??= []).push(new HydrateAttributeInstruction(\n          // todo: def/ def.Type or def.name should be configurable\n          //       example: AOT/runtime can use def.Type, but there are situation\n          //       where instructions need to be serialized, def.name should be used\n          this.resolveResources ? attrDef : attrDef.name,\n          attrDef.aliases != null && attrDef.aliases.includes(attrTarget) ? attrTarget : void 0,\n          attrBindableInstructions\n        ));\n        continue;\n      }\n\n      if (bindingCommand == null) {\n        expr = exprParser.parse(attrValue, etInterpolation);\n\n        // reaching here means:\n        // + maybe a plain attribute with interpolation\n        // + maybe a plain attribute\n\n        if (expr != null) {\n          instructions.push(new InterpolationInstruction(\n            expr,\n            // if not a bindable, then ensure plain attribute are mapped correctly:\n            // e.g: colspan -> colSpan\n            //      innerhtml -> innerHTML\n            //      minlength -> minLength etc...\n            context._attrMapper.map(target, attrTarget) ?? camelCase(attrTarget)\n          ));\n        } else {\n          switch (attrTarget) {\n            case 'class':\n              instructions.push(new SetClassAttributeInstruction(attrValue));\n              break;\n            case 'style':\n              instructions.push(new SetStyleAttributeInstruction(attrValue));\n              break;\n            default:\n              // if not a custom attribute + no binding command + not a bindable + not an interpolation\n              // then it's just a plain attribute\n              instructions.push(new SetAttributeInstruction(attrValue, attrTarget));\n          }\n        }\n      } else {\n        // reaching here means:\n        // + a plain attribute with binding command\n        commandBuildInfo.node = target;\n        commandBuildInfo.attr = attrSyntax;\n        commandBuildInfo.bindable = null;\n        commandBuildInfo.def = null;\n        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));\n      }\n    }\n\n    resetCommandBuildInfo();\n\n    if (attrInstructions != null) {\n      return (attrInstructions as IInstruction[]).concat(instructions);\n    }\n\n    return instructions;\n  }\n\n  /** @internal */\n  private _compileSurrogate(el: Element, context: CompilationContext): IInstruction[] {\n    const instructions: IInstruction[] = [];\n    const attrs = el.attributes;\n    const exprParser = context._exprParser;\n    let ii = attrs.length;\n    let i = 0;\n    let attr: Attr;\n    let attrName: string;\n    let attrValue: string;\n    let attrSyntax: AttrSyntax;\n    let attrDef: IAttributeComponentDefinition | null = null;\n    let attrInstructions: HydrateAttributeInstruction[] | undefined;\n    let attrBindableInstructions: IInstruction[];\n    let bindableInfo: IElementBindablesInfo | IAttributeBindablesInfo;\n    let primaryBindable: IComponentBindablePropDefinition;\n    let bindingCommand: BindingCommandInstance | null = null;\n    let expr: AnyBindingExpression;\n    let isMultiBindings: boolean;\n    let realAttrTarget: string;\n    let realAttrValue: string;\n\n    for (; ii > i; ++i) {\n      attr = attrs[i];\n      attrName = attr.name;\n      attrValue = attr.value;\n      attrSyntax = context._attrParser.parse(attrName, attrValue);\n\n      realAttrTarget = attrSyntax.target;\n      realAttrValue = attrSyntax.rawValue;\n\n      if (invalidSurrogateAttribute[realAttrTarget]) {\n        throw createMappedError(ErrorNames.compiler_invalid_surrogate_attr, attrName);\n      }\n\n      bindingCommand = context._getCommand(attrSyntax);\n      if (bindingCommand !== null && bindingCommand.ignoreAttr) {\n        // when the binding command overrides everything\n        // just pass the target as is to the binding command, and treat it as a normal attribute:\n        // active.class=\"...\"\n        // background.style=\"...\"\n        // my-attr.attr=\"...\"\n\n        commandBuildInfo.node = el;\n        commandBuildInfo.attr = attrSyntax;\n        commandBuildInfo.bindable = null;\n        commandBuildInfo.def = null;\n        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));\n\n        // to next attribute\n        continue;\n      }\n\n      attrDef = context._findAttr(realAttrTarget);\n      if (attrDef !== null) {\n        if (attrDef.isTemplateController) {\n          throw createMappedError(ErrorNames.compiler_no_tc_on_surrogate, realAttrTarget);\n        }\n        bindableInfo = context._getBindables(attrDef);\n        // Custom attributes are always in multiple binding mode,\n        // except when they can't be\n        // When they cannot be:\n        //        * has explicit configuration noMultiBindings: false\n        //        * has binding command, ie: <div my-attr.bind=\"...\">.\n        //          In this scenario, the value of the custom attributes is required to be a valid expression\n        //        * has no colon: ie: <div my-attr=\"abcd\">\n        //          In this scenario, it's simply invalid syntax.\n        //          Consider style attribute rule-value pair: <div style=\"rule: ruleValue\">\n        isMultiBindings = attrDef.noMultiBindings === false\n          && bindingCommand === null\n          && hasInlineBindings(realAttrValue);\n        if (isMultiBindings) {\n          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);\n        } else {\n          primaryBindable = bindableInfo.primary;\n          // custom attribute + single value + WITHOUT binding command:\n          // my-attr=\"\"\n          // my-attr=\"${}\"\n          if (bindingCommand === null) {\n            expr = exprParser.parse(realAttrValue, etInterpolation);\n            attrBindableInstructions = expr === null\n              ? realAttrValue === ''\n                // when the attribute usage is <div attr>\n                // it's considered as no bindings\n                ? []\n                : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)]\n              : [new InterpolationInstruction(expr, primaryBindable.name)];\n          } else {\n            // custom attribute with binding command:\n            // my-attr.bind=\"...\"\n            // my-attr.two-way=\"...\"\n\n            commandBuildInfo.node = el;\n            commandBuildInfo.attr = attrSyntax;\n            commandBuildInfo.bindable = primaryBindable;\n            commandBuildInfo.def = attrDef;\n            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];\n          }\n        }\n\n        el.removeAttribute(attrName);\n        --i;\n        --ii;\n        (attrInstructions ??= []).push(new HydrateAttributeInstruction(\n          // todo: def/ def.Type or def.name should be configurable\n          //       example: AOT/runtime can use def.Type, but there are situation\n          //       where instructions need to be serialized, def.name should be used\n          this.resolveResources ? attrDef : attrDef.name,\n          attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,\n          attrBindableInstructions\n        ));\n        continue;\n      }\n\n      if (bindingCommand === null) {\n        expr = exprParser.parse(realAttrValue, etInterpolation);\n        if (expr != null) {\n          el.removeAttribute(attrName);\n          --i;\n          --ii;\n\n          instructions.push(new InterpolationInstruction(\n            expr,\n            // if not a bindable, then ensure plain attribute are mapped correctly:\n            // e.g: colspan -> colSpan\n            //      innerhtml -> innerHTML\n            //      minlength -> minLength etc...\n            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)\n          ));\n        } else {\n          switch (attrName) {\n            case 'class':\n              instructions.push(new SetClassAttributeInstruction(realAttrValue));\n              break;\n            case 'style':\n              instructions.push(new SetStyleAttributeInstruction(realAttrValue));\n              break;\n            default:\n              // if not a custom attribute + no binding command + not a bindable + not an interpolation\n              // then it's just a plain attribute\n              instructions.push(new SetAttributeInstruction(realAttrValue, attrName));\n          }\n        }\n      } else {\n\n        commandBuildInfo.node = el;\n        commandBuildInfo.attr = attrSyntax;\n        commandBuildInfo.bindable = null;\n        commandBuildInfo.def = null;\n        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));\n      }\n    }\n\n    resetCommandBuildInfo();\n\n    if (attrInstructions != null) {\n      return (attrInstructions as IInstruction[]).concat(instructions);\n    }\n\n    return instructions;\n  }\n\n  // overall flow:\n  // each of the method will be responsible for compiling its corresponding node type\n  // and it should return the next node to be compiled\n  /** @internal */\n  private _compileNode(node: Node, context: CompilationContext): Node | null {\n    switch (node.nodeType) {\n      case 1:\n        switch (node.nodeName) {\n          case 'LET':\n            return this._compileLet(node as Element, context);\n          // ------------------------------------\n          // todo: possible optimization:\n          // when two conditions below are met:\n          // 1. there's no attribute on au slot,\n          // 2. there's no projection\n          //\n          // -> flatten the au-slot into children as this is just a static template\n          // ------------------------------------\n          // case 'AU-SLOT':\n          //   return this.auSlot(node as Element, container, context);\n          default:\n            return this._compileElement(node as Element, context);\n        }\n      case 3:\n        return this._compileText(node as Text, context);\n      case 11: {\n        let current: Node | null = (node as DocumentFragment).firstChild;\n        while (current !== null) {\n          current = this._compileNode(current, context);\n        }\n        break;\n      }\n    }\n    return node.nextSibling;\n  }\n\n  /** @internal */\n  private _compileLet(el: Element, context: CompilationContext): Node | null {\n    const attrs = el.attributes;\n    const ii = attrs.length;\n    const letInstructions: LetBindingInstruction[] = [];\n    const exprParser = context._exprParser;\n    let toBindingContext = false;\n    let i = 0;\n    let attr: Attr;\n    let attrSyntax: AttrSyntax;\n    let attrName: string;\n    let attrValue: string;\n    let bindingCommand: BindingCommandInstance | null;\n    let realAttrTarget: string;\n    let realAttrValue: string;\n    let expr: AnyBindingExpression;\n\n    for (; ii > i; ++i) {\n      attr = attrs[i];\n      attrName = attr.name;\n      attrValue = attr.value;\n      if (attrName === 'to-binding-context') {\n        toBindingContext = true;\n        continue;\n      }\n\n      attrSyntax = context._attrParser.parse(attrName, attrValue);\n      realAttrTarget = attrSyntax.target;\n      realAttrValue = attrSyntax.rawValue;\n\n      bindingCommand = context._getCommand(attrSyntax);\n      if (bindingCommand !== null) {\n        if (attrSyntax.command === 'bind') {\n          letInstructions.push(new LetBindingInstruction(\n            exprParser.parse(realAttrValue, etIsProperty),\n            camelCase(realAttrTarget)\n          ));\n        } else {\n          throw createMappedError(ErrorNames.compiler_invalid_let_command, attrSyntax);\n        }\n        continue;\n      }\n\n      expr = exprParser.parse(realAttrValue, etInterpolation);\n      if (expr === null) {\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `[DEV:aurelia] Property \"${realAttrTarget}\" is declared with literal string ${realAttrValue}. ` +\n            `Did you mean ${realAttrTarget}.bind=\"${realAttrValue}\"?`\n          );\n        }\n      }\n\n      letInstructions.push(new LetBindingInstruction(\n        expr === null ? new PrimitiveLiteralExpression(realAttrValue) : expr,\n        camelCase(realAttrTarget)\n      ));\n    }\n    context.rows.push([new HydrateLetElementInstruction(letInstructions, toBindingContext)]);\n    // probably no need to replace\n    // as the let itself can be used as is\n    // though still need to mark el as target to ensure the instruction is matched with a target\n    return this._markAsTarget(el, context).nextSibling;\n  }\n\n  /** @internal */\n  // eslint-disable-next-line\n  private _compileElement(el: Element, context: CompilationContext): Node | null {\n    // overall, the template compiler does it job by compiling one node,\n    // and let that the process of compiling that node point to the next node to be compiled.\n    // ----------------------------------------\n    // a summary of this 650 line long function:\n    // 1. walk through all attributes to put them into their corresponding instruction groups\n    //    template controllers      -> list 1\n    //    custom attributes         -> list 2\n    //    plain attrs with bindings -> list 3\n    //    el bindables              -> list 4\n    // 2. ensure element instruction is present\n    // 3. sort instructions:\n    //    hydrate custom element instruction\n    //    hydrate custom attribute instructions\n    //    rest kept as is (except special cases & to-be-decided)\n    //    3.1\n    //      mark this element as a target for later hydration\n    // 4. Compiling child nodes of this element\n    //    4.1.\n    //      If 1 or more [Template controller]:\n    //      4.1.1.\n    //          Start processing the most inner (most right TC in list 1) similarly to step 4.2:\n    //          4.1.1.0.\n    //          let innerContext = context.createChild();\n    //          4.1.1.1.\n    //              walks through the child nodes, and perform a [au-slot] check\n    //              - if this is a custom element, then extract all [au-slot] annotated elements into corresponding templates by their target slot name\n    //              - else throw an error as [au-slot] is used on non-custom-element\n    //          4.1.1.2.\n    //              recursively compiles the child nodes into the innerContext\n    //      4.1.2.\n    //          Start processing other Template controllers by walking the TC list (list 1) RIGHT -> LEFT\n    //          Explanation:\n    //              If there' are multiple template controllers on an element,\n    //              only the most inner template controller will have access to the template with the current element\n    //              other \"outer\" template controller will only need to see a marker pointing to a definition of the inner one\n    //    4.2.\n    //      NO [Template controller]\n    //      4.2.1.\n    //          walks through the child nodes, and perform a [au-slot] check\n    //          - if this is a custom element, then extract all [au-slot] annotated elements into corresponding templates by their target slot name\n    //          - else throw an error as [au-slot] is used on non-custom-element\n    //      4.2.2\n    //          recursively compiles the child nodes into the current context\n    // 5. Returning the next node for the compilation\n    const nextSibling = el.nextSibling;\n    const elName = (el.getAttribute('as-element') ?? el.nodeName).toLowerCase();\n    const elDef = context._findElement(elName);\n\n    const isCustomElement = elDef !== null;\n    const isShadowDom = isCustomElement && elDef.shadowOptions != null;\n    const capture = elDef?.capture;\n    const hasCaptureFilter = capture != null && typeof capture !== 'boolean';\n    const captures: AttrSyntax[] = capture ? [] : emptyArray;\n    const exprParser = context._exprParser;\n    const removeAttr = this.debug\n      ? noop\n      : () => {\n        el.removeAttribute(attrName);\n        --i;\n        --ii;\n      };\n    let attrs = el.attributes;\n    let instructions: IInstruction[] | undefined;\n    let ii = attrs.length;\n    let i = 0;\n    let attr: Attr;\n    let attrName: string;\n    let attrValue: string;\n    let attrSyntax: AttrSyntax;\n    /**\n     * A list of plain attribute bindings/interpolation bindings\n     */\n    let plainAttrInstructions: IInstruction[] | undefined;\n    let elBindableInstructions: IInstruction[] | undefined;\n    let attrDef: IAttributeComponentDefinition | null = null;\n    let isMultiBindings = false;\n    let bindable: IComponentBindablePropDefinition;\n    let attrInstructions: HydrateAttributeInstruction[] | undefined;\n    let attrBindableInstructions: IInstruction[];\n    let tcInstructions: HydrateTemplateController[] | undefined;\n    let tcInstruction: HydrateTemplateController | undefined;\n    let expr: AnyBindingExpression;\n    let elementInstruction: HydrateElementInstruction | undefined;\n    let bindingCommand: BindingCommandInstance | null = null;\n    let bindablesInfo: IElementBindablesInfo | IAttributeBindablesInfo;\n    let primaryBindable: IComponentBindablePropDefinition;\n    let realAttrTarget: string;\n    let realAttrValue: string;\n    let processContentResult: boolean | undefined | void = true;\n    let hasContainerless = false;\n    let canCapture = false;\n    let needsMarker = false;\n    let elementMetadata: Record<PropertyKey, unknown>;\n    let spreadIndex = 0;\n\n    if (elName === 'slot') {\n      if (context.root.def.shadowOptions == null) {\n        throw createMappedError(ErrorNames.compiler_slot_without_shadowdom, context.root.def.name);\n      }\n      context.root.hasSlot = true;\n    }\n    if (isCustomElement) {\n      elementMetadata = {};\n      // todo: this is a bit ... powerful\n      // maybe do not allow it to process its own attributes\n      processContentResult = elDef.processContent?.call(elDef.Type, el as HTMLElement, context.p, elementMetadata);\n      // might have changed during the process\n      attrs = el.attributes;\n      ii = attrs.length;\n    }\n\n    // 1. walk and compile through all attributes\n    //    for each of them, put in appropriate group.\n    //    ex. plain attr with binding -> plain attr instruction list\n    //        template controller     -> tc instruction list\n    //        custom attribute        -> ca instruction list\n    //        el bindable attribute   -> el bindable instruction list\n    for (; ii > i; ++i) {\n      attr = attrs[i];\n      attrName = attr.name;\n      attrValue = attr.value;\n      switch (attrName) {\n        // ignore these 2 attributes\n        case 'as-element':\n        case 'containerless':\n          removeAttr();\n          hasContainerless = hasContainerless || attrName === 'containerless';\n          continue;\n      }\n\n      attrSyntax = context._attrParser.parse(attrName, attrValue);\n      bindingCommand = context._getCommand(attrSyntax);\n\n      realAttrTarget = attrSyntax.target;\n      realAttrValue = attrSyntax.rawValue;\n\n      if (capture && (!hasCaptureFilter || hasCaptureFilter && capture(realAttrTarget))) {\n        if (bindingCommand != null && bindingCommand.ignoreAttr) {\n          removeAttr();\n          captures.push(attrSyntax);\n          continue;\n        }\n\n        canCapture = realAttrTarget !== auslotAttr\n          && realAttrTarget !== 'slot'\n          && ((spreadIndex = realAttrTarget.indexOf('...')) === -1\n            // the following condition will allow syntaxes:\n            // ...$bindables\n            // ...some.expression\n            || (spreadIndex === 0 && (realAttrTarget === '...$attrs'))\n          );\n        if (canCapture) {\n          bindablesInfo = context._getBindables(elDef);\n          // if capture is on, capture everything except:\n          // - as-element\n          // - containerless\n          // - bindable properties\n          // - template controller\n          if (bindablesInfo.attrs[realAttrTarget] == null && !context._findAttr(realAttrTarget)?.isTemplateController) {\n            removeAttr();\n            captures.push(attrSyntax);\n            continue;\n          }\n        }\n      }\n\n      if (realAttrTarget === '...$attrs') {\n        (plainAttrInstructions ??= []).push(new SpreadTransferedBindingInstruction());\n        removeAttr();\n        continue;\n      }\n\n      if (bindingCommand?.ignoreAttr) {\n        // when the binding command overrides everything\n        // just pass the target as is to the binding command, and treat it as a normal attribute:\n        // active.class=\"...\"\n        // background.style=\"...\"\n        // my-attr.attr=\"...\"\n\n        commandBuildInfo.node = el;\n        commandBuildInfo.attr = attrSyntax;\n        commandBuildInfo.bindable = null;\n        commandBuildInfo.def = null;\n        (plainAttrInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));\n        removeAttr();\n        // to next attribute\n        continue;\n      }\n\n      if (realAttrTarget.indexOf('...') === 0) {\n        if (isCustomElement && (realAttrTarget = realAttrTarget.slice(3)) !== '$element') {\n          (elBindableInstructions ??= []).push(new SpreadValueBindingInstruction(\n            '$bindables',\n            realAttrTarget === '$bindables' ? realAttrValue : realAttrTarget\n          ));\n          removeAttr();\n          continue;\n        }\n\n        if (__DEV__) {\n          if (realAttrTarget === '$bindable' || realAttrTarget === 'bindables') {\n            // eslint-disable-next-line no-console\n            console.warn(`[DEV:aurelia] Detected usage of ${realAttrTarget} on <${el.nodeName}>, did you mean \"$bindables\"?`);\n          }\n        }\n\n        throw createMappedError(ErrorNames.compiler_no_reserved_spread_syntax, realAttrTarget);\n      }\n\n      // reaching here means:\n      // + there may or may not be a binding command, but it won't be an overriding command\n\n      if (isCustomElement) {\n        // if the element is a custom element\n        // - prioritize bindables on a custom element before plain attributes\n        bindablesInfo = context._getBindables(elDef);\n        bindable = bindablesInfo.attrs[realAttrTarget];\n        if (bindable !== void 0) {\n          if (bindingCommand === null) {\n            expr = exprParser.parse(realAttrValue, etInterpolation);\n            (elBindableInstructions ??= []).push(\n              expr == null\n                ? new SetPropertyInstruction(realAttrValue, bindable.name)\n                : new InterpolationInstruction(expr, bindable.name)\n            );\n          } else {\n            commandBuildInfo.node = el;\n            commandBuildInfo.attr = attrSyntax;\n            commandBuildInfo.bindable = bindable;\n            commandBuildInfo.def = elDef;\n            (elBindableInstructions ??= []).push(bindingCommand.build(\n              commandBuildInfo,\n              context._exprParser,\n              context._attrMapper\n            ));\n          }\n\n          removeAttr();\n\n          if (__DEV__) {\n            attrDef = context._findAttr(realAttrTarget);\n            if (attrDef !== null) {\n              // eslint-disable-next-line no-console\n              console.warn(`[DEV:aurelia] Binding with bindable \"${realAttrTarget}\" on custom element \"${elDef.name}\" is ambiguous.` +\n                `There is a custom attribute with the same name.`\n              );\n            }\n          }\n          continue;\n        }\n\n        if (realAttrTarget === '$bindables') {\n          if (bindingCommand != null) {\n            commandBuildInfo.node = el;\n            commandBuildInfo.attr = attrSyntax;\n            commandBuildInfo.bindable = null;\n            commandBuildInfo.def = elDef;\n\n            if (__DEV__) {\n              const instruction = bindingCommand.build(\n                commandBuildInfo,\n                context._exprParser,\n                context._attrMapper\n              );\n              if (!(instruction instanceof SpreadValueBindingInstruction)) {\n                // eslint-disable-next-line no-console\n                console.warn(`[DEV:aurelia] Binding with \"$bindables\" on custom element \"${elDef.name}\" with command ${attrSyntax.command} ` +\n                  ` did not result in a spread binding instruction. This likely won't work as expected.`\n                );\n              }\n              (elBindableInstructions ??= []).push(instruction);\n            } else {\n              (elBindableInstructions ??= []).push(bindingCommand.build(\n                commandBuildInfo,\n                context._exprParser,\n                context._attrMapper\n              ));\n            }\n          } else if (__DEV__) {\n            // eslint-disable-next-line no-console\n            console.warn(`[DEV:aurelia] Usage of \"$bindables\" on custom element \"<${elDef.name}>\" is ignored.`);\n          }\n\n          removeAttr();\n          continue;\n        }\n      }\n\n      if (realAttrTarget === '$bindables') {\n        throw createMappedError(ErrorNames.compiler_no_reserved_$bindable, el.nodeName, realAttrTarget, realAttrValue);\n      }\n\n      // reaching here means:\n      // + there may or may not be a binding command, but it won't be an overriding command\n      // + the attribute is not targeting a bindable property of a custom element\n      //\n      // + maybe it's a custom attribute\n      // + maybe it's a plain attribute\n\n      // check for custom attributes before plain attributes\n      attrDef = context._findAttr(realAttrTarget);\n      if (attrDef !== null) {\n        bindablesInfo = context._getBindables(attrDef);\n        // Custom attributes are always in multiple binding mode,\n        // except when they can't be\n        // When they cannot be:\n        //        * has explicit configuration noMultiBindings: false\n        //        * has binding command, ie: <div my-attr.bind=\"...\">.\n        //          In this scenario, the value of the custom attributes is required to be a valid expression\n        //        * has no colon: ie: <div my-attr=\"abcd\">\n        //          In this scenario, it's simply invalid syntax.\n        //          Consider style attribute rule-value pair: <div style=\"rule: ruleValue\">\n        isMultiBindings = attrDef.noMultiBindings === false\n          && bindingCommand === null\n          && hasInlineBindings(realAttrValue);\n        if (isMultiBindings) {\n          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);\n        } else {\n          primaryBindable = bindablesInfo.primary;\n          // custom attribute + single value + WITHOUT binding command:\n          // my-attr=\"\"\n          // my-attr=\"${}\"\n          if (bindingCommand === null) {\n            expr = exprParser.parse(realAttrValue, etInterpolation);\n            attrBindableInstructions = expr === null\n              ? realAttrValue === ''\n                // when the attribute usage is <div attr>\n                // it's considered as no bindings\n                ? []\n                : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)]\n              : [new InterpolationInstruction(expr, primaryBindable.name)];\n          } else {\n            // custom attribute with binding command:\n            // my-attr.bind=\"...\"\n            // my-attr.two-way=\"...\"\n\n            commandBuildInfo.node = el;\n            commandBuildInfo.attr = attrSyntax;\n            commandBuildInfo.bindable = primaryBindable;\n            commandBuildInfo.def = attrDef;\n            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];\n          }\n        }\n\n        removeAttr();\n\n        if (attrDef.isTemplateController) {\n          (tcInstructions ??= []).push(new HydrateTemplateController(\n            voidDefinition,\n            // todo: def/ def.Type or def.name should be configurable\n            //       example: AOT/runtime can use def.Type, but there are situation\n            //       where instructions need to be serialized, def.name should be used\n            this.resolveResources ? attrDef : attrDef.name,\n            void 0,\n            attrBindableInstructions,\n          ));\n        } else {\n          (attrInstructions ??= []).push(new HydrateAttributeInstruction(\n            // todo: def/ def.Type or def.name should be configurable\n            //       example: AOT/runtime can use def.Type, but there are situation\n            //       where instructions need to be serialized, def.name should be used\n            this.resolveResources ? attrDef : attrDef.name,\n            attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,\n            attrBindableInstructions\n          ));\n        }\n        continue;\n      }\n\n      // reaching here means:\n      // + it's a plain attribute\n      // + there may or may not be a binding command, but it won't be an overriding command\n\n      if (bindingCommand === null) {\n        // reaching here means:\n        // + maybe a plain attribute with interpolation\n        // + maybe a plain attribute\n        expr = exprParser.parse(realAttrValue, etInterpolation);\n        if (expr != null) {\n          // if it's an interpolation, remove the attribute\n          removeAttr();\n\n          (plainAttrInstructions ??= []).push(new InterpolationInstruction(\n            expr,\n            // if not a bindable, then ensure plain attribute are mapped correctly:\n            // e.g: colspan -> colSpan\n            //      innerhtml -> innerHTML\n            //      minlength -> minLength etc...\n            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)\n          ));\n        }\n        continue;\n      }\n\n      // reaching here means:\n      // + has binding command\n      // + not an overriding binding command\n      // + not a custom attribute\n      // + not a custom element bindable\n\n      commandBuildInfo.node = el;\n      commandBuildInfo.attr = attrSyntax;\n      commandBuildInfo.bindable = null;\n      commandBuildInfo.def = null;\n      (plainAttrInstructions ??= []).push(bindingCommand.build(\n        commandBuildInfo,\n        context._exprParser,\n        context._attrMapper\n      ));\n      removeAttr();\n    }\n\n    resetCommandBuildInfo();\n\n    if (this._shouldReorderAttrs(el, plainAttrInstructions) && plainAttrInstructions != null && plainAttrInstructions.length > 1) {\n      this._reorder(el, plainAttrInstructions);\n    }\n\n    // 2. ensure that element instruction is present if this element is a custom element\n    if (isCustomElement) {\n      elementInstruction = new HydrateElementInstruction(\n        // todo: def/ def.Type or def.name should be configurable\n        //       example: AOT/runtime can use def.Type, but there are situation\n        //       where instructions need to be serialized, def.name should be used\n        this.resolveResources ? elDef : elDef.name,\n        (elBindableInstructions ?? emptyArray) as IInstruction[],\n        null,\n        hasContainerless,\n        captures,\n        elementMetadata!,\n      );\n    }\n\n    // 3. merge and sort all instructions into a single list\n    //    as instruction list for this element\n    if (plainAttrInstructions != null\n      || elementInstruction != null\n      || attrInstructions != null\n    ) {\n      instructions = emptyArray.concat(\n        elementInstruction ?? emptyArray,\n        attrInstructions ?? emptyArray,\n        plainAttrInstructions ?? emptyArray,\n      );\n      // 3.1 mark as template for later hydration\n      // this._markAsTarget(el, context);\n      needsMarker = true;\n    }\n\n    // 4. compiling child nodes\n    let shouldCompileContent: boolean;\n    if (tcInstructions != null) {\n      // 4.1 if there is 1 or more [Template controller]\n      ii = tcInstructions.length - 1;\n      i = ii;\n      tcInstruction = tcInstructions[i];\n\n      let template: HTMLTemplateElement;\n      if (isMarker(el)) {\n        template = context.t();\n        appendManyToTemplate(template, [\n          // context.h(MARKER_NODE_NAME),\n          context._marker(),\n          context._comment(auLocationStart),\n          context._comment(auLocationEnd),\n        ]);\n      } else {\n        // assumption: el.parentNode is not null\n        // but not always the case: e.g compile/enhance an element without parent with TC on it\n        this._replaceByMarker(el, context);\n        if (el.nodeName === 'TEMPLATE') {\n          template = el as HTMLTemplateElement;\n        } else {\n          template = context.t();\n          appendToTemplate(template, el);\n        }\n\n      }\n      const mostInnerTemplate = template;\n      // 4.1.1.0. prepare child context for the inner template compilation\n      const childContext = context._createChild(instructions == null ? [] : [instructions]);\n\n      let childEl: Element;\n      let targetSlot: string | null;\n      let hasAuSlot = false;\n      let projections: Record<string, IElementComponentDefinition> | undefined;\n      let slotTemplateRecord: Record<string, (Node | Element | DocumentFragment)[]> | undefined;\n      let slotTemplates: (Node | Element | DocumentFragment)[];\n      let slotTemplate: Node | Element | DocumentFragment;\n      let marker: Comment;\n      let projectionCompilationContext: CompilationContext;\n      let j = 0, jj = 0;\n      // 4.1.1.1.\n      //  walks through the child nodes, and perform [au-slot] check\n      //  note: this is a bit different with the summary above, possibly wrong since it will not throw\n      //        on [au-slot] used on a non-custom-element + with a template controller on it\n      // for each child element of a custom element\n      // scan for [au-slot], if there's one\n      // then extract the element into a projection definition\n      // this allows support for [au-slot] declared on the same element with anther template controller\n      // e.g:\n      //\n      // can do:\n      //  <my-el>\n      //    <div au-slot if.bind=\"...\"></div>\n      //    <div if.bind=\"...\" au-slot></div>\n      //  </my-el>\n      //\n      // instead of:\n      //  <my-el>\n      //    <template au-slot><div if.bind=\"...\"></div>\n      //  </my-el>\n      let child: Node | null = el.firstChild;\n      let isEmptyTextNode = false;\n      if (processContentResult !== false) {\n        while (child !== null) {\n          targetSlot = isElement(child) ? child.getAttribute(auslotAttr) : null;\n          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;\n          childEl = child.nextSibling as Element;\n          if (hasAuSlot) {\n            if (!isCustomElement) {\n              throw createMappedError(ErrorNames.compiler_au_slot_on_non_element, targetSlot, elName);\n            }\n            (child as Element).removeAttribute?.(auslotAttr);\n            // ignore all whitespace\n            isEmptyTextNode = isTextNode(child) && child.textContent!.trim() === '';\n            if (!isEmptyTextNode) {\n              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName] ??= []).push(child);\n            }\n            el.removeChild(child);\n          }\n          child = childEl;\n        }\n      }\n\n      if (slotTemplateRecord != null) {\n        projections = {};\n        // aggregate all content targeting the same slot\n        // into a single template\n        // with some special rule around <template> element\n        for (targetSlot in slotTemplateRecord) {\n          template = context.t();\n          slotTemplates = slotTemplateRecord[targetSlot];\n          for (j = 0, jj = slotTemplates.length; jj > j; ++j) {\n            slotTemplate = slotTemplates[j];\n            if (slotTemplate.nodeName === 'TEMPLATE') {\n              // this means user has some thing more than [au-slot] on a template\n              // consider this intentional, and use it as is\n              // e.g:\n              // case 1\n              // <my-element>\n              //   <template au-slot repeat.for=\"i of items\">\n              // ----vs----\n              // case 2\n              // <my-element>\n              //   <template au-slot>this is just some static stuff <b>And a b</b></template>\n              if ((slotTemplate as Element).attributes.length > 0) {\n                // case 1\n                appendToTemplate(template, slotTemplate);\n              } else {\n                // case 2\n                appendToTemplate(template, (slotTemplate as HTMLTemplateElement).content);\n              }\n            } else {\n              appendToTemplate(template, slotTemplate);\n            }\n          }\n\n          // after aggregating all the [au-slot] templates into a single one\n          // compile it\n          // technically, the most inner template controller compilation context\n          // is the parent of this compilation context\n          // but for simplicity in compilation, maybe start with a flatter hierarchy\n          // also, it wouldn't have any real uses\n          projectionCompilationContext = context._createChild();\n          this._compileNode(template.content, projectionCompilationContext);\n          projections[targetSlot] = {\n            name: generateElementName(),\n            type: definitionTypeElement,\n            template,\n            instructions: projectionCompilationContext.rows,\n            needsCompile: false,\n          };\n        }\n        elementInstruction!.projections = projections;\n      }\n\n      if (needsMarker) {\n        if (isCustomElement && (hasContainerless || elDef.containerless)) {\n          this._replaceByMarker(el, context);\n        } else {\n          this._markAsTarget(el, context);\n        }\n      }\n\n      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;\n      if (shouldCompileContent) {\n        // 4.1.1.2:\n        //  recursively compiles the child nodes into the inner context\n        // important:\n        // ======================\n        // only goes inside a template, if there is a template controller on it\n        // otherwise, leave it alone\n        if (el.nodeName === TEMPLATE_NODE_NAME) {\n          this._compileNode((el as HTMLTemplateElement).content, childContext);\n        } else {\n          child = el.firstChild;\n          while (child !== null) {\n            child = this._compileNode(child, childContext);\n          }\n        }\n      }\n      tcInstruction.def = {\n        name: generateElementName(),\n        type: definitionTypeElement,\n        template: mostInnerTemplate,\n        instructions: childContext.rows,\n        needsCompile: false,\n      };\n\n      // 4.1.2.\n      //  Start processing other Template controllers by walking the TC list (list 1) RIGHT -> LEFT\n      while (i-- > 0) {\n        // for each of the template controller from [right] to [left]\n        // do create:\n        // (1) a template\n        // (2) add a marker to the template\n        // (3) an instruction\n        // instruction will be corresponded to the marker\n        // =========================\n\n        tcInstruction = tcInstructions[i];\n        template = context.t();\n        // appending most inner template is inaccurate, as the most outer one\n        // is not really the parent of the most inner one\n        // but it's only for the purpose of creating a marker,\n        // so it's just an optimization hack\n        // marker = this._markAsTarget(context.h(MARKER_NODE_NAME));\n        // marker = context.h(MARKER_NODE_NAME);\n        marker = context._marker();\n        appendManyToTemplate(template, [\n          marker,\n          context._comment(auLocationStart),\n          context._comment(auLocationEnd),\n        ]);\n\n        tcInstruction.def = {\n          name: generateElementName(),\n          type: definitionTypeElement,\n          template,\n          needsCompile: false,\n          instructions: [[tcInstructions[i + 1]]],\n        };\n      }\n      // the most outer template controller should be\n      // the only instruction for peek instruction of the current context\n      // e.g\n      // <div if.bind=\"yes\" with.bind=\"scope\" repeat.for=\"i of items\" data-id=\"i.id\">\n      // results in:\n      // -----------\n      //\n      //  TC(if-[value=yes])\n      //    | TC(with-[value=scope])\n      //        | TC(repeat-[...])\n      //            | div(data-id-[value=i.id])\n      context.rows.push([tcInstruction]);\n    } else {\n      // 4.2\n      //\n      // if there's no template controller\n      // then the instruction built is appropriate to be assigned as the peek row\n      // and before the children compilation\n      if (instructions != null) {\n        context.rows.push(instructions);\n      }\n\n      let child = el.firstChild as Node | null;\n      let childEl: Element;\n      let targetSlot: string | null;\n      let hasAuSlot: boolean = false;\n      let projections: Record<string, IElementComponentDefinition> | null = null;\n      let slotTemplateRecord: Record<string, (Node | Element | DocumentFragment)[]> | undefined;\n      let slotTemplates: (Node | Element | DocumentFragment)[];\n      let slotTemplate: Node | Element | DocumentFragment;\n      let template: HTMLTemplateElement;\n      let projectionCompilationContext: CompilationContext;\n      let isEmptyTextNode = false;\n      let j = 0, jj = 0;\n      // 4.2.1.\n      //    walks through the child nodes and perform [au-slot] check\n      // --------------------\n      // for each child element of a custom element\n      // scan for [au-slot], if there's one\n      // then extract the element into a projection definition\n      // this allows support for [au-slot] declared on the same element with anther template controller\n      // e.g:\n      //\n      // can do:\n      //  <my-el>\n      //    <div au-slot if.bind=\"...\"></div>\n      //    <div if.bind=\"...\" au-slot></div>\n      //  </my-el>\n      //\n      // instead of:\n      //  <my-el>\n      //    <template au-slot><div if.bind=\"...\"></div>\n      //  </my-el>\n      if (processContentResult !== false) {\n        while (child !== null) {\n          targetSlot = isElement(child) ? child.getAttribute(auslotAttr) : null;\n          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;\n          childEl = child.nextSibling as Element;\n          if (hasAuSlot) {\n            if (!isCustomElement) {\n              throw createMappedError(ErrorNames.compiler_au_slot_on_non_element, targetSlot, elName);\n            }\n            (child as Element).removeAttribute?.(auslotAttr);\n            // ignore all whitespace\n            isEmptyTextNode = isTextNode(child) && child.textContent!.trim() === '';\n            if (!isEmptyTextNode) {\n              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName] ??= []).push(child);\n            }\n            el.removeChild(child);\n          }\n          child = childEl;\n        }\n      }\n\n      if (slotTemplateRecord != null) {\n        projections = {};\n        // aggregate all content targeting the same slot\n        // into a single template\n        // with some special rule around <template> element\n        for (targetSlot in slotTemplateRecord) {\n          template = context.t();\n          slotTemplates = slotTemplateRecord[targetSlot];\n          for (j = 0, jj = slotTemplates.length; jj > j; ++j) {\n            slotTemplate = slotTemplates[j];\n            if (slotTemplate.nodeName === TEMPLATE_NODE_NAME) {\n              // this means user has some thing more than [au-slot] on a template\n              // consider this intentional, and use it as is\n              // e.g:\n              // case 1\n              // <my-element>\n              //   <template au-slot repeat.for=\"i of items\">\n              // ----vs----\n              // case 2\n              // <my-element>\n              //   <template au-slot>this is just some static stuff <b>And a b</b></template>\n\n              if ((slotTemplate as Element).attributes.length > 0) {\n                // case 1\n                appendToTemplate(template, slotTemplate);\n              } else {\n                // case 2\n                appendToTemplate(template, (slotTemplate as HTMLTemplateElement).content);\n              }\n            } else {\n              appendToTemplate(template, slotTemplate);\n            }\n          }\n\n          // after aggregating all the [au-slot] templates into a single one\n          // compile it\n          projectionCompilationContext = context._createChild();\n          this._compileNode(template.content, projectionCompilationContext);\n          projections[targetSlot] = {\n            name: generateElementName(),\n            type: definitionTypeElement,\n            template,\n            instructions: projectionCompilationContext.rows,\n            needsCompile: false,\n          };\n        }\n        elementInstruction!.projections = projections;\n      }\n\n      if (needsMarker) {\n        if (isCustomElement && (hasContainerless || elDef.containerless)) {\n          this._replaceByMarker(el, context);\n        } else {\n          this._markAsTarget(el, context);\n        }\n      }\n\n      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;\n      if (shouldCompileContent && el.childNodes.length > 0) {\n        // 4.2.2\n        //    recursively compiles the child nodes into current context\n        child = el.firstChild;\n        while (child !== null) {\n          child = this._compileNode(child, context);\n        }\n      }\n    }\n\n    // 5. returns the next node to be compiled\n    return nextSibling;\n  }\n\n  /** @internal */\n  private _compileText(node: Text, context: CompilationContext): Node | null {\n    const parent = node.parentNode!;\n    const expr = context._exprParser.parse(node.textContent!, etInterpolation);\n    const next = node.nextSibling;\n    let parts: readonly string[];\n    let expressions: readonly IsBindingBehavior[];\n    let i: number;\n    let ii: number;\n    let part: string;\n    if (expr !== null) {\n      ({ parts, expressions } = expr);\n\n      // foreach normal part, turn into a standard text node\n      if ((part = parts[0])) {\n        insertBefore(parent, context._text(part), node);\n      }\n      for (i = 0, ii = expressions.length; ii > i; ++i) {\n        // foreach expression part, turn into a marker\n        insertManyBefore(parent, node, [\n          // context.h(MARKER_NODE_NAME),\n          context._marker(),\n          // empty text node will not be cloned when doing fragment.cloneNode()\n          // so give it an empty space instead\n          context._text(' '),\n        ]);\n        // foreach normal part, turn into a standard text node\n        if ((part = parts[i + 1])) {\n          insertBefore(parent, context._text(part), node);\n        }\n        // and the corresponding instruction\n        context.rows.push([new TextBindingInstruction(expressions[i])]);\n      }\n      parent.removeChild(node);\n    }\n    return next;\n  }\n\n  /** @internal */\n  private _compileMultiBindings(\n    node: Element,\n    attrRawValue: string,\n    attrDef: IAttributeComponentDefinition,\n    context: CompilationContext\n  ): IInstruction[] {\n    // custom attribute + multiple values:\n    // my-attr=\"prop1: literal1 prop2.bind: ...; prop3: literal3\"\n    // my-attr=\"prop1.bind: ...; prop2.bind: ...\"\n    // my-attr=\"prop1: ${}; prop2.bind: ...; prop3: ${}\"\n    const bindableAttrsInfo = context._getBindables(attrDef);\n    const valueLength = attrRawValue.length;\n    const instructions: IInstruction[] = [];\n\n    let attrName: string | undefined = void 0;\n    let attrValue: string | undefined = void 0;\n\n    let start = 0;\n    let ch = 0;\n    let expr: AnyBindingExpression;\n    let attrSyntax: AttrSyntax;\n    let command: BindingCommandInstance | null;\n    let bindable: IComponentBindablePropDefinition;\n\n    for (let i = 0; i < valueLength; ++i) {\n      ch = attrRawValue.charCodeAt(i);\n\n      if (ch === Char.Backslash) {\n        ++i;\n        // Ignore whatever comes next because it's escaped\n      } else if (ch === Char.Colon) {\n        attrName = attrRawValue.slice(start, i);\n\n        // Skip whitespace after colon\n        while (attrRawValue.charCodeAt(++i) <= Char.Space);\n\n        start = i;\n\n        for (; i < valueLength; ++i) {\n          ch = attrRawValue.charCodeAt(i);\n          if (ch === Char.Backslash) {\n            ++i;\n            // Ignore whatever comes next because it's escaped\n          } else if (ch === Char.Semicolon) {\n            attrValue = attrRawValue.slice(start, i);\n            break;\n          }\n        }\n\n        if (attrValue === void 0) {\n          // No semicolon found, so just grab the rest of the value\n          attrValue = attrRawValue.slice(start);\n        }\n\n        attrSyntax = context._attrParser.parse(attrName, attrValue);\n        // ================================================\n        // todo: should it always camel case???\n        // const attrTarget = camelCase(attrSyntax.target);\n        // ================================================\n        command = context._getCommand(attrSyntax);\n        bindable = bindableAttrsInfo.attrs[attrSyntax.target];\n        if (bindable == null) {\n          throw createMappedError(ErrorNames.compiler_binding_to_non_bindable, attrSyntax.target, attrDef.name);\n        }\n        if (command === null) {\n          expr = context._exprParser.parse(attrValue, etInterpolation);\n          instructions.push(expr === null\n            ? new SetPropertyInstruction(attrValue, bindable.name)\n            : new InterpolationInstruction(expr, bindable.name)\n          );\n        } else {\n          commandBuildInfo.node = node;\n          commandBuildInfo.attr = attrSyntax;\n          commandBuildInfo.bindable = bindable;\n          commandBuildInfo.def = attrDef;\n          instructions.push(command.build(commandBuildInfo, context._exprParser, context._attrMapper));\n        }\n\n        // Skip whitespace after semicolon\n        while (i < valueLength && attrRawValue.charCodeAt(++i) <= Char.Space);\n\n        start = i;\n\n        attrName = void 0;\n        attrValue = void 0;\n      }\n    }\n\n    resetCommandBuildInfo();\n\n    return instructions;\n  }\n\n  /** @internal */\n  private _compileLocalElement(template: Element | DocumentFragment, context: CompilationContext) {\n    const elName = context.root.def.name;\n    const root: Element | DocumentFragment = template;\n    const localTemplates = toArray(root.querySelectorAll<HTMLTemplateElement>('template[as-custom-element]'));\n    const numLocalTemplates = localTemplates.length;\n    if (numLocalTemplates === 0) { return; }\n    if (numLocalTemplates === root.childElementCount) {\n      throw createMappedError(ErrorNames.compiler_template_only_local_template, elName);\n    }\n    const localTemplateNames: Set<string> = new Set();\n    const localElementTypes: (Constructable & { dependencies?: Key[] })[] = [];\n\n    for (const localTemplate of localTemplates) {\n      if (localTemplate.parentNode !== root) {\n        throw createMappedError(ErrorNames.compiler_local_el_not_under_root, elName);\n      }\n\n      const name = processTemplateName(elName, localTemplate, localTemplateNames);\n\n      const content = localTemplate.content;\n      const bindableEls = toArray(content.querySelectorAll('bindable'));\n      const properties = new Set<string>();\n      const attributes = new Set<string>();\n      const bindables = bindableEls.reduce((allBindables: Record<string, IComponentBindablePropDefinition>, bindableEl) => {\n        if (bindableEl.parentNode !== content) {\n          throw createMappedError(ErrorNames.compiler_local_el_bindable_not_under_root, name);\n        }\n        const property = bindableEl.getAttribute(LocalTemplateBindableAttributes.name);\n        if (property === null) {\n          throw createMappedError(ErrorNames.compiler_local_el_bindable_name_missing, bindableEl, name);\n        }\n        const attribute = bindableEl.getAttribute(LocalTemplateBindableAttributes.attribute);\n        if (attribute !== null\n          && attributes.has(attribute)\n          || properties.has(property)\n        ) {\n          throw createMappedError(ErrorNames.compiler_local_el_bindable_duplicate, properties, attribute);\n        } else {\n          if (attribute !== null) {\n            attributes.add(attribute);\n          }\n          properties.add(property);\n        }\n        const ignoredAttributes = toArray(bindableEl.attributes).filter((attr) => !allowedLocalTemplateBindableAttributes.includes(attr.name));\n        if (ignoredAttributes.length > 0) {\n          if (__DEV__)\n            // eslint-disable-next-line no-console\n            console.warn(`[DEV:aurelia] The attribute(s) ${ignoredAttributes.map(attr => attr.name).join(', ')} will be ignored for ${bindableEl.outerHTML}. Only ${allowedLocalTemplateBindableAttributes.join(', ')} are processed.`);\n        }\n\n        bindableEl.remove();\n\n        allBindables[property] = {\n          name: property,\n          attribute: attribute ?? void 0,\n          mode: bindableEl.getAttribute(LocalTemplateBindableAttributes.mode) as StringBindingMode ?? 'default'\n        };\n\n        return allBindables;\n      }, {});\n\n      class LocalDepType {\n        public static $au: IElementComponentDefinition & { dependencies?: Key[] } = {\n          type: definitionTypeElement,\n          name,\n          template: localTemplate,\n          bindables,\n        };\n      }\n      Reflect.defineProperty(LocalDepType, 'name', { value: pascalCase(name) });\n      localElementTypes.push(LocalDepType);\n\n      root.removeChild(localTemplate);\n    }\n\n    // if we have a template like this\n    //\n    // my-app.html\n    // <template as-custom-element=\"le-1\">\n    //  <le-2></le-2>\n    // </template>\n    // <template as-custom-element=\"le-2\">...</template>\n    //\n    // without registering dependencies properly, <le-1> will not see <le-2> as a custom element\n    const compilationDeps = (context.root.def.dependencies ?? []).concat(context.root.def.Type == null ? emptyArray : [context.root.def.Type]);\n    for (const localElementType of localElementTypes) {\n      localElementType.dependencies = compilationDeps.concat(localElementTypes.filter(d => d !== localElementType));\n      context._addLocalDep(localElementType);\n    }\n\n  }\n\n  /** @internal */\n  private _shouldReorderAttrs(el: Element, instructions?: IInstruction[]): boolean | undefined {\n    const nodeName = el.nodeName;\n    return nodeName === 'INPUT' && orderSensitiveInputType[(el as HTMLInputElement).type] === 1\n      || nodeName === 'SELECT' && (\n        (el as HTMLSelectElement).hasAttribute('multiple')\n        || instructions?.some(i => i.type === propertyBinding && (i as PropertyBindingInstruction | InterpolationInstruction).to === 'multiple')\n      );\n  }\n\n  /** @internal */\n  private _reorder(el: Element, instructions: (IInstruction)[]) {\n    switch (el.nodeName) {\n      case 'INPUT': {\n        const _instructions = instructions as (PropertyBindingInstruction | InterpolationInstruction)[];\n        // swap the order of checked and model/value attribute,\n        // so that the required observers are prepared for checked-observer\n        let modelOrValueOrMatcherIndex: number | undefined = void 0;\n        let checkedIndex: number | undefined = void 0;\n        let found = 0;\n        let instruction: PropertyBindingInstruction | InterpolationInstruction;\n        for (let i = 0; i < _instructions.length && found < 3; i++) {\n          instruction = _instructions[i];\n          switch (instruction.to) {\n            case 'model':\n            case 'value':\n            case 'matcher':\n              modelOrValueOrMatcherIndex = i;\n              found++;\n              break;\n            case 'checked':\n              checkedIndex = i;\n              found++;\n              break;\n          }\n        }\n        if (checkedIndex !== void 0 && modelOrValueOrMatcherIndex !== void 0 && checkedIndex < modelOrValueOrMatcherIndex) {\n          [_instructions[modelOrValueOrMatcherIndex], _instructions[checkedIndex]] = [_instructions[checkedIndex], _instructions[modelOrValueOrMatcherIndex]];\n        }\n        break;\n      }\n      case 'SELECT': {\n        const _instructions = instructions as (PropertyBindingInstruction | InterpolationInstruction)[];\n        let valueIndex = 0;\n        let multipleIndex = 0;\n        // a variable to stop the loop as soon as we find both value & multiple binding indices\n        let found = 0;\n        let instruction: PropertyBindingInstruction | InterpolationInstruction;\n        // swap the order of multiple and value bindings\n        for (let i = 0; i < _instructions.length && found < 2; ++i) {\n          instruction = _instructions[i];\n          switch (instruction.to) {\n            case 'multiple':\n              multipleIndex = i;\n              found++;\n              break;\n            case 'value':\n              valueIndex = i;\n              found++;\n              break;\n          }\n          if (found === 2 && valueIndex < multipleIndex) {\n            [_instructions[multipleIndex], _instructions[valueIndex]] = [_instructions[valueIndex], _instructions[multipleIndex]];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Mark an element as target with a special css class\n   * and return it\n   *\n   * @internal\n   */\n  private _markAsTarget<T extends Element>(el: T, context: CompilationContext): T {\n    insertBefore(el.parentNode!, context._comment('au*'), el);\n    // el.classList.add('au');\n    return el;\n  }\n\n  /**\n   * Replace an element with a marker, and return the marker\n   *\n   * @internal\n   */\n  private _replaceByMarker(node: Node, context: CompilationContext): Comment {\n    if (isMarker(node)) {\n      return node;\n    }\n    // todo: assumption made: parentNode won't be null\n    const parent = node.parentNode!;\n    // const marker = this._markAsTarget(context.h(MARKER_NODE_NAME));\n    const marker = context._marker();\n    // insertBefore(parent, marker, node);\n    insertManyBefore(parent, node, [\n      marker,\n      context._comment(auLocationStart),\n      context._comment(auLocationEnd),\n    ]);\n    parent.removeChild(node);\n    return marker;\n  }\n}\n\nconst TEMPLATE_NODE_NAME = 'TEMPLATE';\nconst isMarker = (el: Node): el is Comment =>\n  el.nodeValue === 'au*';\n    // && isComment(nextSibling = el.nextSibling) && nextSibling.textContent === auStartComment\n    // && isComment(nextSibling = el.nextSibling) && nextSibling.textContent === auEndComment;\n// const isComment = (el: Node | null): el is Comment => el?.nodeType === 8;\n\n// this class is intended to be an implementation encapsulating the information at the root level of a template\n// this works at the time this is created because everything inside a template should be retrieved\n// from the root itself.\n// if anytime in the future, where it's desirable to retrieve information from somewhere other than root\n// then consider dropping this\n// goal: hide the root container, and all the resources finding calls\nclass CompilationContext {\n  public readonly root: CompilationContext;\n  public readonly parent: CompilationContext | null;\n  public readonly def: IElementComponentDefinition;\n  public readonly _resourceResolver: IResourceResolver;\n  public readonly _commandResolver: IBindingCommandResolver;\n  public readonly _templateFactory: ITemplateElementFactory;\n  public readonly _logger: ILogger;\n  public readonly _attrParser: IAttributeParser;\n  public readonly _attrMapper: IAttrMapper;\n  public readonly _exprParser: IExpressionParser;\n  public readonly p: IDomPlatform;\n  // an array representing targets of instructions, built on depth first tree walking compilation\n  public readonly rows: IInstruction[][];\n  public readonly localEls: Set<string>;\n  public hasSlot: boolean = false;\n  public deps: Constructable[] | null = null;\n\n  /** @internal */\n  private readonly c: IContainer;\n\n  public constructor(\n    def: IElementComponentDefinition,\n    container: IContainer,\n    parent: CompilationContext | null,\n    root: CompilationContext | null,\n    instructions: IInstruction[][] | undefined,\n  ) {\n    const hasParent = parent !== null;\n    this.c = container;\n    this.root = root === null ? this : root;\n    this.def = def;\n    this.parent = parent;\n    this._resourceResolver = hasParent ? parent._resourceResolver : container.get(IResourceResolver);\n    this._commandResolver = hasParent ? parent._commandResolver : container.get(IBindingCommandResolver);\n    this._templateFactory = hasParent ? parent._templateFactory : container.get(ITemplateElementFactory);\n    // todo: attr parser should be retrieved based in resource semantic (current leaf + root + ignore parent)\n    this._attrParser = hasParent ? parent._attrParser : container.get(IAttributeParser);\n    this._exprParser = hasParent ? parent._exprParser : container.get(IExpressionParser);\n    this._attrMapper = hasParent ? parent._attrMapper : container.get(IAttrMapper);\n    this._logger = hasParent ? parent._logger : container.get(ILogger);\n    if (typeof (this.p = hasParent ? parent.p : container.get(IPlatform) as unknown as IDomPlatform).document?.nodeType !== 'number') {\n      throw createMappedError(ErrorNames.compiler_no_dom_api);\n    }\n    this.localEls = hasParent ? parent.localEls : new Set();\n    this.rows = instructions ?? [];\n  }\n\n  public _addLocalDep(Type: Constructable) {\n    (this.root.deps ??= []).push(Type);\n    this.root.c.register(Type);\n    return this;\n  }\n\n  public _text(text: string) {\n    return this.p.document.createTextNode(text);\n  }\n\n  public _comment(text: string) {\n    return this.p.document.createComment(text);\n  }\n\n  public _marker() {\n    return this._comment('au*');\n  }\n\n  public h<K extends keyof HTMLElementTagNameMap>(name: K): HTMLElementTagNameMap[K];\n  public h(name: string): HTMLElement;\n  public h(name: string): HTMLElement {\n    const el = this.p.document.createElement(name);\n    if (name === 'template') {\n      this.p.document.adoptNode((el as HTMLTemplateElement).content);\n    }\n    return el;\n  }\n\n  public t() {\n    return this.h('template');\n  }\n\n  /**\n   * Find the custom element definition of a given name\n   */\n  public _findElement(name: string): IElementComponentDefinition | null {\n    return this._resourceResolver.el(this.c, name);\n  }\n\n  /**\n   * Find the custom attribute definition of a given name\n   */\n  public _findAttr(name: string): IAttributeComponentDefinition | null {\n    return this._resourceResolver.attr(this.c, name);\n  }\n\n  public _getBindables(def: IAttributeComponentDefinition): IAttributeBindablesInfo;\n  public _getBindables(def: IElementComponentDefinition): IElementBindablesInfo;\n  public _getBindables(def: IAttributeComponentDefinition | IElementComponentDefinition): IAttributeBindablesInfo | IElementBindablesInfo {\n    return this._resourceResolver.bindables(def);\n  }\n\n  /**\n   * Create a new child compilation context\n   */\n  public _createChild(instructions?: IInstruction[][]) {\n    return new CompilationContext(this.def, this.c, this, this.root, instructions);\n  }\n\n  /**\n   * Retrieve a binding command resource instance.\n   *\n   * @param name - The parsed `AttrSyntax`\n   *\n   * @returns An instance of the command if it exists, or `null` if it does not exist.\n   */\n  public _getCommand(syntax: AttrSyntax): BindingCommandInstance | null {\n    const name = syntax.command;\n    if (name === null) {\n      return null;\n    }\n    return this._commandResolver.get(this.c, name);\n  }\n}\n\nconst hasInlineBindings = (rawValue: string): boolean => {\n  const len = rawValue.length;\n  let ch = 0;\n  let i = 0;\n  while (len > i) {\n    ch = rawValue.charCodeAt(i);\n    if (ch === Char.Backslash) {\n      ++i;\n      // Ignore whatever comes next because it's escaped\n    } else if (ch === Char.Colon) {\n      return true;\n    } else if (ch === Char.Dollar && rawValue.charCodeAt(i + 1) === Char.OpenBrace) {\n      return false;\n    }\n    ++i;\n  }\n  return false;\n};\n\nconst resetCommandBuildInfo = (): void => {\n  commandBuildInfo.node\n    = commandBuildInfo.attr\n    = commandBuildInfo.bindable\n    = commandBuildInfo.def = null!;\n};\n\nconst voidDefinition: IElementComponentDefinition = { name: 'unnamed', type: definitionTypeElement };\nconst commandBuildInfo: Writable<ICommandBuildInfo> = {\n  node: null!,\n  attr: null!,\n  bindable: null,\n  def: null,\n};\nconst invalidSurrogateAttribute: Record<string, boolean> = {\n  'id': true,\n  'name': true,\n  'au-slot': true,\n  'as-element': true,\n};\nconst orderSensitiveInputType: Record<string, number> = {\n  checkbox: 1,\n  radio: 1,\n  // todo: range is also sensitive to order, for min/max\n};\n\nexport interface IAttributeBindablesInfo {\n  readonly attrs: Record<string, IComponentBindablePropDefinition>;\n  readonly bindables: Record<string, IComponentBindablePropDefinition>;\n  readonly primary: IComponentBindablePropDefinition;\n}\n\nexport interface IElementBindablesInfo {\n  readonly attrs: Record<string, IComponentBindablePropDefinition>;\n  readonly bindables: Record<string, IComponentBindablePropDefinition>;\n  readonly primary: null;\n}\n\nexport interface IResourceResolver<\n  TElementDef extends IElementComponentDefinition = IElementComponentDefinition,\n  TAttrDef extends IAttributeComponentDefinition = IAttributeComponentDefinition,\n> {\n  el(c: IContainer, name: string): TElementDef | null;\n  attr(c: IContainer, name: string): TAttrDef | null;\n  bindables(def: TAttrDef): IAttributeBindablesInfo;\n  bindables(def: TElementDef): IElementBindablesInfo;\n  bindables(def: TAttrDef | TElementDef): IAttributeBindablesInfo | IElementBindablesInfo;\n}\n\nexport const IResourceResolver = /*@__PURE__*/ tcCreateInterface<IResourceResolver>('IResourceResolver');\n\nexport interface IBindingCommandResolver {\n  get(c: IContainer, name: string): BindingCommandInstance | null;\n}\nexport const IBindingCommandResolver = /*@__PURE__*/ tcCreateInterface<IBindingCommandResolver>('IBindingCommandResolver', x => {\n  class DefaultBindingCommandResolver implements IBindingCommandResolver {\n    private readonly _cache = new WeakMap<IContainer, Record<string, BindingCommandInstance>>();\n    public get(c: IContainer, name: string): BindingCommandInstance | null {\n      let record = this._cache.get(c);\n      if (!record) {\n        this._cache.set(c, record = {});\n      }\n      return name in record ? record[name] : (record[name] = BindingCommand.get(c, name));\n    }\n  }\n\n  return x.singleton(DefaultBindingCommandResolver);\n});\n\n_START_CONST_ENUM();\nconst enum LocalTemplateBindableAttributes {\n  name = \"name\",\n  attribute = \"attribute\",\n  mode = \"mode\",\n}\n_END_CONST_ENUM();\nconst allowedLocalTemplateBindableAttributes: readonly string[] = tcObjectFreeze([\n  LocalTemplateBindableAttributes.name,\n  LocalTemplateBindableAttributes.attribute,\n  LocalTemplateBindableAttributes.mode\n]);\nconst localTemplateIdentifier = 'as-custom-element';\n\nconst processTemplateName = (owningElementName: string, localTemplate: HTMLTemplateElement, localTemplateNames: Set<string>): string => {\n  const name = localTemplate.getAttribute(localTemplateIdentifier);\n  if (name === null || name === '') {\n    throw createMappedError(ErrorNames.compiler_local_name_empty, owningElementName);\n  }\n  if (localTemplateNames.has(name)) {\n    throw createMappedError(ErrorNames.compiler_duplicate_local_name, name, owningElementName);\n  } else {\n    localTemplateNames.add(name);\n    localTemplate.removeAttribute(localTemplateIdentifier);\n  }\n  return name;\n};\n\n/**\n * An interface describing the hooks a compilation process should invoke.\n *\n * A feature available to the default template compiler.\n */\nexport const ITemplateCompilerHooks = /*@__PURE__*/tcCreateInterface<ITemplateCompilerHooks>('ITemplateCompilerHooks');\nexport interface ITemplateCompilerHooks {\n  /**\n   * Should be invoked immediately before a template gets compiled\n   */\n  compiling?(template: HTMLElement): void;\n}\n\nexport const TemplateCompilerHooks = tcObjectFreeze({\n  name: /*@__PURE__*/getResourceKeyFor('compiler-hooks'),\n  define<K extends ITemplateCompilerHooks, T extends Constructable<K>>(Type: T): IRegistry {\n    return {\n      register(container) {\n        singletonRegistration(ITemplateCompilerHooks, Type).register(container);\n      }\n    };\n  },\n  findAll(container: IContainer): readonly ITemplateCompilerHooks[] {\n    return container.get(allResources(ITemplateCompilerHooks));\n  }\n});\n\n/**\n * Decorator: Indicates that the decorated class is a template compiler hooks.\n *\n * An instance of this class will be created and appropriate compilation hooks will be invoked\n * at different phases of the default compiler.\n */\n/* eslint-disable */\n// deepscan-disable-next-line\nexport const templateCompilerHooks = <T extends Constructable>(target?: T, context?: ClassDecoratorContext) => {\n  return target === void 0 ? decorator : decorator(target, context!);\n  function decorator<T extends Constructable>(t: T, context: ClassDecoratorContext): any {\n    context.metadata[registrableMetadataKey] = TemplateCompilerHooks.define(t);\n    return t;\n  };\n}\n/* eslint-enable */\n\n_START_CONST_ENUM();\nconst enum Char {\n  // Null           = 0x00,\n  // Backspace      = 0x08,\n  // Tab            = 0x09,\n  // LineFeed       = 0x0A,\n  // VerticalTab    = 0x0B,\n  // FormFeed       = 0x0C,\n  // CarriageReturn = 0x0D,\n  Space          = 0x20,\n  // Exclamation    = 0x21,\n  // DoubleQuote    = 0x22,\n  Dollar         = 0x24,\n  // Percent        = 0x25,\n  // Ampersand      = 0x26,\n  // SingleQuote    = 0x27,\n  // OpenParen      = 0x28,\n  // CloseParen     = 0x29,\n  // Asterisk       = 0x2A,\n  // Plus           = 0x2B,\n  // Comma          = 0x2C,\n  // Minus          = 0x2D,\n  // Dot            = 0x2E,\n  // Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  // Backtick       = 0x60,\n  // OpenBracket    = 0x5B,\n  Backslash      = 0x5C,\n  // CloseBracket   = 0x5D,\n  // Caret          = 0x5E,\n  // Underscore     = 0x5F,\n  OpenBrace      = 0x7B,\n  // Bar            = 0x7C,\n  // CloseBrace     = 0x7D,\n  Colon          = 0x3A,\n  // LessThan       = 0x3C,\n  // Equals         = 0x3D,\n  // GreaterThan    = 0x3E,\n  // Question       = 0x3F,\n}\n_END_CONST_ENUM();\n\n// eslint-disable-next-line\nfunction apiTest() {\n\n  @templateCompilerHooks()\n  @templateCompilerHooks\n  class Abc {}\n\n  return Abc;\n}\n", "import { Metadata } from '@aurelia/metadata';\nimport { DI } from '@aurelia/kernel';\n\n/**\n * A shortcut to Object.prototype.hasOwnProperty\n * Needs to do explicit .call\n *\n * @internal\n */\nexport const hasOwnProp = Object.prototype.hasOwnProperty;\n\n/**\n * Reflect does not throw on invalid property def\n *\n * @internal\n */\nexport const rtDef = Reflect.defineProperty;\n\n/** @internal */\nexport function rtDefineHiddenProp<T>(obj: object, key: PropertyKey, value: T): T {\n  rtDef(obj, key, {\n    configurable: true,\n    writable: true,\n    value\n  });\n  return value;\n}\n\n/** @internal */\nexport function ensureProto<T extends object, K extends keyof T>(\n  proto: T,\n  key: K,\n  defaultValue: unknown\n): void {\n  if (!(key in proto)) {\n    rtDefineHiddenProp(proto, key, defaultValue);\n  }\n}\n\n/** @internal */ export const rtObjectAssign = Object.assign;\n/** @internal */ export const rtObjectFreeze = Object.freeze;\n// this is used inside template literal, since TS errs without String(...value)\n/** @internal */ export const rtSafeString = String;\n/** @internal */ export const rtCreateInterface = DI.createInterface;\n\n/** @internal */ export const rtGetMetadata = Metadata.get;\n/** @internal */ export const rtDefineMetadata = Metadata.define;\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n\nimport { rtSafeString } from './utilities';\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${rtSafeString(code).padStart(4, '0')}: ${getMessageByCode(code, ...details)}`)\n  : (code: ErrorNames, ...details: unknown[]) => new Error(`AUR${rtSafeString(code).padStart(4, '0')}:${details.map(rtSafeString)}`);\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  method_not_implemented = 99,\n\n  ast_behavior_not_found = 101,\n  ast_behavior_duplicated = 102,\n  ast_converter_not_found = 103,\n  ast_$host_not_found = 105,\n  ast_no_assign_$host = 106,\n  ast_not_a_function = 107,\n  ast_unknown_binary_operator = 108,\n  ast_unknown_unary_operator = 109,\n  ast_tagged_not_a_function = 110,\n  ast_name_is_not_a_function = 111,\n  ast_destruct_null = 112,\n  ast_increment_infinite_loop = 113,\n  ast_nullish_member_access = 114,\n  ast_nullish_keyed_access = 115,\n  ast_nullish_assignment = 116,\n\n  null_scope = 203,\n  create_scope_with_null_context = 204,\n  switch_on_null_connectable = 206,\n  switch_active_connectable = 207,\n  switch_off_null_connectable = 208,\n  switch_off_inactive_connectable = 209,\n  non_recognisable_collection_type = 210,\n  dirty_check_no_handler = 217,\n  dirty_check_not_allowed = 218,\n  dirty_check_setter_not_allowed = 219,\n  assign_readonly_size = 220,\n  assign_readonly_readonly_property_from_computed = 221,\n  invalid_observable_decorator_usage = 224,\n  stopping_a_stopped_effect = 225,\n  effect_maximum_recursion_reached = 226,\n\n  parse_invalid_start = 151,\n  parse_no_spread = 152,\n  parse_expected_identifier = 153,\n  parse_invalid_member_expr = 154,\n  parse_unexpected_end = 155,\n  parse_unconsumed_token = 156,\n  parse_invalid_empty = 157,\n  parse_left_hand_side_not_assignable = 158,\n  parse_expected_converter_identifier = 159,\n  parse_expected_behavior_identifier = 160,\n  parse_unexpected_keyword_of = 161,\n  parse_unexpected_keyword_import = 162,\n  parse_invalid_identifier_in_forof = 163,\n  parse_invalid_identifier_object_literal_key = 164,\n  parse_unterminated_string = 165,\n  parse_unterminated_template_string = 166,\n  parse_missing_expected_token = 167,\n  parse_unexpected_character = 168,\n  parse_unexpected_token_destructuring = 170,\n  parse_unexpected_token_optional_chain = 171,\n  parse_invalid_tag_in_optional_chain = 172,\n  parse_invalid_arrow_params = 173,\n  parse_no_arrow_param_default_value = 174,\n  parse_no_arrow_param_destructuring = 175,\n  parse_rest_must_be_last = 176,\n  parse_no_arrow_fn_body = 178,\n  parse_unexpected_double_dot = 179,\n  observing_null_undefined = 199,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string> = {\n  [ErrorNames.method_not_implemented]: 'Method {{0}} not implemented',\n\n  [ErrorNames.ast_behavior_not_found]: `Ast eval error: binding behavior \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_behavior_duplicated]: `Ast eval error: binding behavior \"{{0}}\" already applied.`,\n  [ErrorNames.ast_converter_not_found]: `Ast eval error: value converter \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_$host_not_found]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,\n  [ErrorNames.ast_no_assign_$host]: `Ast eval error: invalid assignment. \"$host\" is a reserved keyword.`,\n  [ErrorNames.ast_not_a_function]: `Ast eval error: expression is not a function.`,\n  [ErrorNames.ast_unknown_unary_operator]: `Ast eval error: unknown unary operator: \"{{0}}\"`,\n  [ErrorNames.ast_unknown_binary_operator]: `Ast eval error: unknown binary operator: \"{{0}}\"`,\n  [ErrorNames.ast_tagged_not_a_function]: `Ast eval error: left-hand side of tagged template expression is not a function.`,\n  [ErrorNames.ast_name_is_not_a_function]: `Ast eval error: expected \"{{0}}\" to be a function`,\n  [ErrorNames.ast_destruct_null]: `Ast eval error: cannot use non-object value for destructuring assignment.`,\n  [ErrorNames.ast_increment_infinite_loop]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,\n  [ErrorNames.ast_nullish_member_access]: `Ast eval error: cannot access property \"{{0}}\" of {{1}}.`,\n  [ErrorNames.ast_nullish_keyed_access]: `Ast eval error: cannot access key \"{{0}}\" of {{1}}.`,\n  [ErrorNames.ast_nullish_assignment]: `Ast eval error: cannot assign value to property \"{{0}}\" of null/undefined.`,\n\n  [ErrorNames.parse_invalid_start]: `Expression error: invalid start: \"{{0}}\"`,\n  [ErrorNames.parse_no_spread]: `Expression error: spread operator is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_expected_identifier]: `Expression error: expected identifier: \"{{0}}\"`,\n  [ErrorNames.parse_invalid_member_expr]: `Expression error: invalid member expression: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_end]: `Expression error: unexpected end of expression: \"{{0}}\"`,\n  [ErrorNames.parse_unconsumed_token]: `Expression error: unconsumed token: \"{{0}}\" at position {{1}} of \"{{2}}\"`,\n  [ErrorNames.parse_invalid_empty]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,\n  [ErrorNames.parse_left_hand_side_not_assignable]: `Expression error: left hand side of expression is not assignable: \"{{0}}\"`,\n  [ErrorNames.parse_expected_converter_identifier]: `Expression error: expected identifier to come after value converter operator: \"{{0}}\"`,\n  [ErrorNames.parse_expected_behavior_identifier]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,\n  [ErrorNames.parse_unexpected_keyword_of]: `Expression error: unexpected keyword \"of\": \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_keyword_import]: `Expression error: unexpected keyword \"import\": \"{{0}}\"`,\n  [ErrorNames.parse_invalid_identifier_in_forof]: `Expression error: invalid BindingIdentifier at left hand side of \"of\": \"{{0}}\" | kind: {{1}}`,\n  [ErrorNames.parse_invalid_identifier_object_literal_key]: `Expression error: invalid or unsupported property definition in object literal: \"{{0}}\"`,\n  [ErrorNames.parse_unterminated_string]: `Expression error: unterminated quote in string literal: \"{{0}}\"`,\n  [ErrorNames.parse_unterminated_template_string]: `Expression error: unterminated template string: \"{{0}}\"`,\n  [ErrorNames.parse_missing_expected_token]: `Expression error: missing expected token \"{{0}}\" in \"{{1}}\"`,\n  [ErrorNames.parse_unexpected_character]: `Expression error: unexpected character: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_token_destructuring]: `Expression error: unexpected \"{{0}}\" at position \"{{1}}\" for destructuring assignment in \"{{2}}\"`,\n  [ErrorNames.parse_unexpected_token_optional_chain]: `Expression error: unexpected {{0}} at position \"{{1}}\" for optional chain in \"{{2}}\"`,\n  [ErrorNames.parse_invalid_tag_in_optional_chain]: `Expression error: invalid tagged template on optional chain in \"{{1}}\"`,\n  [ErrorNames.parse_invalid_arrow_params]: `Expression error: invalid arrow parameter list in \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_param_default_value]: `Expression error: arrow function with default parameters is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_param_destructuring]: `Expression error: arrow function with destructuring parameters is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_rest_must_be_last]: `Expression error: rest parameter must be last formal parameter in arrow function: \"{{0}}\"`,\n  [ErrorNames.parse_no_arrow_fn_body]: `Expression error: arrow function with function body is not supported: \"{{0}}\"`,\n  [ErrorNames.parse_unexpected_double_dot]: `Expression error: unexpected token '.' at position \"{{1}}\" in \"{{0}}\"`,\n\n  [ErrorNames.observing_null_undefined]: `Trying to observe property {{0}} on null/undefined`,\n  [ErrorNames.null_scope]: `Trying to retrieve a property or build a scope from a null/undefined scope`,\n  [ErrorNames.create_scope_with_null_context]: 'Trying to create a scope with null/undefined binding context',\n\n  [ErrorNames.switch_on_null_connectable]: `Trying to switch to a null/undefined connectable`,\n  [ErrorNames.switch_active_connectable]: `Trying to enter an active connectable`,\n  [ErrorNames.switch_off_null_connectable]: `Trying to pop a null/undefined connectable`,\n  [ErrorNames.switch_off_inactive_connectable]: `Trying to exit an inactive connectable`,\n  [ErrorNames.non_recognisable_collection_type]: `Unrecognised collection type {{0:toString}}.`,\n\n  [ErrorNames.dirty_check_no_handler]: 'There is no registration for IDirtyChecker interface. If you want to use your own dirty checker, make sure you register it.',\n  [ErrorNames.dirty_check_not_allowed]: `Dirty checked is not permitted in this application. Property key {{0}} is being dirty checked.`,\n  [ErrorNames.dirty_check_setter_not_allowed]: `Trying to set value for property {{0}} in dirty checker`,\n\n  [ErrorNames.assign_readonly_size]: `Map/Set \"size\" is a readonly property`,\n  [ErrorNames.assign_readonly_readonly_property_from_computed]: `Trying to assign value to readonly property \"{{0}}\" through computed observer.`,\n  [ErrorNames.invalid_observable_decorator_usage]: `Invalid @observable decorator usage, cannot determine property name`,\n  [ErrorNames.stopping_a_stopped_effect]: `Trying to stop an effect that has already been stopped`,\n  [ErrorNames.effect_maximum_recursion_reached]: `Maximum number of recursive effect run reached. Consider handle effect dependencies differently.`,\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n    let matches = regex.exec(cooked);\n    while (matches != null) {\n      const method = matches[1]?.slice(1);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let value = details[i] as any;\n      if (value != null) {\n        switch (method) {\n          case 'typeof': value = typeof value; break;\n          case 'toString': value = Object.prototype.toString.call(value); break;\n          case 'join(!=)': value = (value as unknown[]).join('!='); break;\n          case 'element': value = value === '*' ? 'all elements' : `<${value} />`; break;\n          default: {\n            // property access\n            if (method?.startsWith('.')) {\n              value = rtSafeString(value[method.slice(1)]);\n            } else {\n              value = rtSafeString(value);\n            }\n          }\n        }\n      }\n      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);\n      matches = regex.exec(cooked);\n    }\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n", "import { ErrorNames, createMappedError } from './errors';\n\nexport interface IBindingContext {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: PropertyKey]: any;\n}\n\nexport interface IOverrideContext {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: PropertyKey]: any;\n}\n\nexport class Scope {\n  private constructor(\n    public parent: Scope | null,\n    public bindingContext: IBindingContext,\n    public overrideContext: IOverrideContext,\n    public readonly isBoundary: boolean,\n  ) { }\n\n  public static getContext(scope: Scope, name: string, ancestor: number): IBindingContext | IOverrideContext | undefined | null {\n    if (scope == null) {\n      throw createMappedError(ErrorNames.null_scope);\n    }\n    let overrideContext: IOverrideContext | null = scope.overrideContext;\n    let currentScope: Scope | null = scope;\n\n    if (ancestor > 0) {\n      // jump up the required number of ancestor contexts (eg $parent.$parent requires two jumps)\n      while (ancestor > 0) {\n        ancestor--;\n        currentScope = currentScope.parent;\n        if (currentScope == null) {\n          return void 0;\n        }\n      }\n\n      overrideContext = currentScope.overrideContext;\n      // Here we are giving benefit of doubt considering the dev has used one or more `$parent` token, and thus should know what s/he is targeting.\n      return name in overrideContext ? overrideContext : currentScope.bindingContext;\n    }\n\n    // walk the scope hierarchy until\n    // the first scope that has the property in its contexts\n    // or\n    // the closet boundary scope\n    // -------------------------\n    // this behavior is different with v1\n    // where it would fallback to the immediate scope instead of the root one\n    // TODO: maybe avoid immediate loop and return earlier\n    // -------------------------\n    while (\n      currentScope != null\n      && !currentScope.isBoundary\n      && !(name in currentScope.overrideContext)\n      && !(name in currentScope.bindingContext)\n    ) {\n      currentScope = currentScope.parent;\n    }\n\n    if (currentScope == null) {\n      return scope.bindingContext;\n    }\n\n    overrideContext = currentScope.overrideContext;\n    return name in overrideContext ? overrideContext : currentScope.bindingContext;\n  }\n\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and a new standalone `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   *\n   * @param bc - The `BindingContext` to back the `Scope` with.\n   */\n  public static create(bc: object): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * @param bc - The `BindingContext` to back the `Scope` with.\n   * @param oc - The `OverrideContext` to back the `Scope` with.\n   * If a binding expression attempts to access a property that does not exist on the `BindingContext`\n   * during binding, it will traverse up via the `parentScope` of the scope until\n   * it finds the property.\n   */\n  public static create(bc: object, oc: IOverrideContext, isBoundary?: boolean): Scope;\n  /**\n   * Create a new `Scope` backed by the provided `BindingContext` and `OverrideContext`.\n   *\n   * Use this overload when the scope is for the root component, in a unit test,\n   * or when you simply want to prevent binding expressions from traversing up the scope.\n   *\n   * @param bc - The `BindingContext` to back the `Scope` with.\n   * @param oc - null. This overload is functionally equivalent to not passing this argument at all.\n   */\n  public static create(bc: object, oc: null, isBoundary?: boolean): Scope;\n  public static create(bc: object, oc?: IOverrideContext | null, isBoundary?: boolean): Scope {\n    if (bc == null) {\n      throw createMappedError(ErrorNames.create_scope_with_null_context);\n    }\n    return new Scope(null, bc as IBindingContext, oc ?? new OverrideContext(), isBoundary ?? false);\n  }\n\n  public static fromParent(ps: Scope | null, bc: object, oc: IOverrideContext = new OverrideContext()): Scope {\n    if (ps == null) {\n      throw createMappedError(ErrorNames.null_scope);\n    }\n    return new Scope(ps, bc as IBindingContext, oc, false);\n  }\n}\n\n/**\n * A class for creating context in synthetic scope to keep the number of classes of context in scope small\n */\nexport class BindingContext implements IBindingContext {\n  [key: PropertyKey]: unknown;\n\n  public constructor();\n  public constructor(key: PropertyKey, value: unknown);\n  public constructor(key?: PropertyKey, value?: unknown) {\n    if (key !== void 0) {\n      this[key] = value;\n    }\n  }\n}\n\nclass OverrideContext implements IOverrideContext {\n  [key: PropertyKey]: unknown;\n}\n", "/* eslint-disable no-fallthrough */\nimport {\n  CustomExpression,\n  DestructuringAssignmentSingleExpression,\n  type DestructuringAssignmentExpression,\n  type DestructuringAssignmentRestExpression,\n  type IsExpressionOrStatement,\n} from '@aurelia/expression-parser';\nimport { type AnyFunction, type IIndexable, isArrayIndex, isArray, isFunction, isObjectOrFunction, Constructable } from '@aurelia/kernel';\nimport { type IConnectable, type IObservable } from './interfaces';\nimport { Scope, type IBindingContext, type IOverrideContext } from './scope';\nimport { ErrorNames, createMappedError } from './errors';\nimport { rtSafeString as safeString } from './utilities';\n\n// -----------------------------------\n// this interface causes issues to sourcemap mapping in devtool\n// chuck it at the bottom to avoid such issue\n/**\n * An interface describing the object that can evaluate Aurelia AST\n */\nexport interface IAstEvaluator {\n  /** describe whether the evaluator wants to evaluate in strict mode */\n  strict?: boolean;\n  /** describe whether the evaluator wants a bound function to be returned, in case the returned value is a function */\n  boundFn?: boolean;\n  /**\n   * bind a behavior by the given name\n   */\n  bindBehavior?(name: string, scope: Scope, args: unknown[]): void;\n  /**\n   * unbind a behavior by the given name\n   */\n  unbindBehavior?(name: string, scope: Scope): void;\n  /**\n   * bind a converter by the given name\n   */\n  bindConverter?(name: string): void;\n  /**\n   * unbind a converter by the given name\n   */\n  unbindConverter?(name: string): void;\n  /**\n   * use a converter to convert a value\n   */\n  useConverter?(name: string, mode: 'toView' | 'fromView', value: unknown, args: unknown[]): unknown;\n}\n\nexport const {\n  astAssign,\n  astEvaluate,\n  astBind,\n  astUnbind\n} = /*@__PURE__*/(() => {\n  const ekAccessThis = 'AccessThis';\n  const ekAccessBoundary = 'AccessBoundary';\n  const ekAccessGlobal = 'AccessGlobal';\n  const ekAccessScope = 'AccessScope';\n  const ekArrayLiteral = 'ArrayLiteral';\n  const ekObjectLiteral = 'ObjectLiteral';\n  const ekPrimitiveLiteral = 'PrimitiveLiteral';\n  const ekNew = 'New';\n  const ekTemplate = 'Template';\n  const ekUnary = 'Unary';\n  const ekCallScope = 'CallScope';\n  const ekCallMember = 'CallMember';\n  const ekCallFunction = 'CallFunction';\n  const ekCallGlobal = 'CallGlobal';\n  const ekAccessMember = 'AccessMember';\n  const ekAccessKeyed = 'AccessKeyed';\n  const ekTaggedTemplate = 'TaggedTemplate';\n  const ekBinary = 'Binary';\n  const ekConditional = 'Conditional';\n  const ekAssign = 'Assign';\n  const ekArrowFunction = 'ArrowFunction';\n  const ekValueConverter = 'ValueConverter';\n  const ekBindingBehavior = 'BindingBehavior';\n  const ekArrayBindingPattern = 'ArrayBindingPattern';\n  const ekObjectBindingPattern = 'ObjectBindingPattern';\n  const ekBindingIdentifier = 'BindingIdentifier';\n  const ekForOfStatement = 'ForOfStatement';\n  const ekInterpolation = 'Interpolation';\n  const ekArrayDestructuring = 'ArrayDestructuring';\n  const ekObjectDestructuring = 'ObjectDestructuring';\n  const ekDestructuringAssignmentLeaf = 'DestructuringAssignmentLeaf';\n  const ekCustom = 'Custom';\n  const getContext = Scope.getContext;\n\n  // eslint-disable-next-line max-lines-per-function\n  function astEvaluate(ast: CustomExpression | IsExpressionOrStatement, s: Scope, e: IAstEvaluator | null, c: IConnectable | null): unknown {\n    switch (ast.$kind) {\n      case ekAccessThis: {\n        let oc: IOverrideContext | null = s.overrideContext;\n        let currentScope: Scope | null = s;\n        let i = ast.ancestor;\n        while (i-- && oc) {\n          currentScope = currentScope!.parent;\n          oc = currentScope?.overrideContext ?? null;\n        }\n        return i < 1 && currentScope ? currentScope.bindingContext : void 0;\n      }\n      case ekAccessBoundary: {\n        let currentScope: Scope | null = s;\n\n        while (\n          currentScope != null\n          && !currentScope.isBoundary\n        ) {\n          currentScope = currentScope.parent;\n        }\n        return currentScope ? currentScope.bindingContext : void 0;\n      }\n      case ekAccessScope: {\n        const obj = getContext(s, ast.name, ast.ancestor) as IBindingContext;\n        if (c !== null) {\n          c.observe(obj, ast.name);\n        }\n        const evaluatedValue: unknown = obj[ast.name];\n        if (evaluatedValue == null) {\n          if (ast.name === '$host') {\n            throw createMappedError(ErrorNames.ast_$host_not_found);\n          }\n          return evaluatedValue;\n        }\n        return e?.boundFn && isFunction(evaluatedValue)\n          ? evaluatedValue.bind(obj)\n          : evaluatedValue;\n      }\n      case ekAccessGlobal:\n        return globalThis[ast.name as keyof typeof globalThis];\n      case ekCallGlobal: {\n        const func = globalThis[ast.name as keyof typeof globalThis] as AnyFunction;\n        if (isFunction(func)) {\n          return func(...ast.args.map(a => astEvaluate(a, s, e, c)));\n        }\n        /* istanbul ignore next */\n        if (!e?.strict && func == null) {\n          return void 0;\n        }\n        throw createMappedError(ErrorNames.ast_not_a_function);\n      }\n      case ekArrayLiteral:\n        return ast.elements.map(expr => astEvaluate(expr, s, e, c));\n      case ekObjectLiteral: {\n        const instance: Record<string, unknown> = {};\n        for (let i = 0; i < ast.keys.length; ++i) {\n          instance[ast.keys[i]] = astEvaluate(ast.values[i], s, e, c);\n        }\n        return instance;\n      }\n      case ekPrimitiveLiteral:\n        return ast.value;\n      case ekNew: {\n        const func = astEvaluate(ast.func, s, e, c);\n        if (isFunction(func)) {\n          return new (func as Constructable)(...ast.args.map(a => astEvaluate(a, s, e, c)));\n        }\n        throw createMappedError(ErrorNames.ast_not_a_function);\n      }\n      case ekTemplate: {\n        let result = ast.cooked[0];\n        for (let i = 0; i < ast.expressions.length; ++i) {\n          result += safeString(astEvaluate(ast.expressions[i], s, e, c));\n          result += ast.cooked[i + 1];\n        }\n        return result;\n      }\n      case ekUnary: {\n        const value = astEvaluate(ast.expression, s, e, c) ;\n        switch (ast.operation as string) {\n          case 'void':\n            return void value;\n          case 'typeof':\n            return typeof value;\n          case '!':\n            return !(value as boolean);\n          case '-':\n            return -(value as number);\n          case '+':\n            return +(value as number);\n          case '--':\n            if (c != null) throw createMappedError(ErrorNames.ast_increment_infinite_loop);\n            return (astAssign(ast.expression, s, e, c, (value as number) - 1) as number) + ast.pos;\n          case '++':\n            if (c != null) throw createMappedError(ErrorNames.ast_increment_infinite_loop);\n            return (astAssign(ast.expression, s, e, c, (value as number) + 1) as number) - ast.pos;\n          default:\n            throw createMappedError(ErrorNames.ast_unknown_unary_operator, ast.operation);\n        }\n      }\n      case ekCallScope: {\n        const context = getContext(s, ast.name, ast.ancestor)!;\n        if (context == null) {\n          if (e?.strict) {\n            throw createMappedError(ErrorNames.ast_nullish_member_access, ast.name, context);\n          }\n          return void 0;\n        }\n        const fn: unknown = context[ast.name];\n        if (isFunction(fn)) {\n          return fn.apply(context, ast.args.map(a => astEvaluate(a, s, e, c)));\n        }\n        if (fn == null) {\n          if (e?.strict && !ast.optional) {\n            throw createMappedError(ErrorNames.ast_name_is_not_a_function, ast.name);\n          }\n          return void 0;\n        }\n        throw createMappedError(ErrorNames.ast_name_is_not_a_function, ast.name);\n      }\n      case ekCallMember: {\n        const instance = astEvaluate(ast.object, s, e, c) as IIndexable;\n        if (instance == null) {\n          if (e?.strict && !ast.optionalMember) {\n            throw createMappedError(ErrorNames.ast_nullish_member_access, ast.name, instance);\n          }\n        }\n        const fn = instance?.[ast.name];\n        if (fn == null) {\n          if (!ast.optionalCall && e?.strict) {\n            throw createMappedError(ErrorNames.ast_name_is_not_a_function, ast.name);\n          }\n          return void 0;\n        }\n        if (!isFunction(fn)) {\n          throw createMappedError(ErrorNames.ast_name_is_not_a_function, ast.name);\n        }\n        const ret = fn.apply(instance, ast.args.map(a => astEvaluate(a, s, e, c)));\n        if (isArray(instance) && autoObserveArrayMethods.includes(ast.name)) {\n          c?.observeCollection(instance);\n        }\n        return ret;\n      }\n      case ekCallFunction: {\n        const func = astEvaluate(ast.func, s, e, c);\n        if (isFunction(func)) {\n          return func(...ast.args.map(a => astEvaluate(a, s, e, c)));\n        }\n        if (func == null) {\n          if (!ast.optional && e?.strict) {\n            throw createMappedError(ErrorNames.ast_not_a_function);\n          }\n          return void 0;\n        }\n        throw createMappedError(ErrorNames.ast_not_a_function);\n      }\n      case ekArrowFunction: {\n        const func = (...args: unknown[]) => {\n          const params = ast.args;\n          const rest = ast.rest;\n          const lastIdx = params.length - 1;\n          const context = params.reduce<IIndexable>((map, param, i) => {\n            if (rest && i === lastIdx) {\n              map[param.name] = args.slice(i);\n            } else {\n              map[param.name] = args[i];\n            }\n            return map;\n          }, {});\n          const functionScope = Scope.fromParent(s, context);\n          return astEvaluate(ast.body, functionScope, e, c);\n        };\n        return func;\n      }\n      case ekAccessMember: {\n        const instance = astEvaluate(ast.object, s, e, c) as IIndexable | null;\n        if (instance == null) {\n          if (!ast.optional && e?.strict) {\n            throw createMappedError(ErrorNames.ast_nullish_member_access, ast.name, instance);\n          }\n          return void 0;\n        }\n\n        if (c !== null && !ast.accessGlobal) {\n          c.observe(instance, ast.name);\n        }\n        const ret = instance[ast.name];\n        return e?.boundFn && isFunction(ret)\n          // event listener wants the returned function to be bound to the instance\n          ? ret.bind(instance)\n          : ret;\n      }\n      case ekAccessKeyed: {\n        const instance = astEvaluate(ast.object, s, e, c) as IIndexable;\n        const key = astEvaluate(ast.key, s, e, c) as string;\n\n        if (instance == null) {\n          if (!ast.optional && e?.strict) {\n            throw createMappedError(ErrorNames.ast_nullish_keyed_access, key, instance);\n          }\n          return void 0;\n        }\n\n        if (c !== null && !ast.accessGlobal) {\n          c.observe(instance, key);\n        }\n\n        return instance[key];\n      }\n      case ekTaggedTemplate: {\n        const results = ast.expressions.map(expr => astEvaluate(expr, s, e, c));\n        const func = astEvaluate(ast.func, s, e, c);\n        if (!isFunction(func)) {\n          throw createMappedError(ErrorNames.ast_tagged_not_a_function);\n        }\n        return func(ast.cooked, ...results);\n      }\n      case ekBinary: {\n        const left = ast.left;\n        const right = ast.right;\n        switch (ast.operation as string) {\n          case '&&':\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return astEvaluate(left, s, e, c) && astEvaluate(right, s, e, c);\n          case '||':\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return astEvaluate(left, s, e, c) || astEvaluate(right, s, e, c);\n          case '??':\n            return astEvaluate(left, s, e, c) ?? astEvaluate(right, s, e, c);\n          case '==':\n            // eslint-disable-next-line eqeqeq\n            return astEvaluate(left, s, e, c) == astEvaluate(right, s, e, c);\n          case '===':\n            return astEvaluate(left, s, e, c) === astEvaluate(right, s, e, c);\n          case '!=':\n            // eslint-disable-next-line eqeqeq\n            return astEvaluate(left, s, e, c) != astEvaluate(right, s, e, c);\n          case '!==':\n            return astEvaluate(left, s, e, c) !== astEvaluate(right, s, e, c);\n          case 'instanceof': {\n            const $right = astEvaluate(right, s, e, c);\n            if (isFunction($right)) {\n              return astEvaluate(left, s, e, c) instanceof $right;\n            }\n            return false;\n          }\n          case 'in': {\n            const $right = astEvaluate(right, s, e, c);\n            if (isObjectOrFunction($right)) {\n              return astEvaluate(left, s, e, c) as string in $right;\n            }\n            return false;\n          }\n          case '+':\n            return (astEvaluate(left, s, e, c) as number) + (astEvaluate(right, s, e, c) as number);\n          case '-':\n            return (astEvaluate(left, s, e, c) as number) - (astEvaluate(right, s, e, c) as number);\n          case '*':\n            return (astEvaluate(left, s, e, c) as number) * (astEvaluate(right, s, e, c) as number);\n          case '/':\n            return (astEvaluate(left, s, e, c) as number) / (astEvaluate(right, s, e, c) as number);\n          case '%':\n            return (astEvaluate(left, s, e, c) as number) % (astEvaluate(right, s, e, c) as number);\n          case '**':\n            return (astEvaluate(left, s, e, c) as number) ** (astEvaluate(right, s, e, c) as number);\n          case '<':\n            return (astEvaluate(left, s, e, c) as number) < (astEvaluate(right, s, e, c) as number);\n          case '>':\n            return (astEvaluate(left, s, e, c) as number) > (astEvaluate(right, s, e, c) as number);\n          case '<=':\n            return (astEvaluate(left, s, e, c) as number) <= (astEvaluate(right, s, e, c) as number);\n          case '>=':\n            return (astEvaluate(left, s, e, c) as number) >= (astEvaluate(right, s, e, c) as number);\n          default:\n            throw createMappedError(ErrorNames.ast_unknown_binary_operator, ast.operation);\n        }\n      }\n      case ekConditional:\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        return astEvaluate(ast.condition, s, e, c) ? astEvaluate(ast.yes, s, e, c) : astEvaluate(ast.no, s, e, c);\n      case ekAssign: {\n        let value = astEvaluate(ast.value, s, e, c) as number;\n        if (ast.op !== '=') {\n          if (c != null) {\n            throw createMappedError(ErrorNames.ast_increment_infinite_loop);\n          }\n          const target = (astEvaluate(ast.target, s, e, c) as number);\n          switch (ast.op) {\n            case '/=':\n              value = target / value;\n              break;\n            case '*=':\n              value = target * value;\n              break;\n            case '+=':\n              value = target + value;\n              break;\n            case '-=':\n              value = target - value;\n              break;\n            default:\n              throw createMappedError(ErrorNames.ast_unknown_binary_operator, ast.op);\n          }\n        }\n        return astAssign(ast.target, s, e, c, value);\n      }\n      case ekValueConverter: {\n        return e?.useConverter?.(ast.name, 'toView', astEvaluate(ast.expression, s, e, c), ast.args.map(a => astEvaluate(a, s, e, c)));\n      }\n      case ekBindingBehavior:\n        return astEvaluate(ast.expression, s, e, c);\n      case ekBindingIdentifier:\n        return ast.name;\n      case ekForOfStatement:\n        return astEvaluate(ast.iterable, s, e, c);\n      case ekInterpolation:\n        if (ast.isMulti) {\n          let result = ast.parts[0];\n          let i = 0;\n          for (; i < ast.expressions.length; ++i) {\n            result += safeString(astEvaluate(ast.expressions[i], s, e, c));\n            result += ast.parts[i + 1];\n          }\n          return result;\n        } else {\n          return `${ast.parts[0]}${astEvaluate(ast.firstExpression, s, e, c)}${ast.parts[1]}`;\n        }\n      case ekDestructuringAssignmentLeaf:\n        return astEvaluate(ast.target, s, e, c);\n      case ekArrayDestructuring: {\n        return ast.list.map(x => astEvaluate(x, s, e, c));\n      }\n      // TODO: this should come after batch\n      // as a destructuring expression like [x, y] = value\n      //\n      // should only trigger change only once:\n      // batch(() => {\n      //   object.x = value[0]\n      //   object.y = value[1]\n      // })\n      //\n      // instead of twice:\n      // object.x = value[0]\n      // object.y = value[1]\n      case ekArrayBindingPattern:\n      // TODO\n      // similar to array binding ast, this should only come after batch\n      // for a single notification per destructing,\n      // regardless number of property assignments on the scope binding context\n      case ekObjectBindingPattern:\n      case ekObjectDestructuring:\n      default:\n        return void 0;\n      case ekCustom:\n        return ast.evaluate(s, e, c);\n    }\n  }\n\n  function astAssign(ast: CustomExpression | IsExpressionOrStatement, s: Scope, e: IAstEvaluator | null, c: IConnectable | null, val: unknown): unknown {\n    switch (ast.$kind) {\n      case ekAccessScope: {\n        if (ast.name === '$host') {\n          throw createMappedError(ErrorNames.ast_no_assign_$host);\n        }\n        const obj = getContext(s, ast.name, ast.ancestor) as IObservable;\n        return obj[ast.name] = val;\n      }\n      case ekAccessMember: {\n        const obj = astEvaluate(ast.object, s, e, c) as IObservable;\n        if (obj == null) {\n          if (e?.strict) {\n            // if ast optional and the optional assignment proposal goes ahead\n            // we can allow this to be a no-op instead of throwing (check via ast.optional)\n            // https://github.com/tc39/proposal-optional-chaining-assignment\n            throw createMappedError(ErrorNames.ast_nullish_assignment, ast.name);\n          }\n          // creating an object and assign it to the owning property of the ast\n          // this is a good enough behavior, and it works well in v1\n          astAssign(ast.object, s, e, c, { [ast.name]: val });\n        } else if (isObjectOrFunction(obj)) {\n          if (ast.name === 'length' && isArray(obj) && !isNaN(val as number)) {\n            obj.splice(val as number);\n          } else {\n            obj[ast.name] = val;\n          }\n        } else {\n          // obj is a primitive, assigning a value to a property on a primitive\n          // does nothing\n        }\n        return val;\n      }\n      case ekAccessKeyed: {\n        const instance = astEvaluate(ast.object, s, e, c) as IIndexable;\n        const key = astEvaluate(ast.key, s, e, c) as string;\n        if (instance == null) {\n          if (e?.strict) {\n            // if ast optional and the optional assignment proposal goes ahead\n            // we can allow this to be a no-op instead of throwing (check via ast.optional)\n            // https://github.com/tc39/proposal-optional-chaining-assignment\n            throw createMappedError(ErrorNames.ast_nullish_assignment, key);\n          }\n          // creating an object and assign it to the owning property of the ast\n          // this is a good enough behavior, and it works well in v1\n          astAssign(ast.object, s, e, c, { [key]: val });\n          return val;\n        }\n\n        if (isArray(instance)) {\n          if (key === 'length' && !isNaN(val as number)) {\n            instance.splice(val as number);\n            return val;\n          }\n          if (isArrayIndex(key)) {\n            instance.splice(key as unknown as number, 1, val);\n            return val;\n          }\n        }\n\n        return instance[key] = val;\n      }\n      case ekAssign:\n        astAssign(ast.value, s, e, c, val);\n        return astAssign(ast.target, s, e, c, val);\n      case ekValueConverter: {\n        val = e?.useConverter?.(ast.name, 'fromView', val, ast.args.map(a => astEvaluate(a, s, e, c)));\n        return astAssign(ast.expression, s, e, c, val);\n      }\n      case ekBindingBehavior:\n        return astAssign(ast.expression, s, e, c, val);\n      case ekArrayDestructuring:\n      case ekObjectDestructuring: {\n        const list = ast.list;\n        const len = list.length;\n        let i: number;\n        let item: DestructuringAssignmentExpression | DestructuringAssignmentSingleExpression | DestructuringAssignmentRestExpression;\n        for (i = 0; i < len; i++) {\n          item = list[i];\n          switch (item.$kind) {\n            case ekDestructuringAssignmentLeaf:\n              astAssign(item, s, e, c, val);\n              break;\n            case ekArrayDestructuring:\n            case ekObjectDestructuring: {\n              if (typeof val !== 'object' || val === null) {\n                throw createMappedError(ErrorNames.ast_destruct_null);\n              }\n              let source = astEvaluate(item.source!, Scope.create(val), e, null);\n              if (source === void 0 && item.initializer) {\n                source = astEvaluate(item.initializer, s, e, null);\n              }\n              astAssign(item, s, e, c, source);\n              break;\n            }\n          }\n        }\n        break;\n      }\n      case ekDestructuringAssignmentLeaf: {\n        if (ast instanceof DestructuringAssignmentSingleExpression) {\n          if (val == null) { return; }\n          if (typeof val !== 'object') {\n            throw createMappedError(ErrorNames.ast_destruct_null);\n          }\n          let source = astEvaluate(ast.source, Scope.create(val), e, c);\n          if (source === void 0 && ast.initializer) {\n            source = astEvaluate(ast.initializer, s, e, c);\n          }\n          astAssign(ast.target, s, e, c, source);\n        } else {\n          if (val == null) { return; }\n          if (typeof val !== 'object') {\n            throw createMappedError(ErrorNames.ast_destruct_null);\n          }\n\n          const indexOrProperties = ast.indexOrProperties;\n\n          let restValue: Record<string, unknown> | unknown[];\n          if (isArrayIndex(indexOrProperties)) {\n            if (!Array.isArray(val)) {\n              throw createMappedError(ErrorNames.ast_destruct_null);\n            }\n            restValue = val.slice(indexOrProperties);\n          } else {\n            restValue = Object\n              .entries(val)\n              .reduce((acc, [k, v]) => {\n                if (!indexOrProperties.includes(k)) { acc[k] = v; }\n                return acc;\n                // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n              }, {} as Record<string, unknown>);\n          }\n          astAssign(ast.target, s, e, c, restValue);\n        }\n        break;\n      }\n      case ekCustom:\n        return ast.assign(s, e, val);\n      default:\n        return void 0;\n    }\n  }\n\n  function astBind(ast: CustomExpression | IsExpressionOrStatement, s: Scope, b: IAstEvaluator) {\n    switch (ast.$kind) {\n      case ekBindingBehavior: {\n        b.bindBehavior?.(ast.name, s, ast.args.map(a => astEvaluate(a, s, b, null)));\n        astBind(ast.expression, s, b);\n        break;\n      }\n      case ekValueConverter: {\n        b.bindConverter?.(ast.name);\n        astBind(ast.expression, s, b);\n        break;\n      }\n      case ekForOfStatement: {\n        astBind(ast.iterable, s, b);\n        break;\n      }\n      case ekCustom: {\n        ast.bind?.(s, b);\n      }\n    }\n  }\n\n  function astUnbind(ast: CustomExpression | IsExpressionOrStatement, s: Scope, b: IAstEvaluator) {\n    switch (ast.$kind) {\n      case ekBindingBehavior: {\n        b.unbindBehavior?.(ast.name, s);\n        astUnbind(ast.expression, s, b);\n        break;\n      }\n      case ekValueConverter: {\n        b.unbindConverter?.(ast.name);\n        astUnbind(ast.expression, s, b);\n        break;\n      }\n      case ekForOfStatement: {\n        astUnbind(ast.iterable, s, b);\n        break;\n      }\n      case ekCustom: {\n        ast.unbind?.(s, b);\n      }\n    }\n  }\n\n  const autoObserveArrayMethods =\n    'at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort'.split(' ');\n  // sort,      // bad supported, self mutation + unclear dependency\n\n  // push,      // not supported, self mutation + unclear dependency\n  // pop,       // not supported, self mutation + unclear dependency\n  // shift,     // not supported, self mutation + unclear dependency\n  // splice,    // not supported, self mutation + unclear dependency\n  // unshift,   // not supported, self mutation + unclear dependency\n  // reverse,   // not supported, self mutation + unclear dependency\n\n  // keys,    // not meaningful in template\n  // values,  // not meaningful in template\n  // entries, // not meaningful in template\n\n  return {\n    astEvaluate,\n    astAssign,\n    astBind,\n    astUnbind,\n  };\n})();\n", "import { Constructable } from '@aurelia/kernel';\nimport { IAstEvaluator } from './ast.eval';\nimport { rtDefineHiddenProp } from './utilities';\nimport { createMappedError, ErrorNames } from './errors';\n\n/**\n * For Aurelia packages internal use only, do not use this in application code.\n *\n * Add ast evaluator mixin with throw implementation for all methods.\n */\nexport const mixinNoopAstEvaluator = (() => <T extends IAstEvaluator>(target: Constructable<T>) => {\n  const proto = target.prototype;\n  ['bindBehavior', 'unbindBehavior', 'bindConverter', 'unbindConverter', 'useConverter'].forEach(name => {\n    rtDefineHiddenProp(proto, name, () => { throw createMappedError(ErrorNames.method_not_implemented, name); });\n  });\n})();\n", "/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable jsdoc/check-indentation */\n/* eslint-disable jsdoc/no-multi-asterisks */\nimport { noop } from '@aurelia/kernel';\n\nconst tsPending = 'pending';\nconst tsRunning = 'running';\nconst tsCompleted = 'completed';\nconst tsCanceled = 'canceled';\nexport type TaskStatus = typeof tsPending | typeof tsRunning | typeof tsCompleted | typeof tsCanceled;\nexport type TaskCallback<T = any> = () => T;\n\nconst resolvedPromise = Promise.resolve();\nlet runScheduled = false;\nlet isAutoRun = false;\n\nconst queue: (Task | RecurringTask | (() => unknown))[] = [];\nconst recurringTasks: RecurringTask[] = [];\nlet pendingAsyncCount = 0;\nlet settlePromise: Promise<boolean> | null = null;\nlet taskErrors: unknown[] = [];\nlet settlePromiseResolve: ((value: boolean) => void) | null = null;\nlet settlePromiseReject: ((reason?: any) => void) | null = null;\n\nconst requestRun = () => {\n  if (!runScheduled) {\n    runScheduled = true;\n    void resolvedPromise.then(() => {\n      runScheduled = false;\n      isAutoRun = true;\n      runTasks();\n    });\n  }\n};\n\nconst signalSettled = (hasPerformedWork: boolean) => {\n  if (settlePromise && queue.length === 0 && pendingAsyncCount === 0) {\n    settlePromise = null;\n    if (taskErrors.length > 0) {\n      const errors = taskErrors;\n      taskErrors = [];\n      if (errors.length === 1) {\n        settlePromiseReject!(errors[0]);\n      } else {\n        settlePromiseReject!(new AggregateError(errors, 'One or more tasks failed.'));\n      }\n    } else {\n      settlePromiseResolve!(hasPerformedWork);\n    }\n  }\n};\n\n/**\n * **Immediately drain** Aurelia's internal task queue.\n *\n * Normally the scheduler calls this automatically on the next micro-task\n * whenever you enqueue work with {@link queueTask} or {@link queueAsyncTask}.\n * Calling it yourself is only useful in **low-level tests, debugging sessions,\n * or custom instrumentation** where you need a _synchronous_ flush.\n *\n * ### What it does\n * 1. Removes each item from the queue (FIFO) and runs it.\n * 2. If an item queues more work, the loop continues until the queue is empty,\n *    up to **10 000 extra tasks**  after that a \"Potential deadlock\" error is\n *    thrown and the queue is cleared.\n * 3. Collects every uncaught exception.\n *    * When you invoke the function manually those errors are re-thrown \n *      either the single error or an `AggregateError` if several tasks failed.*\n *    * During the scheduler's automatic run they are _suppressed_ and will only\n *      surface through `tasksSettled()` or the runtime console, so the app\n *      keeps running.\n * 4. Signals the internal \"settled promise\" so `await tasksSettled()` continues\n *    once _all_ **synchronous** callbacks have finished (async promises may\n *    still be pending).\n *\n * > **Tip:** In most cases you should prefer `await tasksSettled()`; it waits\n * > for both the synchronous drain **and** any asynchronous work started by\n * > the tasks. `runTasks()` is only needed when you must stay purely\n * > synchronous (e.g. inside a non-async test).\n *\n * @throws Error            If a task throws and you called the function\n *                          directly.\n * @throws AggregateError   If multiple tasks throw.\n * @throws Error            \"Potential deadlock detected\" when > 10 000 extra\n *                          tasks are re-queued in one drain.\n *\n * @example\n * Synchronous assertion in a non-async test\n * ```ts\n * it('updates the DOM synchronously', () => {\n *   vm.value = 42;\n *   runTasks(); // flush queue synchronously\n *   expect(el.textContent).toBe('42');\n * });\n * ```\n *\n * @example\n * Debugging pending tasks in the browser console\n * ```ts\n * // In the app startup code\n * window.runTasks = runTasks;\n *\n * // After pausing in a breakpoint\n * window.runTasks(); // force the scheduler to drain now\n * ```\n *\n * @example\n * Fail fast when a task throws during manual drain\n * ```ts\n * try {\n *   runTasks();\n * } catch (e) {\n *   console.error('A queued operation failed:', e);\n *   throw e; // make the test fail\n * }\n * ```\n */\nexport const runTasks = () => {\n  const isManualRun = !isAutoRun;\n  isAutoRun = false;\n  settlePromise ??= new Promise<boolean>((resolve, reject) => {\n    settlePromiseResolve = resolve;\n    settlePromiseReject = reject;\n  });\n\n  let extraTaskCount = -queue.length;\n\n  const isEmpty = queue.length === 0;\n  while (queue.length > 0) {\n    if (++extraTaskCount > 10000) {\n      const error = new Error(`Potential deadlock detected. More than 10000 extra tasks were queued from within tasks.`);\n      queue.length = 0;\n      settlePromiseReject?.(error);\n      settlePromise = null;\n      throw error;\n    }\n\n    const task = queue.shift()!;\n    if (typeof task === 'function') {\n      try {\n        task();\n      } catch (err) {\n        taskErrors.push(err);\n      }\n    } else {\n      task.run();\n    }\n  }\n  // Make a copy; this is for testing, signalSettled will clear the array\n  const errors = taskErrors.slice();\n  signalSettled(!isEmpty);\n  if (isManualRun && errors.length > 0) {\n    if (errors.length === 1) {\n      throw errors[0];\n    } else {\n      throw new AggregateError(errors, 'One or more tasks failed.');\n    }\n  }\n};\n\n/**\n * Gets a read-only copy of the list of all active recurring tasks.\n *\n * While the returned array is a copy, the `RecurringTask` objects within it\n * are the actual instances managed by the scheduler. This is useful for\n * inspection or for cleaning up all active tasks by iterating over the array\n * and calling `task.cancel()` on each one.\n *\n * @returns A new array containing all currently active {@link RecurringTask} instances.\n *\n * @example\n * Cleaning up after a test\n * ```ts\n * afterEach(() => {\n *   // Ensure no recurring tasks leak between tests\n *   for (const task of getRecurringTasks()) {\n *     task.cancel();\n *   }\n * });\n * ```\n *\n * @example\n * Inspecting active tasks for debugging\n * ```ts\n * function logActiveRecurringTasks() {\n *   const tasks = getRecurringTasks();\n *   if (tasks.length > 0) {\n *     console.log('Active recurring tasks:', tasks.map(t => `ID ${t.id}`));\n *   } else {\n *     console.log('No active recurring tasks.');\n *   }\n * }\n * ```\n */\nexport const getRecurringTasks = () => {\n  return recurringTasks.slice();\n};\n\n/**\n * Return a promise that resolves once **all queued work has finished** and the\n * Aurelia scheduler is completely idle.\n *\n * Conceptually similar to a browser's \"micro-task drain\" (the classic\n * `await Promise.resolve()` trick) but extended to cover:\n *\n * * synchronous micro-tasks queued via {@link queueTask}\n * * asynchronous or delayed tasks queued via {@link queueAsyncTask}\n * * any promises those callbacks return\n *\n * Perfect for unit / component / e2e tests where you must wait for bindings,\n * observers, `requestAnimationFrame` chains and timers to flush **without\n * guessing a timeout**.\n *\n * #### Behaviour\n * | Situation                                                | Result                             |\n * |----------------------------------------------------------|------------------------------------|\n * | At least one task ran before the queue became empty      | **resolves `true`**                |\n * | Nothing was pending when you called the function         | **resolves `false`**               |\n * | One task throws                                          | **rejects** with that error        |\n * | Multiple tasks throw                                     | **rejects** with an `AggregateError` |\n *\n * Re-invocations while work is still pending return the **same** promise; once\n * everything settles, the next call starts a fresh cycle.\n *\n * @returns Promise<boolean> &mdash; `true` if any work was processed,\n *          otherwise `false`.\n *\n * @throws {*} Propagates the error(s) thrown by tasks, see table above.\n *\n * @example\n * <caption>Flush bindings in a component test\n * ```ts\n * vm.todoText = 'Write docs';\n * vm.addTodo();\n * await tasksSettled(); // wait for DOM & animations\n * expect(list.children.length).toBe(1);\n * ```\n *\n * @example\n * Playwright helper to wait for framework idle\n * ```ts\n * // In the app startup code\n * window.tasksSettled = tasksSettled;\n *\n * // helpers.ts\n * export async function waitForIdle(page: Page) {\n *   await page.evaluate(() => window.tasksSettled());\n * }\n *\n * await page.getByRole('button', { name: 'Save' }).click();\n * await waitForIdle(page); // no arbitrary sleeps\n * ```\n *\n * @example\n * Detect and surface aggregated task errors\n * ```ts\n * queueTask(() => { throw new Error('first'); });\n * queueTask(() => { throw new Error('second'); });\n *\n * try {\n *   await tasksSettled();\n * } catch (e) {\n *   if (e instanceof AggregateError) {\n *     console.log('Multiple failures:', e.errors.length);\n *   }\n * }\n * ```\n *\n * @example\n * Ensure every test exits cleanly using the boolean result\n * ```ts\n * afterEach(async () => {\n *   const didWork = await tasksSettled();\n *   if (didWork) {\n *     // Failing here highlights orphaned micro-tasks or timers left by the test\n *     throw new Error('Test left pending work on the Aurelia scheduler');\n *   }\n * });\n * ```\n */\nexport const tasksSettled = (): Promise<boolean> => {\n  // do not convert to async function (it will wrap the internal promise and cause test code to fail)\n  if (settlePromise) {\n    return settlePromise;\n  }\n  if (queue.length > 0 || pendingAsyncCount > 0) {\n    return settlePromise ??= new Promise<boolean>((resolve, reject) => {\n      settlePromiseResolve = resolve;\n      settlePromiseReject = reject;\n    });\n  }\n  // Not strictly necessary but without this we need a lot of extra `await Promise.resolve()` in test code\n  return resolvedPromise.then(() => {\n    if (queue.length > 0 || pendingAsyncCount > 0) {\n      return settlePromise ??= new Promise<boolean>((resolve, reject) => {\n        settlePromiseResolve = resolve;\n        settlePromiseReject = reject;\n      });\n    }\n    return false;\n  });\n};\n\n/**\n * Queue a **synchronous** callback onto Aurelia's internal task queue.\n *\n * The callback is executed in the same micro-task drain as bindings,\n * computed observers, and other framework internals, immediately after the\n * current call-stack has unwound.\n * Because these tasks are *fire-and-forget* they:\n *\n * * **cannot be awaited**  if you need an awaitable handle use\n *   {@link queueAsyncTask} instead;\n * * are still included in the bookkeeping for {@link tasksSettled}, so tests\n *   that `await tasksSettled()` will not proceed until every queued callback\n *   has run.\n *\n * **Intended audience**: framework contributors, advanced plug-ins, and custom\n * binding strategies. Typical application code rarely needs this API.\n *\n * @param callback - A *synchronous* function to execute after the current\n *                   JavaScript turn.  Any exception it throws is captured and\n *                   surfaced collectively via `tasksSettled()` or `runTasks()`.\n */\nexport const queueTask = (callback: TaskCallback) => {\n  requestRun();\n  queue.push(callback);\n};\n\n/**\n * Queue a callback to run **asynchronously** on Aurelia's central scheduler\n * and get back a {@link Task} object you can:\n *\n * * `await`  via `task.result`\n * * cancel  via `task.cancel()`\n * * inspect  via `task.status`\n *\n * Any callbacks scheduled this way are automatically tracked by the framework,\n * so `await tasksSettled()` waits until the all tasks (and any promises they return)\n * have finished.\n *\n * @template R The value returned by `callback`, or the value the promise it\n *             returns resolves to.\n *\n * @param callback  - A function to execute. It may be synchronous or asynchronous;\n *                    if it returns a promise, the scheduler treats the task as\n *                    *running* until that promise settles.\n *\n * @param options.delay  - Optional delay **in milliseconds** before the callback\n *                         is queued. While waiting, the task can still be\n *                         cancelled.\n *\n * @returns The {@link Task} representing the scheduled work.\n *\n * @throws {TaskAbortError} The task's `result` promise rejects with this error\n *                          if the task is cancelled before it starts.\n * @throws {*}              The task's `result` promise propagates any error\n *                          thrown by `callback`.\n *\n * ---\n *\n * @example\n * Component integration tests\n * ```ts\n * it('increments the view when the button is clicked', async () => {\n *   const { vm, host } = await createFixture(`<counter></counter>`);\n *   host.querySelector('button')!.click();\n *\n *   // This will resolve after every queued task has finished,\n *   // including rendering.\n *   await tasksSettled();\n *\n *   expect(host.textContent).toContain('1');\n * });\n * ```\n *\n * @example\n * Debounce a network search  cancel if the user keeps typing\n * ```ts\n * let current: Task<SearchResult[]> | null = null;\n *\n * function search(term: string) {\n *   current?.cancel(); // abort the previous call\n *\n *   current = queueAsyncTask(async () => {\n *     const resp = await fetch(`/api/search?q=${encodeURIComponent(term)}`);\n *     return resp.json() as Promise<SearchResult[]>;\n *   }, { delay: 300 }); // classic 300 ms debounce\n *\n *   return current.result; // awaitable by callers\n * }\n * ```\n *\n * @example\n * Schedule expensive canvas work onto the next animation frame (test-friendly)\n * ```ts\n * export function scheduleRender(frameData: Data) {\n *   queueAsyncTask(\n *     () => new Promise<void>(resolve => requestAnimationFrame(() => {\n *       draw(frameData); // expensive canvas work\n *       resolve();\n *     }))\n *   );\n * }\n * ```\n *\n * @example\n * Auto-dismiss a toast after 5 s (test-friendly)\n * ```ts\n * export function showToast(msg: string) {\n *   const toast = createToast(msg);\n *   document.body.appendChild(toast);\n *\n *   queueAsyncTask(() => toast.remove(), { delay: 5000 });\n * }\n * ```\n */\nexport const queueAsyncTask = <R = any>(callback: TaskCallback<R>, options?: { delay?: number }) => {\n  const task = new Task<R>(callback, options?.delay);\n\n  if (task.delay != null && task.delay > 0) {\n    ++pendingAsyncCount;\n    task._timerId = setTimeout(() => {\n      --pendingAsyncCount;\n      task._timerId = undefined;\n\n      if (task.status === tsCanceled) {\n        signalSettled(true);\n        return;\n      }\n\n      queue.push(task);\n      requestRun();\n    }, task.delay);\n  } else {\n    queue.push(task);\n    requestRun();\n  }\n\n  return task;\n};\n\nexport class TaskAbortError<T = any> extends Error {\n  public constructor(public task: Task<T>) {\n    super(`Task ${task.id} was canceled.`);\n  }\n}\n\n/**\n * A handle returned by {@link queueAsyncTask} that lets you observe and control\n * the life-cycle of a piece of scheduled work.\n *\n * Tasks move through **four immutable states**:\n *\n * | State      | Meaning | When it changes |\n * |------------|---------|-----------------|\n * | `\"pending\"`   | Waiting in the queue <br>(or in a `setTimeout` delay). | Immediately after creation. |\n * | `\"running\"`   | `callback` is executing. | When the scheduler dequeues the task. |\n * | `\"completed\"` | Callback (and any returned promise) settled. | After `callback` finishes / promise resolves. |\n * | `\"canceled\"`  | Task was aborted **or** callback/promise rejected. | When `cancel()` succeeds, or on error. |\n *\n * @template R Type of the value produced by the callback.\n */\nexport class Task<R = any> {\n  /** @internal */\n  private static _taskId = 0;\n  /**\n   * Unique, incrementing identifier  handy for logging / debugging.\n   */\n  public readonly id: number = ++Task._taskId;\n\n  /** @internal */\n  public _timerId?: number;\n\n  /** @internal */\n  private _resolve!: (value: Awaited<R>) => void;\n  /** @internal */\n  private _reject!: (reason?: any) => void;\n\n  /** @internal */\n  private readonly _result: Promise<Awaited<R>>;\n  /**\n   * A promise that:\n   * * **fulfils** with the callback's return value, or\n   * * **rejects** with:\n   *   * whatever error the callback throws,\n   *   * whatever rejection the callback's promise yields, or\n   *   * a {@link TaskAbortError} if the task is canceled before it starts.\n   *\n   * Consumers typically `await` this to know when *their* task is done without\n   * caring about unrelated work still queued.\n   *\n   * @example\n   * ```ts\n   * const toastTask = queueAsyncTask(showToast, { delay: 5000 });\n   * await toastTask.result; // waits 5 s then resolves\n   * ```\n   */\n  public get result(): Promise<Awaited<R>> {\n    return this._result;\n  }\n\n  /** @internal */\n  private _status: TaskStatus = tsPending;\n  /**\n   * Current immutable status of the task.\n   *\n   * @example\n   * ```ts\n   * const task = queueAsyncTask(() => 123);\n   * console.log(task.status); // \"pending\"\n   * await task.result;\n   * console.log(task.status); // \"completed\"\n   * ```\n   */\n  public get status(): TaskStatus {\n    return this._status;\n  }\n\n  public constructor(\n    public callback: TaskCallback<R>,\n    public delay?: number,\n  ) {\n    this._result = new Promise<Awaited<R>>((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n  }\n\n  /** @internal */\n  public run(): void {\n    if (this._status !== tsPending) {\n      throw new Error(`Cannot run task in ${this._status} state`);\n    }\n    this._status = tsRunning;\n    let ret: unknown;\n    try {\n      ret = this.callback();\n    } catch (err) {\n      this._status = tsCanceled;\n      this._reject(err);\n      taskErrors.push(err);\n      return;\n    }\n\n    if (ret instanceof Promise) {\n      ++pendingAsyncCount;\n      ret.then(result => {\n        this._status = tsCompleted;\n        this._resolve(result);\n      }).catch(err => {\n        this._status = tsCanceled;\n        this._reject(err);\n        taskErrors.push(err);\n      }).finally(() => {\n        --pendingAsyncCount;\n        signalSettled(true);\n      });\n    } else {\n      this._status = tsCompleted;\n      this._resolve(ret as Awaited<R>);\n    }\n  }\n\n  /**\n   * Attempt to cancel the task **before it runs**.\n   *\n   * * If the task is still `\"pending\"` **and**:\n   *   * waiting in a `setTimeout`  the timer is cleared.\n   *   * sitting in the queue      it is removed.\n   *   The task transitions to `\"canceled\"` and `result` rejects with\n   *   {@link TaskAbortError}.\n   * * If the task is already `\"running\"` or `\"completed\"` nothing happens.\n   *\n   * @returns `true` when the task was successfully canceled,\n   *          otherwise `false`.\n   *\n   * @example\n   * ```ts\n   * const t = queueAsyncTask(fetchData, { delay: 300 });\n   * // user typed again before the debounce expired\n   * if (t.cancel()) console.log('Previous fetch aborted');\n   * ```\n   */\n  public cancel(): boolean {\n    if (this._timerId !== undefined) {\n      clearTimeout(this._timerId);\n      --pendingAsyncCount;\n      this._timerId = undefined;\n      this._status = tsCanceled;\n      const abortErr = new TaskAbortError(this);\n      this._reject(abortErr);\n      // Attach a noop-catch so the promise is immediately handled and the host never\n      // emits an `unhandledRejection` for a *normal* cancel.\n      //\n      // IMPORTANT \n      // - `cancel()` MUST ONLY reject with the `TaskAbortError` we just created.\n      //   Nothing else is allowed to flow through `_reject()` here.\n      // - If you ever change that invariant (e.g. forward another error or add\n      //   logging-failures), you **must** either:\n      //     1. push the new error into `taskErrors` so the scheduler's aggregator\n      //        surfaces it, or\n      //     2. replace this with a *selective* handler that re-throws anything that\n      //        isn't a TaskAbortError.\n      //   Failing to do so will silently swallow real errors in dev builds.\n      void this._result.catch(noop);\n      signalSettled(true);\n      return true;\n    }\n\n    if (this._status === tsPending) {\n      const idx = queue.indexOf(this);\n      if (idx > -1) {\n        queue.splice(idx, 1);\n        this._status = tsCanceled;\n        const abortErr = new TaskAbortError(this);\n        this._reject(abortErr);\n        void this._result.catch(noop);\n        signalSettled(true);\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n/**\n * Queue a callback to run **repeatedly** on a given interval, managed by\n * Aurelia's central scheduler.\n *\n * Unlike a one-off task from {@link queueAsyncTask}, this creates a persistent,\n * timer-based operation that continues until explicitly canceled. Each\n * execution of the callback is pushed onto the normal task queue, ensuring\n * it runs with the same timing and error-handling as other framework tasks.\n *\n * This is useful for polling or any periodic background work that needs to be\n * test-friendly and integrated with Aurelia's life-cycle.\n *\n * @param callback  - The function to execute on each interval. Any exception\n *                    it throws is captured and surfaced collectively via\n *                    `tasksSettled()` or `runTasks()` (after awaiting `task.next()`).\n * @param opts.interval  - The delay **in milliseconds** between the end of one\n *                         execution and the start of the next. Defaults to `0`.\n * @returns A {@link RecurringTask} handle that lets you `cancel()` the\n *                                  repetition or use `await task.next()` to wait for\n *                                  the next run.\n */\nexport const queueRecurringTask = (callback: TaskCallback, opts?: { interval?: number }) => {\n  const task = new RecurringTask(callback, Math.max(opts?.interval ?? 0, 0));\n  recurringTasks.push(task);\n  task._start();\n  return task;\n};\n\n/**\n * A handle returned by {@link queueRecurringTask} that lets you observe and\n * control a periodic, repeating task.\n *\n * Unlike a single-use {@link Task}, a `RecurringTask` does not have a status\n * or a final `result` promise. Instead, it continues to schedule itself on a\n * given interval until it is explicitly stopped.\n */\nexport class RecurringTask {\n  /** @internal */\n  private static _nextId = 0;\n  public readonly id: number = ++RecurringTask._nextId;\n\n  /** @internal */\n  private _timerId?: number;\n  /** @internal */\n  private _canceled = false;\n  /** @internal */\n  private readonly _nextResolvers: (() => void)[] = [];\n\n  public constructor(\n    private readonly _callback: () => unknown,\n    private readonly _interval: number,\n  ) {}\n\n  /** @internal */\n  public run(): void {\n    try {\n      // TODO: possibly store return value to connect to resolver\n      this._callback();\n    } catch (err) {\n      taskErrors.push(err);\n      return;\n    }\n  }\n\n  /** @internal */\n  public _start(): void {\n    if (this._canceled) {\n      return;\n    }\n\n    this._timerId = setTimeout(() => {\n      this._tick();\n      if (!this._canceled) {\n        this._start();\n      }\n    }, this._interval);\n  }\n\n  /** @internal */\n  private _tick(): void {\n    queue.push(this);\n    requestRun();\n\n    const resolvers = this._nextResolvers.splice(0);\n    for (const resolver of resolvers) {\n      resolver();\n    }\n  }\n\n  /**\n   * Returns a promise that resolves after the next time the task's callback\n   * is queued for execution.\n   *\n   * This is useful for synchronizing other work with the task's interval,\n   * especially in tests. If the task has already been canceled, it returns an\n   * immediately-resolved promise.\n   *\n   * @returns A promise that resolves when the next interval occurs.\n   *\n   * @example\n   * Synchronizing with a polling task in a test\n   * ```ts\n   * it('updates data on a polling interval', async () => {\n   *   let count = 0;\n   *   const poller = queueRecurringTask(() => count++, { interval: 100 });\n   *\n   *   await poller.next();\n   *   await tasksSettled();\n   *   expect(count).toBe(1);\n   *\n   *   await poller.next();\n   *   await tasksSettled();\n   *   expect(count).toBe(2);\n   *\n   *   poller.cancel();\n   * });\n   * ```\n   */\n  public next(): Promise<void> {\n    if (this._canceled) {\n      return Promise.resolve();\n    }\n    return new Promise(resolve => this._nextResolvers.push(resolve));\n  }\n\n  /**\n   * Permanently stops the recurring task.\n   *\n   * This action clears any pending timer, prevents future executions, removes\n   * the task from the scheduler's list of recurring tasks, and immediately\n   * resolves any pending promises created by `next()`.\n   *\n   * Once canceled, a recurring task cannot be restarted.\n   */\n  public cancel(): void {\n    this._canceled = true;\n    if (this._timerId !== undefined) {\n      clearTimeout(this._timerId);\n      this._timerId = undefined;\n    }\n\n    const idx = recurringTasks.indexOf(this);\n    if (idx > -1) {\n      recurringTasks.splice(idx, 1);\n    }\n\n    const resolvers = this._nextResolvers.splice(0);\n    for (const resolve of resolvers) {\n      resolve();\n    }\n  }\n}\n", "import { DI, IIndexable, isArray } from '@aurelia/kernel';\nimport { rtObjectFreeze } from './utilities';\n\nimport type { CollectionLengthObserver, CollectionSizeObserver } from './collection-length-observer';\n\nexport const ICoercionConfiguration = /*@__PURE__*/DI.createInterface<ICoercionConfiguration>('ICoercionConfiguration');\nexport interface ICoercionConfiguration {\n  /** When set to `true`, enables the automatic type-coercion for bindables globally. */\n  enableCoercion: boolean;\n  /** When set to `true`, coerces the `null` and `undefined` values to the target types. This is ineffective when `disableCoercion` is set to `true.` */\n  coerceNullish: boolean;\n}\n\nexport type InterceptorFunc<TInput = unknown, TOutput = unknown> = (value: TInput, coercionConfig?: ICoercionConfiguration) => TOutput;\n\nexport interface IConnectable {\n  observe(obj: object, key: PropertyKey): void;\n  observeCollection(obj: Collection): void;\n  subscribeTo(subscribable: ISubscribable | ICollectionSubscribable): void;\n}\n\nexport interface IDirtySubscriber {\n  handleDirty(): void;\n}\n\n/**\n * Interface of a subscriber or property change handler\n */\nexport interface ISubscriber<TValue = unknown> extends Partial<IDirtySubscriber> {\n  handleChange(newValue: TValue, previousValue: TValue): void;\n}\n\n/**\n * Interface of a collection subscriber or mutation handler\n */\nexport interface ICollectionSubscriber {\n  handleCollectionChange(collection: Collection, indexMap: IndexMap): void;\n}\n\nexport interface ISubscribable<T = ISubscriber> {\n  subscribe(subscriber: T): void;\n  unsubscribe(subscriber: T): void;\n}\n\nexport interface ICollectionSubscribable {\n  subscribe(subscriber: ICollectionSubscriber): void;\n  unsubscribe(subscriber: ICollectionSubscriber): void;\n}\n\n/**\n * An interface describing the contract of a subscriber list,\n * with the ability to propagate values to those subscribers\n */\nexport interface ISubscriberRecord<T extends ISubscriber | ICollectionSubscriber> {\n  readonly count: number;\n  add(subscriber: T): boolean;\n  remove(subscriber: T): boolean;\n  notify(value: unknown, oldValue: unknown): void;\n  notifyCollection(collection: Collection, indexMap: IndexMap): void;\n  notifyDirty(): void;\n}\n\n/**\n * An internal interface describing the implementation of a ISubscribable of Aurelia that supports batching\n *\n * This is usually mixed into a class via the import `subscriberCollection` import from Aurelia.\n * The `subscriberCollection` import can be used as either a decorator, or a function call.\n */\nexport interface ISubscriberCollection extends ISubscribable {\n  /**\n   * The backing subscriber record for all subscriber methods of this collection\n   */\n  readonly subs: ISubscriberRecord<ISubscriber>;\n}\n\n/**\n * An internal interface describing the implementation of a ICollectionSubscribable of Aurelia that supports batching\n *\n * This is usually mixed into a class via the import `subscriberCollection` import from Aurelia.\n * The `subscriberCollection` import can be used as either a decorator, or a function call.\n */\nexport interface ICollectionSubscriberCollection extends ICollectionSubscribable {\n  /**\n   * The backing subscriber record for all subscriber methods of this collection\n   */\n  readonly subs: ISubscriberRecord<ICollectionSubscriber>;\n}\n\n/**\n * A collection (array, set or map)\n */\nexport type Collection = unknown[] | Set<unknown> | Map<unknown, unknown>;\n\nexport type CollectionKind = 'indexed' | 'keyed' | 'array' | 'map' | 'set';\n\nexport type LengthPropertyName<T> =\n  T extends unknown[] ? 'length' :\n    T extends Set<unknown> ? 'size' :\n      T extends Map<unknown, unknown> ? 'size' :\n        never;\n\nexport type CollectionKindToType<T> =\n  T extends 'array' ? unknown[] :\n    T extends 'indexed' ? unknown[] :\n      T extends 'map' ? Map<unknown, unknown> :\n        T extends 'set' ? Set<unknown> :\n          T extends 'keyed' ? Set<unknown> | Map<unknown, unknown> :\n            never;\n\nexport type ObservedCollectionKindToType<T> =\n  T extends 'array' ? unknown[] :\n    T extends 'indexed' ? unknown[] :\n      T extends 'map' ? Map<unknown, unknown> :\n        T extends 'set' ? Set<unknown> :\n          T extends 'keyed' ? Map<unknown, unknown> | Set<unknown> :\n            never;\n\n/** @internal */ export const atNone     = 0b0_000_000;\n/** @internal */ export const atObserver = 0b0_000_001;\n/** @internal */ export const atNode     = 0b0_000_010;\n/** @internal */ export const atLayout   = 0b0_000_100;\nexport const AccessorType = /*@__PURE__*/rtObjectFreeze({\n  None      : atNone,\n  Observer  : atObserver,\n  Node      : atNode,\n  // misc characteristic of accessors/observers when update\n  //\n  // by default, everything is synchronous\n  // except changes that are supposed to cause reflow/heavy computation\n  // an observer can use this flag to signal binding that don't carelessly tell it to update\n  // queue it instead\n  // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n  // todo: https://csstriggers.com/\n  Layout    : atLayout,\n} as const);\nexport type AccessorType = typeof AccessorType[keyof typeof AccessorType];\n/**\n * Basic interface to normalize getting/setting a value of any property on any object\n */\nexport interface IAccessor<TValue = unknown> {\n  type: AccessorType;\n  getValue(obj?: object, key?: PropertyKey): TValue;\n  setValue(newValue: TValue, obj?: object, key?: PropertyKey): void;\n}\n\n/**\n * An interface describing a standard contract of an observer in Aurelia binding & observation system\n */\nexport interface IObserver<TValue = unknown> extends IAccessor<TValue>, ISubscribable {\n  doNotCache?: boolean;\n  useCallback?(callback: (newValue: TValue, oldValue: TValue) => void): boolean;\n  useCoercer?(coercer: InterceptorFunc, coercionConfig?: ICoercionConfiguration): boolean;\n}\n\nexport type AccessorOrObserver = (IAccessor | IObserver) & {\n  doNotCache?: boolean;\n};\n\n/**\n * An array of indices, where the index of an element represents the index to map FROM, and the numeric value of the element itself represents the index to map TO\n *\n * The deletedIndices property contains the items (in case of an array) or keys (in case of map or set) that have been deleted.\n */\n export type IndexMap<T = unknown> = number[] & {\n  deletedIndices: number[];\n  deletedItems: T[];\n  isIndexMap: true;\n};\n\nexport const hasChanges = (indexMap: IndexMap) => {\n  if (indexMap.deletedIndices.length > 0) {\n    return true;\n  }\n\n  for (let i = 0; i < indexMap.length; ++i) {\n    if (indexMap[i] !== i) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport function copyIndexMap<T = unknown>(\n  existing: number[] & { deletedIndices?: number[]; deletedItems?: T[] },\n  deletedIndices?: number[],\n  deletedItems?: T[],\n): IndexMap {\n  const { length } = existing;\n  const arr = Array(length) as IndexMap;\n  let i = 0;\n  while (i < length) {\n    arr[i] = existing[i];\n    ++i;\n  }\n  if (deletedIndices !== void 0) {\n    arr.deletedIndices = deletedIndices.slice(0);\n  } else if (existing.deletedIndices !== void 0) {\n    arr.deletedIndices = existing.deletedIndices.slice(0);\n  } else {\n    arr.deletedIndices = [];\n  }\n  if (deletedItems !== void 0) {\n    arr.deletedItems = deletedItems.slice(0);\n  } else if (existing.deletedItems !== void 0) {\n    arr.deletedItems = existing.deletedItems.slice(0);\n  } else {\n    arr.deletedItems = [];\n  }\n  arr.isIndexMap = true;\n  return arr;\n}\n\nexport function createIndexMap(length: number = 0): IndexMap {\n  const arr = Array(length) as IndexMap;\n  let i = 0;\n  while (i < length) {\n    arr[i] = i++;\n  }\n  arr.deletedIndices = [];\n  arr.deletedItems = [];\n  arr.isIndexMap = true;\n  return arr;\n}\n\nexport function cloneIndexMap(indexMap: IndexMap): IndexMap {\n  const clone = indexMap.slice() as IndexMap;\n  clone.deletedIndices = indexMap.deletedIndices.slice();\n  clone.deletedItems = indexMap.deletedItems.slice();\n  clone.isIndexMap = true;\n  return clone;\n}\n\nexport function isIndexMap(value: unknown): value is IndexMap {\n  return isArray(value) && (value as IndexMap).isIndexMap === true;\n}\n/**\n * Describes a type that specifically tracks changes in a collection (map, set or array)\n */\nexport interface ICollectionChangeTracker<T extends Collection> {\n  collection: T;\n  indexMap: IndexMap;\n}\n\n/**\n * An observer that tracks collection mutations and notifies subscribers (either directly or in batches)\n */\nexport interface ICollectionObserver<T extends CollectionKind> extends\n  ICollectionChangeTracker<CollectionKindToType<T>>,\n  ICollectionSubscribable {\n  type: AccessorType;\n  collection: ObservedCollectionKindToType<T>;\n  getLengthObserver(): T extends 'array' ? CollectionLengthObserver : CollectionSizeObserver;\n  notify(): void;\n}\nexport type CollectionObserver = ICollectionObserver<CollectionKind>;\n\nexport type IObservable<T = IIndexable> = T & {\n  $observers?: IIndexable<{}, AccessorOrObserver>;\n};\n", "import {\n  type ISubscriberRecord,\n  type ICollectionSubscriber,\n  type IndexMap,\n  type Collection,\n} from './interfaces';\nimport type { IAnySubscriber } from './subscriber-collection';\n\ntype ValueBatchRecord = [\n  1,\n  unknown, // oldValue\n  unknown, // newValue\n];\ntype CollectionBatchRecord = [\n  2,\n  Collection,\n  IndexMap,\n];\ntype BatchRecord = ValueBatchRecord | CollectionBatchRecord;\ntype Batch = Map<ISubscriberRecord<IAnySubscriber>, BatchRecord>;\n\nlet currBatch: Batch | null = new Map();\n// eslint-disable-next-line import/no-mutable-exports\nexport let batching = false;\n\nexport function batch(fn: () => unknown): void {\n  const prevBatch = currBatch;\n  const newBatch: Batch = currBatch = new Map();\n  batching = true;\n  try {\n    fn();\n  } finally {\n    currBatch = null;\n    batching = false;\n    try {\n      let pair: [ISubscriberRecord<IAnySubscriber>, BatchRecord];\n      let subs: ISubscriberRecord<IAnySubscriber>;\n      let batchRecord: BatchRecord;\n      let col: Collection;\n      let indexMap: IndexMap;\n      let hasChanges = false;\n      let i: number;\n      let ii: number;\n      for (pair of newBatch) {\n        subs = pair[0];\n        batchRecord = pair[1];\n        if (prevBatch?.has(subs)) {\n          prevBatch.set(subs, batchRecord);\n        }\n        if (batchRecord[0] === 1) {\n          subs.notify(batchRecord[1], batchRecord[2]);\n        } else {\n          col = batchRecord[1];\n          indexMap = batchRecord[2];\n          hasChanges = false;\n          if (indexMap.deletedIndices.length > 0) {\n            hasChanges = true;\n          } else {\n            for (i = 0, ii = indexMap.length; i < ii; ++i) {\n              if (indexMap[i] !== i) {\n                hasChanges = true;\n                break;\n              }\n            }\n          }\n          if (hasChanges) {\n            subs.notifyCollection(col, indexMap);\n          }\n        }\n      }\n    } finally {\n      currBatch = prevBatch;\n    }\n  }\n}\n\nexport function addCollectionBatch(\n  subs: ISubscriberRecord<ICollectionSubscriber>,\n  collection: Collection,\n  indexMap: IndexMap,\n) {\n  if (!currBatch!.has(subs)) {\n    currBatch!.set(subs, [2, collection, indexMap]);\n  } else {\n    currBatch!.get(subs)![2] = indexMap;\n  }\n}\n\nexport function addValueBatch(\n  subs: ISubscriberRecord<IAnySubscriber>,\n  newValue: unknown,\n  oldValue: unknown,\n) {\n  const batchRecord = currBatch!.get(subs);\n  if (batchRecord === void 0) {\n    currBatch!.set(subs, [1, newValue, oldValue]);\n  } else {\n    batchRecord[1] = newValue;\n    batchRecord[2] = oldValue;\n  }\n}\n", "import { rtDef, rtDefineHiddenProp, ensureProto } from './utilities';\n\nimport type {\n  Collection,\n  ICollectionSubscriber,\n  IDirtySubscriber,\n  IndexMap,\n  ISubscriber,\n  ISubscriberCollection,\n  ISubscriberRecord,\n} from './interfaces';\nimport { addValueBatch, batching } from './subscriber-batch';\nimport { Class, Constructable } from '@aurelia/kernel';\n\nexport type IAnySubscriber = ISubscriber | ICollectionSubscriber;\n\nexport const subscriberCollection = /*@__PURE__*/(() => {\n\n  function subscriberCollection(): <T extends Constructable>(value: T, context: ClassDecoratorContext) => T;\n  function subscriberCollection<T extends Constructable>(target: T, context: ClassDecoratorContext): T;\n  function subscriberCollection<T extends Constructable>(target?: T, context?: ClassDecoratorContext<T>): ((value: T, context: ClassDecoratorContext) => T) | T {\n    return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target, context!);\n  }\n\n  function getSubscriberRecord(this: ISubscriberCollection) {\n    return rtDefineHiddenProp(this, 'subs', new SubscriberRecord());\n  }\n\n  function addSubscriber(this: ISubscriberCollection, subscriber: IAnySubscriber): boolean {\n    return this.subs.add(subscriber as ISubscriber & ICollectionSubscriber);\n  }\n\n  function removeSubscriber(this: ISubscriberCollection, subscriber: IAnySubscriber): boolean {\n    return this.subs.remove(subscriber as ISubscriber & ICollectionSubscriber);\n  }\n\n  const decoratedTarget = new WeakSet<Constructable>();\n  function subscriberCollectionDeco<TObj extends object, T extends Class<TObj>>(target: T, context: ClassDecoratorContext): T { // ClassDecorator expects it to be derived from Function\n    if (!decoratedTarget.has(target)) {\n      decoratedTarget.add(target);\n      const proto = target.prototype as ISubscriberCollection;\n      // not configurable, as in devtool, the getter could be invoked on the prototype,\n      // and become permanently broken\n      rtDef(proto, 'subs', { get: getSubscriberRecord });\n\n      ensureProto(proto, 'subscribe', addSubscriber);\n      ensureProto(proto, 'unsubscribe', removeSubscriber);\n    }\n\n    return target;\n  }\n\n  class SubscriberRecord<T extends IAnySubscriber> implements ISubscriberRecord<T> {\n    public count: number = 0;\n    /** @internal */\n    private readonly _subs: T[] = [];\n    /** @internal */\n    private readonly _requestDirtySubs: IDirtySubscriber[] = [];\n    /** @internal */\n    private _hasDirtySubs = false;\n\n    public add(subscriber: T): boolean {\n      if (this._subs.includes(subscriber)) {\n        return false;\n      }\n      this._subs[this._subs.length] = subscriber;\n      if ('handleDirty' in subscriber) {\n        this._requestDirtySubs[this._requestDirtySubs.length] = subscriber as IDirtySubscriber;\n        this._hasDirtySubs = true;\n      }\n      ++this.count;\n      return true;\n    }\n\n    public remove(subscriber: T): boolean {\n      let idx = this._subs.indexOf(subscriber);\n      if (idx !== -1) {\n        this._subs.splice(idx, 1);\n        idx = this._requestDirtySubs.indexOf(subscriber as IDirtySubscriber);\n        if (idx !== -1) {\n          this._requestDirtySubs.splice(idx, 1);\n          this._hasDirtySubs = this._requestDirtySubs.length > 0;\n        }\n        --this.count;\n        return true;\n      }\n      return false;\n    }\n\n    public notify(val: unknown, oldVal: unknown): void {\n      if (batching) {\n        addValueBatch(this, val, oldVal);\n        return;\n      }\n\n      /**\n       * Note: change handlers may have the side-effect of adding/removing subscribers to this collection during this\n       * callSubscribers invocation, so we're caching them all before invoking any.\n       * Subscribers added during this invocation are not invoked (and they shouldn't be).\n       * Subscribers removed during this invocation will still be invoked (and they also shouldn't be,\n       * however this is accounted for via $isBound and similar flags on the subscriber objects)\n       */\n      for (const sub of this._subs.slice(0) as ISubscriber[]) {\n        sub.handleChange(val, oldVal);\n      }\n    }\n\n    public notifyCollection(collection: Collection, indexMap: IndexMap): void {\n      const _subs = this._subs.slice(0) as ICollectionSubscriber[];\n      const len = _subs.length;\n      let i = 0;\n      for (; i < len; ++i) {\n        _subs[i].handleCollectionChange(collection, indexMap);\n      }\n      return;\n    }\n\n    public notifyDirty() {\n      if (this._hasDirtySubs) {\n        for (const dirtySub of this._requestDirtySubs.slice(0)) {\n          dirtySub.handleDirty();\n        }\n      }\n    }\n  }\n\n  return subscriberCollection;\n})();\n", "import { Collection, IObserver, atObserver } from './interfaces';\nimport { subscriberCollection } from './subscriber-collection';\nimport { ensureProto } from './utilities';\n\nimport type { Constructable } from '@aurelia/kernel';\nimport type {\n  AccessorType,\n  ICollectionObserver,\n  IndexMap,\n  ISubscriber,\n  ISubscriberCollection,\n  ICollectionSubscriber,\n  CollectionKind,\n} from './interfaces';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface CollectionLengthObserver extends ISubscriberCollection {}\n\nexport class CollectionLengthObserver implements IObserver, ICollectionSubscriber {\n  static {\n    implementLengthObserver(CollectionLengthObserver);\n  }\n\n  public readonly type: AccessorType = atObserver;\n\n  /** @internal */\n  private _value: number;\n\n  /** @internal */\n  private readonly _obj: unknown[];\n\n  public constructor(\n    public readonly owner: ICollectionObserver<'array'>,\n  ) {\n    this._value = (this._obj = owner.collection).length;\n  }\n\n  public getValue(): number {\n    return this._obj.length;\n  }\n\n  public setValue(newValue: number): void {\n    // if in the template, length is two-way bound directly\n    // then there's a chance that the new value is invalid\n    // add a guard so that we don't accidentally broadcast invalid values\n    if (newValue !== this._value) {\n      if (!Number.isNaN(newValue)) {\n        this._obj.splice(newValue);\n        this._value = this._obj.length;\n        // todo: maybe use splice so that it'll notify everything properly\n        // this._obj.length = newValue;\n        // this.subs.notify(newValue, currentValue);\n      } else if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`Invalid value \"${newValue}\" for array length`);\n      }\n    }\n  }\n\n  public handleDirty() {\n    if (this._value !== this._obj.length) {\n      this.subs.notifyDirty();\n    }\n  }\n\n  public handleCollectionChange(_arr: unknown[], _: IndexMap) {\n    const oldValue = this._value;\n    const value = this._obj.length;\n    if ((this._value = value) !== oldValue) {\n      this.subs.notifyDirty();\n      this.subs.notify(this._value, oldValue);\n    }\n  }\n}\n\nexport interface CollectionSizeObserver extends ISubscriberCollection {}\n\nexport class CollectionSizeObserver implements ICollectionSubscriber {\n  static {\n    implementLengthObserver(CollectionSizeObserver);\n  }\n\n  public readonly type: AccessorType = atObserver;\n\n  /** @internal */\n  private _value: number;\n\n  /** @internal */\n  private readonly _obj: Set<unknown> | Map<unknown, unknown>;\n\n  public constructor(\n    public readonly owner: ICollectionObserver<'map' | 'set'>,\n  ) {\n    this._value = (this._obj = owner.collection).size;\n  }\n\n  public getValue(): number {\n    return this._obj.size;\n  }\n\n  public setValue(): void {\n    throw createMappedError(ErrorNames.assign_readonly_size);\n  }\n\n  public handleDirty() {\n    if (this._value !== this._obj.size) {\n      this.subs.notifyDirty();\n    }\n  }\n\n  public handleCollectionChange(_collection: Collection,  _: IndexMap): void {\n    const oldValue = this._value;\n    const value = this._obj.size;\n    if ((this._value = value) !== oldValue) {\n      this.subs.notify(this._value, oldValue);\n    }\n  }\n}\n\ninterface CollectionLengthObserverImpl extends ISubscriberCollection, ICollectionSubscriber {\n  owner: ICollectionObserver<CollectionKind>;\n}\n\nfunction implementLengthObserver(klass: Constructable<ISubscriberCollection>) {\n  const proto = klass.prototype as ISubscriberCollection;\n  ensureProto(proto, 'subscribe', subscribe);\n  ensureProto(proto, 'unsubscribe', unsubscribe);\n  return subscriberCollection(klass, null!);\n}\n\nfunction subscribe(this: CollectionLengthObserverImpl, subscriber: ISubscriber): void {\n  if (this.subs.add(subscriber) && this.subs.count === 1) {\n    this.owner.subscribe(this);\n  }\n}\n\nfunction unsubscribe(this: CollectionLengthObserverImpl, subscriber: ISubscriber): void {\n  if (this.subs.remove(subscriber) && this.subs.count === 0) {\n    this.owner.subscribe(this);\n  }\n}\n", "import {\n  createIndexMap,\n  type AccessorType,\n  type ISubscriberCollection,\n  type ICollectionSubscriberCollection,\n  type IObserver,\n  type ICollectionObserver,\n  type IndexMap,\n  type ISubscriber,\n  atObserver,\n} from './interfaces';\nimport {\n  CollectionLengthObserver,\n} from './collection-length-observer';\nimport {\n  subscriberCollection,\n} from './subscriber-collection';\nimport { rtDef, rtDefineHiddenProp, rtDefineMetadata, rtGetMetadata } from './utilities';\nimport { addCollectionBatch, batching } from './subscriber-batch';\nimport { type IIndexable, isFunction } from '@aurelia/kernel';\n\nexport interface ArrayObserver extends ICollectionObserver<'array'>, ICollectionSubscriberCollection {\n  getIndexObserver(index: number): ArrayIndexObserver;\n}\n\nexport interface ArrayIndexObserver extends IObserver, ISubscriberCollection {\n  readonly owner: ICollectionObserver<'array'>;\n}\n\nexport const getArrayObserver = /*@__PURE__*/ (() => {\n\n  // multiple applications of Aurelia wouldn't have different observers for the same Array object\n  const lookupMetadataKey = Symbol.for('__au_arr_obs__');\n  const observerLookup = ((Array as IIndexable<typeof Array>)[lookupMetadataKey]\n    ?? rtDefineHiddenProp(Array, lookupMetadataKey, new WeakMap())\n  ) as WeakMap<unknown[], ArrayObserverImpl>;\n\n  // https://tc39.github.io/ecma262/#sec-sortcompare\n  function sortCompare(x: unknown, y: unknown): number {\n    if (x === y) {\n      return 0;\n    }\n    x = x === null ? 'null' : (x as {}).toString();\n    y = y === null ? 'null' : (y as {}).toString();\n    return (x as {}) < (y as {}) ? -1 : 1;\n  }\n\n  function preSortCompare(x: unknown, y: unknown): number {\n    if (x === void 0) {\n      if (y === void 0) {\n        return 0;\n      } else {\n        return 1;\n      }\n    }\n    if (y === void 0) {\n      return -1;\n    }\n    return 0;\n  }\n\n  function insertionSort(arr: unknown[], indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n    let velement, ielement, vtmp, itmp, order;\n    let i, j;\n    for (i = from + 1; i < to; i++) {\n      velement = arr[i];\n      ielement = indexMap[i];\n      for (j = i - 1; j >= from; j--) {\n        vtmp = arr[j];\n        itmp = indexMap[j];\n        order = compareFn(vtmp, velement);\n        if (order > 0) {\n          arr[j + 1] = vtmp;\n          indexMap[j + 1] = itmp;\n        } else {\n          break;\n        }\n      }\n      arr[j + 1] = velement;\n      indexMap[j + 1] = ielement;\n    }\n  }\n\n  function quickSort(arr: unknown[], indexMap: IndexMap, from: number, to: number, compareFn: (a: unknown, b: unknown) => number): void {\n    let thirdIndex = 0, i = 0;\n    let v0, v1, v2;\n    let i0, i1, i2;\n    let c01, c02, c12;\n    let vtmp, itmp;\n    let vpivot, ipivot, lowEnd, highStart;\n    let velement, ielement, order, vtopElement;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (to - from <= 10) {\n        insertionSort(arr, indexMap, from, to, compareFn);\n        return;\n      }\n\n      thirdIndex = from + ((to - from) >> 1);\n      v0 = arr[from]; i0 = indexMap[from];\n      v1 = arr[to - 1]; i1 = indexMap[to - 1];\n      v2 = arr[thirdIndex]; i2 = indexMap[thirdIndex];\n      c01 = compareFn(v0, v1);\n      if (c01 > 0) {\n        vtmp = v0; itmp = i0;\n        v0 = v1; i0 = i1;\n        v1 = vtmp; i1 = itmp;\n      }\n      c02 = compareFn(v0, v2);\n      if (c02 >= 0) {\n        vtmp = v0; itmp = i0;\n        v0 = v2; i0 = i2;\n        v2 = v1; i2 = i1;\n        v1 = vtmp; i1 = itmp;\n      } else {\n        c12 = compareFn(v1, v2);\n        if (c12 > 0) {\n          vtmp = v1; itmp = i1;\n          v1 = v2; i1 = i2;\n          v2 = vtmp; i2 = itmp;\n        }\n      }\n      arr[from] = v0; indexMap[from] = i0;\n      arr[to - 1] = v2; indexMap[to - 1] = i2;\n      vpivot = v1; ipivot = i1;\n      lowEnd = from + 1;\n      highStart = to - 1;\n      arr[thirdIndex] = arr[lowEnd]; indexMap[thirdIndex] = indexMap[lowEnd];\n      arr[lowEnd] = vpivot; indexMap[lowEnd] = ipivot;\n\n      partition: for (i = lowEnd + 1; i < highStart; i++) {\n        velement = arr[i]; ielement = indexMap[i];\n        order = compareFn(velement, vpivot);\n        if (order < 0) {\n          arr[i] = arr[lowEnd]; indexMap[i] = indexMap[lowEnd];\n          arr[lowEnd] = velement; indexMap[lowEnd] = ielement;\n          lowEnd++;\n        } else if (order > 0) {\n          do {\n            highStart--;\n            // eslint-disable-next-line eqeqeq\n            if (highStart == i) {\n              break partition;\n            }\n            vtopElement = arr[highStart]; order = compareFn(vtopElement, vpivot);\n          } while (order > 0);\n          arr[i] = arr[highStart]; indexMap[i] = indexMap[highStart];\n          arr[highStart] = velement; indexMap[highStart] = ielement;\n          if (order < 0) {\n            velement = arr[i]; ielement = indexMap[i];\n            arr[i] = arr[lowEnd]; indexMap[i] = indexMap[lowEnd];\n            arr[lowEnd] = velement; indexMap[lowEnd] = ielement;\n            lowEnd++;\n          }\n        }\n      }\n\n      if (to - highStart < lowEnd - from) {\n        quickSort(arr, indexMap, highStart, to, compareFn);\n        to = lowEnd;\n      } else {\n        quickSort(arr, indexMap, from, lowEnd, compareFn);\n        from = highStart;\n      }\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const proto = Array.prototype as { [K in keyof any[]]: any[][K] & { observing?: boolean } };\n  const methods: ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'] = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'];\n  let observe: undefined | Pick<typeof proto, typeof methods[number]>;\n  // let native: undefined | Pick<typeof proto, typeof methods[number]>;\n\n  function overrideArrayPrototypes() {\n    const $push = proto.push;\n    const $unshift = proto.unshift;\n    const $pop = proto.pop;\n    const $shift = proto.shift;\n    const $splice = proto.splice;\n    const $reverse = proto.reverse;\n    const $sort = proto.sort;\n\n    // native = { push: $push, unshift: $unshift, pop: $pop, shift: $shift, splice: $splice, reverse: $reverse, sort: $sort };\n\n    observe = {\n      // https://tc39.github.io/ecma262/#sec-array.prototype.push\n      push: function (this: unknown[], ...args: unknown[]): ReturnType<typeof Array.prototype.push> {\n        const o = observerLookup.get(this);\n        if (o === void 0) {\n          return $push.apply(this, args);\n        }\n        const len = this.length;\n        const argCount = args.length;\n        if (argCount === 0) {\n          return len;\n        }\n        this.length = o.indexMap.length = len + argCount;\n        let i = len;\n        while (i < this.length) {\n          this[i] = args[i - len];\n          o.indexMap[i] = - 2;\n          i++;\n        }\n        o.notify();\n        return this.length;\n      },\n      // https://tc39.github.io/ecma262/#sec-array.prototype.unshift\n      unshift: function (this: unknown[], ...args: unknown[]): ReturnType<typeof Array.prototype.unshift> {\n        const o = observerLookup.get(this);\n        if (o === void 0) {\n          return $unshift.apply(this, args);\n        }\n        const argCount = args.length;\n        const inserts = new Array(argCount);\n        let i = 0;\n        while (i < argCount) {\n          inserts[i++] = - 2;\n        }\n        $unshift.apply(o.indexMap, inserts);\n        const len = $unshift.apply(this, args);\n        o.notify();\n        return len;\n      },\n      // https://tc39.github.io/ecma262/#sec-array.prototype.pop\n      pop: function (this: unknown[]): ReturnType<typeof Array.prototype.pop> {\n        const o = observerLookup.get(this);\n        if (o === void 0) {\n          return $pop.call(this);\n        }\n        const indexMap = o.indexMap;\n        const element = $pop.call(this);\n        // only mark indices as deleted if they actually existed in the original array\n        const index = indexMap.length - 1;\n        if (indexMap[index] > -1) {\n          indexMap.deletedIndices.push(indexMap[index]);\n          indexMap.deletedItems.push(element);\n        }\n        $pop.call(indexMap);\n        o.notify();\n        return element;\n      },\n      // https://tc39.github.io/ecma262/#sec-array.prototype.shift\n      shift: function (this: unknown[]): ReturnType<typeof Array.prototype.shift> {\n        const o = observerLookup.get(this);\n        if (o === void 0) {\n          return $shift.call(this);\n        }\n        const indexMap = o.indexMap;\n        const element = $shift.call(this);\n        // only mark indices as deleted if they actually existed in the original array\n        if (indexMap[0] > -1) {\n          indexMap.deletedIndices.push(indexMap[0]);\n          indexMap.deletedItems.push(element);\n        }\n        $shift.call(indexMap);\n        o.notify();\n        return element;\n      },\n      // https://tc39.github.io/ecma262/#sec-array.prototype.splice\n      splice: function (this: unknown[], ...args: [number, number, ...unknown[]]): ReturnType<typeof Array.prototype.splice> {\n        const start: number = args[0];\n        const deleteCount: number | undefined = args[1];\n        const o = observerLookup.get(this);\n        if (o === void 0) {\n          return $splice.apply(this, args);\n        }\n        const len = this.length;\n        const relativeStart = start | 0;\n        const actualStart = relativeStart < 0 ? Math.max((len + relativeStart), 0) : Math.min(relativeStart, len);\n        const indexMap = o.indexMap;\n        const argCount = args.length;\n        const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;\n        let i = actualStart;\n        if (actualDeleteCount > 0) {\n          const to = i + actualDeleteCount;\n          while (i < to) {\n            // only mark indices as deleted if they actually existed in the original array\n            if (indexMap[i] > -1) {\n              indexMap.deletedIndices.push(indexMap[i]);\n              indexMap.deletedItems.push(this[i]);\n            }\n            i++;\n          }\n        }\n        i = 0;\n        if (argCount > 2) {\n          const itemCount = argCount - 2;\n          const inserts = new Array(itemCount);\n          while (i < itemCount) {\n            inserts[i++] = - 2;\n          }\n          $splice.call(indexMap, start, deleteCount, ...inserts);\n        } else {\n          $splice.apply(indexMap, args);\n        }\n        const deleted = $splice.apply(this, args);\n        // only notify when there's deletion, or addition\n        if (actualDeleteCount > 0 || i > 0) {\n          o.notify();\n        }\n        return deleted;\n      },\n      // https://tc39.github.io/ecma262/#sec-array.prototype.reverse\n      reverse: function (this: unknown[]): ReturnType<typeof Array.prototype.reverse> {\n        const o = observerLookup.get(this);\n        if (o === void 0) {\n          $reverse.call(this);\n          return this;\n        }\n        const len = this.length;\n        const middle = (len / 2) | 0;\n        let lower = 0;\n        while (lower !== middle) {\n          const upper = len - lower - 1;\n          const lowerValue = this[lower]; const lowerIndex = o.indexMap[lower];\n          const upperValue = this[upper]; const upperIndex = o.indexMap[upper];\n          this[lower] = upperValue; o.indexMap[lower] = upperIndex;\n          this[upper] = lowerValue; o.indexMap[upper] = lowerIndex;\n          lower++;\n        }\n        o.notify();\n        return this;\n      },\n      // https://tc39.github.io/ecma262/#sec-array.prototype.sort\n      // https://github.com/v8/v8/blob/master/src/js/array.js\n      sort: function (this: unknown[], compareFn?: (a: unknown, b: unknown) => number): unknown[] {\n        const o = observerLookup.get(this);\n        if (o === void 0) {\n          $sort.call(this, compareFn);\n          return this;\n        }\n        let len = this.length;\n        if (len < 2) {\n          return this;\n        }\n        quickSort(this, o.indexMap, 0, len, preSortCompare);\n        let i = 0;\n        while (i < len) {\n          if (this[i] === void 0) {\n            break;\n          }\n          i++;\n        }\n        if (compareFn === void 0 || !isFunction(compareFn)/* spec says throw a TypeError, should we do that too? */) {\n          compareFn = sortCompare;\n        }\n        quickSort(this, o.indexMap, 0, i, compareFn);\n        // todo(fred): it shouldn't notify if the sort produce a stable array:\n        //             where every item has the same index before/after\n        //             though this is inefficient we loop a few times like this\n        let shouldNotify = false;\n        for (i = 0, len = o.indexMap.length; len > i; ++i) {\n          if (o.indexMap[i] !== i) {\n            shouldNotify = true;\n            break;\n          }\n        }\n        if (shouldNotify || batching) {\n          o.notify();\n        }\n        return this;\n      }\n    };\n\n    for (const method of methods) {\n      rtDef(observe[method], 'observing', { value: true });\n    }\n  }\n\n  let enableArrayObservationCalled = false;\n\n  const observationEnabledKey = '__au_arr_on__';\n\n  function enableArrayObservation(): void {\n    if (observe === undefined) {\n      overrideArrayPrototypes();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!(rtGetMetadata(observationEnabledKey, Array) ?? false)) {\n      rtDefineMetadata(true, Array, observationEnabledKey);\n      for (const method of methods) {\n        if (proto[method].observing !== true) {\n          rtDefineHiddenProp(proto, method, observe![method]);\n        }\n      }\n    }\n  }\n\n  // function disableArrayObservation(): void {\n  //   for (const method of methods) {\n  //     if (proto[method].observing === true) {\n  //       rtDefineHiddenProp(proto, method, native![method]);\n  //     }\n  //   }\n  // }\n\n  interface ArrayObserverImpl extends ICollectionObserver<'array'>, ICollectionSubscriberCollection { }\n\n  class ArrayObserverImpl {\n    static {\n      subscriberCollection(ArrayObserverImpl, null!);\n    }\n\n    public type: AccessorType = atObserver;\n\n    private readonly indexObservers: Record<string | number, ArrayIndexObserverImpl | undefined>;\n    private lenObs?: CollectionLengthObserver;\n\n    public constructor(array: unknown[]) {\n\n      if (!enableArrayObservationCalled) {\n        enableArrayObservationCalled = true;\n        enableArrayObservation();\n      }\n\n      this.indexObservers = {};\n\n      this.collection = array;\n      this.indexMap = createIndexMap(array.length);\n      this.lenObs = void 0;\n\n      observerLookup.set(array, this);\n    }\n\n    public notify(): void {\n      const subs = this.subs;\n      subs.notifyDirty();\n\n      const indexMap = this.indexMap;\n      if (batching) {\n        addCollectionBatch(subs, this.collection, indexMap);\n        return;\n      }\n\n      const arr = this.collection;\n      const length = arr.length;\n\n      this.indexMap = createIndexMap(length);\n      subs.notifyCollection(arr, indexMap);\n    }\n\n    public getLengthObserver(): CollectionLengthObserver {\n      return this.lenObs ??= new CollectionLengthObserver(this);\n    }\n\n    public getIndexObserver(index: number): ArrayIndexObserverImpl {\n      // It's unnecessary to destroy/recreate index observer all the time,\n      // so just create once, and add/remove instead\n      return this.indexObservers[index] ??= new ArrayIndexObserverImpl(this, index);\n    }\n  }\n\n  interface ArrayIndexObserverImpl extends ArrayIndexObserver, ISubscriberCollection { }\n\n  class ArrayIndexObserverImpl implements ArrayIndexObserver {\n    static {\n      subscriberCollection(ArrayIndexObserverImpl, null!);\n    }\n\n    public doNotCache: boolean = true;\n    public value: unknown;\n\n    public constructor(\n      public readonly owner: ArrayObserverImpl,\n      public readonly index: number\n    ) {\n      this.value = this.getValue();\n    }\n\n    public getValue(): unknown {\n      return this.owner.collection[this.index];\n    }\n\n    public setValue(newValue: unknown): void {\n      if (newValue === this.getValue()) {\n        return;\n      }\n      const arrayObserver = this.owner;\n      const index = this.index;\n      const indexMap = arrayObserver.indexMap;\n\n      if (indexMap[index] > -1) {\n        indexMap.deletedIndices.push(indexMap[index]);\n      }\n      indexMap[index] = -2;\n      // do not need to update current value here\n      // as it will be updated inside handle collection change\n      arrayObserver.collection[index] = newValue;\n      arrayObserver.notify();\n    }\n\n    public handleDirty() {\n      if (this.value !== this.getValue()) {\n        this.subs.notifyDirty();\n      }\n    }\n\n    /**\n     * From interface `ICollectionSubscriber`\n     */\n    public handleCollectionChange(_arr: unknown[], indexMap: IndexMap): void {\n      const index = this.index;\n      const noChange = indexMap[index] === index;\n      if (noChange) {\n        return;\n      }\n      const prevValue = this.value;\n      const currValue = this.value = this.getValue();\n      if (prevValue !== currValue) {\n        this.subs.notify(currValue, prevValue);\n      }\n    }\n\n    public subscribe(subscriber: ISubscriber): void {\n      if (this.subs.add(subscriber) && this.subs.count === 1) {\n        this.owner.subscribe(this);\n      }\n    }\n\n    public unsubscribe(subscriber: ISubscriber): void {\n      if (this.subs.remove(subscriber) && this.subs.count === 0) {\n        this.owner.unsubscribe(this);\n      }\n    }\n  }\n\n  return function getArrayObserver(array: unknown[]): ArrayObserver {\n    let observer = observerLookup.get(array);\n    if (observer === void 0) {\n      observerLookup.set(array, observer = new ArrayObserverImpl(array));\n      enableArrayObservation();\n    }\n    return observer;\n  };\n})();\n", "import { IIndexable } from '@aurelia/kernel';\nimport { CollectionSizeObserver } from './collection-length-observer';\nimport { atObserver, createIndexMap, type AccessorType, type ICollectionObserver, type ICollectionSubscriberCollection } from './interfaces';\nimport { addCollectionBatch, batching } from './subscriber-batch';\nimport { subscriberCollection } from './subscriber-collection';\nimport { rtDefineHiddenProp } from './utilities';\n\nexport interface SetObserver extends ICollectionObserver<'set'>, ICollectionSubscriberCollection { }\n\nexport const getSetObserver = /*@__PURE__*/ (() => {\n  // multiple applications of Aurelia wouldn't have different observers for the same Set object\n  const lookupMetadataKey = Symbol.for('__au_set_obs__');\n  const observerLookup = ((Set as IIndexable<typeof Set>)[lookupMetadataKey]\n    ?? rtDefineHiddenProp(Set, lookupMetadataKey, new WeakMap())\n  ) as WeakMap<Set<unknown>, SetObserverImpl>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const { add: $add, clear: $clear, delete: $delete } = Set.prototype as { [K in keyof Set<any>]: Set<any>[K] & { observing?: boolean } };\n\n  const methods: ['add', 'clear', 'delete'] = ['add', 'clear', 'delete'];\n\n  // note: we can't really do much with Set due to the internal data structure not being accessible so we're just using the native calls\n  // fortunately, add/delete/clear are easy to reconstruct for the indexMap\n\n  const observe = {\n    // https://tc39.github.io/ecma262/#sec-set.prototype.add\n    add: function (this: Set<unknown>, value: unknown): ReturnType<typeof $add> {\n      const o = observerLookup.get(this);\n      if (o === undefined) {\n        $add.call(this, value);\n        return this;\n      }\n      const oldSize = this.size;\n      $add.call(this, value);\n      const newSize = this.size;\n      if (newSize === oldSize) {\n        return this;\n      }\n      o.indexMap[oldSize] = -2;\n      o.notify();\n      return this;\n    },\n    // https://tc39.github.io/ecma262/#sec-set.prototype.clear\n    clear: function (this: Set<unknown>): ReturnType<typeof $clear> {\n      const o = observerLookup.get(this);\n      if (o === undefined) {\n        return $clear.call(this);\n      }\n      const size = this.size;\n      if (size > 0) {\n        const indexMap = o.indexMap;\n        let i = 0;\n        // deepscan-disable-next-line\n        for (const key of this.keys()) {\n          if (indexMap[i] > -1) {\n            indexMap.deletedIndices.push(indexMap[i]);\n            indexMap.deletedItems.push(key);\n          }\n          i++;\n        }\n        $clear.call(this);\n        indexMap.length = 0;\n        o.notify();\n      }\n      return undefined;\n    },\n    // https://tc39.github.io/ecma262/#sec-set.prototype.delete\n    delete: function (this: Set<unknown>, value: unknown): ReturnType<typeof $delete> {\n      const o = observerLookup.get(this);\n      if (o === undefined) {\n        return $delete.call(this, value);\n      }\n      const size = this.size;\n      if (size === 0) {\n        return false;\n      }\n      let i = 0;\n      const indexMap = o.indexMap;\n      for (const entry of this.keys()) {\n        if (entry === value) {\n          if (indexMap[i] > -1) {\n            indexMap.deletedIndices.push(indexMap[i]);\n            indexMap.deletedItems.push(entry);\n          }\n          indexMap.splice(i, 1);\n          const deleteResult = $delete.call(this, value);\n          if (deleteResult === true) {\n            o.notify();\n          }\n          return deleteResult;\n        }\n        i++;\n      }\n      return false;\n    }\n  };\n\n  function enableSetObservation(set: Set<unknown>): void {\n    for (const method of methods) {\n      rtDefineHiddenProp(set, method, observe[method]);\n    }\n  }\n\n  interface SetObserverImpl extends SetObserver {}\n  class SetObserverImpl {\n    public type: AccessorType = atObserver;\n    private lenObs?: CollectionSizeObserver;\n\n    public constructor(observedSet: Set<unknown>) {\n      this.collection = observedSet;\n      this.indexMap = createIndexMap(observedSet.size);\n      this.lenObs = void 0;\n    }\n\n    public notify(): void {\n      const subs = this.subs;\n      subs.notifyDirty();\n\n      const indexMap = this.indexMap;\n      if (batching) {\n        addCollectionBatch(subs, this.collection, indexMap);\n        return;\n      }\n\n      const set = this.collection;\n      const size = set.size;\n\n      this.indexMap = createIndexMap(size);\n      subs.notifyCollection(set, indexMap);\n    }\n\n    public getLengthObserver(): CollectionSizeObserver {\n      return this.lenObs ??= new CollectionSizeObserver(this);\n    }\n  }\n  subscriberCollection(SetObserverImpl, null!);\n\n  return function getSetObserver(set: Set<unknown>): SetObserver {\n    let observer = observerLookup.get(set);\n    if (observer === void 0) {\n      observerLookup.set(set, observer = new SetObserverImpl(set));\n      enableSetObservation(set);\n    }\n    return observer;\n  };\n})();\n", "import { CollectionSizeObserver } from './collection-length-observer';\nimport { atObserver, createIndexMap } from './interfaces';\nimport { subscriberCollection } from './subscriber-collection';\nimport { rtDefineHiddenProp } from './utilities';\n\nimport { type IIndexable } from '@aurelia/kernel';\nimport type {\n  AccessorType,\n  ICollectionObserver,\n  ICollectionSubscriberCollection,\n} from './interfaces';\nimport { addCollectionBatch, batching } from './subscriber-batch';\n\nexport interface MapObserver extends ICollectionObserver<'map'>, ICollectionSubscriberCollection { }\n\nexport const getMapObserver = /*@__PURE__*/ (() => {\n  // multiple applications of Aurelia wouldn't have different observers for the same Map object\n  const lookupMetadataKey = Symbol.for('__au_map_obs__');\n  const observerLookup = ((Map as IIndexable<typeof Map>)[lookupMetadataKey]\n    ?? rtDefineHiddenProp(Map, lookupMetadataKey, new WeakMap())\n  ) as WeakMap<Map<unknown, unknown>, MapObserverImpl>;\n\n  const { set: $set, clear: $clear, delete: $delete } = Map.prototype;\n  const methods = ['set', 'clear', 'delete'] as const;\n\n  // note: we can't really do much with Map due to the internal data structure not being accessible so we're just using the native calls\n  // fortunately, map/delete/clear are easy to reconstruct for the indexMap\n\n  const observe = {\n    // https://tc39.github.io/ecma262/#sec-map.prototype.map\n    set: function (this: Map<unknown, unknown>, key: unknown, value: unknown): ReturnType<typeof $set> {\n      const o = observerLookup.get(this);\n      if (o === undefined) {\n        $set.call(this, key, value);\n        return this;\n      }\n      const oldValue = this.get(key);\n      const oldSize = this.size;\n      $set.call(this, key, value);\n      const newSize = this.size;\n      if (newSize === oldSize) {\n        let i = 0;\n        for (const entry of this.entries()) {\n          if (entry[0] === key) {\n            if (entry[1] !== oldValue) {\n              o.indexMap.deletedIndices.push(o.indexMap[i]);\n              o.indexMap.deletedItems.push(entry);\n              o.indexMap[i] = -2;\n              o.notify();\n            }\n            return this;\n          }\n          i++;\n        }\n        return this;\n      }\n      o.indexMap[oldSize] = -2;\n      o.notify();\n      return this;\n    },\n    // https://tc39.github.io/ecma262/#sec-map.prototype.clear\n    clear: function (this: Map<unknown, unknown>): ReturnType<typeof $clear> {\n      const o = observerLookup.get(this);\n      if (o === undefined) {\n        return $clear.call(this);\n      }\n      const size = this.size;\n      if (size > 0) {\n        const indexMap = o.indexMap;\n        let i = 0;\n        // deepscan-disable-next-line\n        for (const key of this.keys()) {\n          if (indexMap[i] > -1) {\n            indexMap.deletedIndices.push(indexMap[i]);\n            indexMap.deletedItems.push(key);\n          }\n          i++;\n        }\n        $clear.call(this);\n        indexMap.length = 0;\n        o.notify();\n      }\n      return undefined;\n    },\n    // https://tc39.github.io/ecma262/#sec-map.prototype.delete\n    delete: function (this: Map<unknown, unknown>, value: unknown): ReturnType<typeof $delete> {\n      const o = observerLookup.get(this);\n      if (o === undefined) {\n        return $delete.call(this, value);\n      }\n      const size = this.size;\n      if (size === 0) {\n        return false;\n      }\n      let i = 0;\n      const indexMap = o.indexMap;\n      for (const entry of this.keys()) {\n        if (entry === value) {\n          if (indexMap[i] > -1) {\n            indexMap.deletedIndices.push(indexMap[i]);\n            indexMap.deletedItems.push(entry);\n          }\n          indexMap.splice(i, 1);\n          const deleteResult = $delete.call(this, value);\n          if (deleteResult === true) {\n            o.notify();\n          }\n          return deleteResult;\n        }\n        ++i;\n      }\n      return false;\n    }\n  };\n\n  function enableMapObservation(map: Map<unknown, unknown>): void {\n    for (const method of methods) {\n      rtDefineHiddenProp(map, method, observe[method]);\n    }\n  }\n\n  // function disableMapObservation(map: Map<unknown, unknown>): void {\n  //   for (const method of methods) {\n  //     if (hasOwnProp.call(map, method)) {\n  //       // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  //       delete map[method];\n  //     }\n  //   }\n  // }\n\n  interface MapObserverImpl extends MapObserver {}\n  class MapObserverImpl {\n    public type: AccessorType = atObserver;\n    private lenObs?: CollectionSizeObserver;\n\n    public constructor(map: Map<unknown, unknown>) {\n      this.collection = map;\n      this.indexMap = createIndexMap(map.size);\n      this.lenObs = void 0;\n    }\n\n    public notify(): void {\n      const subs = this.subs;\n      subs.notifyDirty();\n\n      const indexMap = this.indexMap;\n      if (batching) {\n        addCollectionBatch(subs, this.collection, indexMap);\n        return;\n      }\n\n      const map = this.collection;\n      const size = map.size;\n\n      this.indexMap = createIndexMap(size);\n      subs.notifyCollection(map, indexMap);\n    }\n\n    public getLengthObserver(): CollectionSizeObserver {\n      return this.lenObs ??= new CollectionSizeObserver(this);\n    }\n  }\n\n  subscriberCollection(MapObserverImpl, null!);\n\n  return function getMapObserver(map: Map<unknown, unknown>): MapObserver {\n    let observer = observerLookup.get(map);\n    if (observer === void 0) {\n      observerLookup.set(map, observer = new MapObserverImpl(map));\n      enableMapObservation(map);\n    }\n    return observer;\n  };\n})();\n", "import { isArray, isMap, isSet, type Constructable } from '@aurelia/kernel';\nimport { rtDef, rtDefineHiddenProp, ensureProto } from './utilities';\nimport { getArrayObserver } from './array-observer';\nimport { getSetObserver } from './set-observer';\nimport { getMapObserver } from './map-observer';\n\nimport type {\n  IConnectable,\n  ISubscribable,\n  ISubscriber,\n  Collection,\n  CollectionObserver,\n  ICollectionSubscriber,\n  ICollectionSubscribable,\n} from './interfaces';\nimport type { IObserverLocator } from './observer-locator';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface IObserverLocatorBasedConnectable extends IConnectable, ISubscriber, ICollectionSubscriber {\n  oL: IObserverLocator;\n  /**\n   * A record storing observers that are currently subscribed to by this binding\n   */\n  obs: IObserverRecord;\n}\n\nexport interface IObserverRecord {\n  version: number;\n  count: number;\n  add(observer: ISubscribable | ICollectionSubscribable): void;\n  clear(): void;\n  clearAll(): void;\n}\n\nexport type DecoratedConnectable<T extends Partial<IConnectable>> = Constructable<T & IConnectable & ISubscriber & ICollectionSubscriber>;\n\nconst connectableDecorator = /*@__PURE__*/ (() => {\n  class BindingObserverRecord implements IObserverRecord {\n    public version: number = 0;\n    public count: number = 0;\n    // a map of the observers (subscribables) that the owning binding of this record\n    // is currently subscribing to. The values are the version of the observers,\n    // as the observers version may need to be changed during different evaluation\n    /** @internal */\n    public o = new Map<ISubscribable | ICollectionSubscribable, number>();\n    /** @internal */\n    public readonly b: IObserverLocatorBasedConnectable;\n\n    public constructor(b: IObserverLocatorBasedConnectable) {\n      this.b = b;\n    }\n\n    /**\n     * Add, and subscribe to a given observer\n     */\n    public add(observer: ISubscribable | ICollectionSubscribable): void {\n      if (!this.o.has(observer)) {\n        observer.subscribe(this.b);\n        ++this.count;\n      }\n      this.o.set(observer, this.version);\n    }\n\n    /**\n     * Unsubscribe the observers that are not up to date with the record version\n     */\n    public clear(): void {\n      this.o.forEach(unsubscribeStale, this);\n      this.count = this.o.size;\n    }\n\n    public clearAll() {\n      this.o.forEach(unsubscribeAll, this);\n      this.o.clear();\n      this.count = 0;\n    }\n  }\n\n  function unsubscribeAll(this: BindingObserverRecord, version: number, subscribable: ISubscribable | ICollectionSubscribable) {\n    subscribable.unsubscribe(this.b);\n  }\n\n  function unsubscribeStale(this: BindingObserverRecord, version: number, subscribable: ISubscribable | ICollectionSubscribable) {\n    if (this.version !== version) {\n      subscribable.unsubscribe(this.b);\n      this.o.delete(subscribable);\n    }\n  }\n\n  function getObserverRecord(this: IObserverLocatorBasedConnectable): BindingObserverRecord {\n    return rtDefineHiddenProp(this, 'obs', new BindingObserverRecord(this));\n  }\n  function observe(this: IObserverLocatorBasedConnectable, obj: object, key: PropertyKey): void {\n    this.obs.add(this.oL.getObserver(obj, key));\n  }\n  function observeCollection(this: IObserverLocatorBasedConnectable, collection: Collection): void {\n    let observer: CollectionObserver;\n    if (isArray(collection)) {\n      observer = getArrayObserver(collection);\n    } else if (isSet(collection)) {\n      observer = getSetObserver(collection);\n    } else if (isMap(collection)) {\n      observer = getMapObserver(collection);\n    } else {\n      throw createMappedError(ErrorNames.non_recognisable_collection_type, collection);\n    }\n    this.obs.add(observer);\n  }\n\n  function subscribeTo(this: IObserverLocatorBasedConnectable, subscribable: ISubscribable | ICollectionSubscribable): void {\n    this.obs.add(subscribable);\n  }\n\n  function noopHandleChange() {\n    throw createMappedError(ErrorNames.method_not_implemented, 'handleChange');\n  }\n\n  function noopHandleCollectionChange() {\n    throw createMappedError(ErrorNames.method_not_implemented, 'handleCollectionChange');\n  }\n\n  return function connectableDecorator<T extends Partial<IConnectable>, C extends Constructable<T>>(target: C, context: ClassDecoratorContext<C>): DecoratedConnectable<T> {\n    const proto = target.prototype;\n    ensureProto(proto, 'observe', observe);\n    ensureProto(proto, 'observeCollection', observeCollection);\n    ensureProto(proto, 'subscribeTo', subscribeTo);\n    rtDef(proto, 'obs', { get: getObserverRecord });\n    // optionally add these two methods to normalize a connectable impl\n    // though don't override if it already exists\n    ensureProto(proto, 'handleChange', noopHandleChange);\n    ensureProto(proto, 'handleCollectionChange', noopHandleCollectionChange);\n\n    return target as unknown as DecoratedConnectable<T>;\n  };\n})();\n\nexport function connectable(): typeof connectableDecorator;\nexport function connectable<T extends Partial<IConnectable>, C extends Constructable<T>>(target: C, context: ClassDecoratorContext<C>): DecoratedConnectable<T>;\nexport function connectable<T extends Partial<IConnectable>, C extends Constructable<T>>(target?: C, context?: ClassDecoratorContext<C>): DecoratedConnectable<T> | typeof connectableDecorator {\n  return target == null ? connectableDecorator : connectableDecorator(target, context!);\n}\n", "import { ErrorNames, createMappedError } from './errors';\nimport type { IConnectable } from './interfaces';\nimport { rtObjectFreeze } from './utilities';\n\n/**\n * Current subscription collector\n */\n// eslint-disable-next-line import/no-mutable-exports\nexport let _connectable: IConnectable | null = null;\nconst connectables: IConnectable[] = [];\n// eslint-disable-next-line\nexport let connecting = false;\n\n// todo: layer based collection pause/resume?\nexport function pauseConnecting() {\n  connecting = false;\n}\n\nexport function resumeConnecting() {\n  connecting = true;\n}\n\nexport function currentConnectable(): IConnectable | null {\n  return _connectable;\n}\n\nexport function enterConnectable(connectable: IConnectable): void {\n  if (connectable == null) {\n    throw createMappedError(ErrorNames.switch_on_null_connectable);\n  }\n  if (_connectable == null) {\n    _connectable = connectable;\n    connectables[0] = _connectable;\n    connecting = true;\n    return;\n  }\n  if (_connectable === connectable) {\n    throw createMappedError(ErrorNames.switch_active_connectable);\n  }\n  connectables.push(connectable);\n  _connectable = connectable;\n  connecting = true;\n}\n\nexport function exitConnectable(connectable: IConnectable): void {\n  if (connectable == null) {\n    throw createMappedError(ErrorNames.switch_off_null_connectable);\n  }\n  if (_connectable !== connectable) {\n    throw createMappedError(ErrorNames.switch_off_inactive_connectable);\n  }\n\n  connectables.pop();\n  _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;\n  connecting = _connectable != null;\n}\n\nexport const ConnectableSwitcher = /*@__PURE__*/ rtObjectFreeze({\n  get current() {\n    return _connectable;\n  },\n  get connecting() {\n    return connecting;\n  },\n  enter: enterConnectable,\n  exit: exitConnectable,\n  pause: pauseConnecting,\n  resume: resumeConnecting,\n});\n", "import { IIndexable, isArray, isMap, isSet } from '@aurelia/kernel';\nimport { Collection, IConnectable } from './interfaces';\nimport { rtObjectFreeze, rtSafeString } from './utilities';\nimport { connecting, currentConnectable, _connectable } from './connectable-switcher';\n\nconst R$get = Reflect.get;\nconst toStringTag = Object.prototype.toString;\nconst proxyMap = new WeakMap<object, object>();\n/** @internal */\nexport const nowrapClassKey = '__au_nw__';\n/** @internal */\nexport const nowrapPropKey = '__au_nw';\n\nfunction canWrap(obj: unknown): obj is object {\n  switch (toStringTag.call(obj)) {\n    case '[object Object]':\n      // enable inheritance decoration\n      return ((obj as object).constructor as IIndexable<() => unknown>)[nowrapClassKey] !== true;\n    case '[object Array]':\n    case '[object Map]':\n    case '[object Set]':\n    // it's unlikely that methods on the following 2 objects need to be observed for changes\n    // so while they are valid/ we don't wrap them either\n    // case '[object Math]':\n    // case '[object Reflect]':\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport const rawKey = '__raw__';\n\nexport function wrap<T>(v: T): T {\n  return canWrap(v) ? getProxy(v) : v;\n}\nexport function getProxy<T extends object>(obj: T): T {\n  // deepscan-disable-next-line\n  return proxyMap.get(obj) as T ?? createProxy(obj);\n}\n\nexport function getRaw<T extends object>(obj: T): T {\n  // todo: get in a weakmap if null/undef\n  return (obj as IIndexable)[rawKey] as T ?? obj;\n}\nexport function unwrap<T>(v: T): T {\n  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n  return canWrap(v) && (v as IIndexable)[rawKey] as T || v;\n}\n\nfunction doNotCollect(object: object, key: PropertyKey): boolean {\n  if (key === 'constructor'\n    || key === '__proto__'\n    // probably should revert to v1 naming style for consistency with builtin?\n    // __o__ is shorters & less chance of conflict with other libs as well\n    || key === '$observers'\n    || key === Symbol.toPrimitive\n    || key === Symbol.toStringTag\n    // limit to string first\n    // symbol can be added later\n    // looking up from the constructor means inheritance is supported\n    || (object.constructor as IIndexable<() => unknown>)[`${nowrapPropKey}_${rtSafeString(key)}__`] === true) {\n    return true;\n  }\n\n  // ensure Proxy spec compliance, value of non-configurable and non-writable property MUST be returned as is\n  // https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver\n  const descriptor = Reflect.getOwnPropertyDescriptor(object, key);\n\n  return descriptor?.configurable === false && descriptor.writable === false;\n}\n\nfunction createProxy<T extends object>(obj: T): T {\n  const handler: ProxyHandler<object> = isArray(obj)\n    ? arrayHandler\n    : isMap(obj) || isSet(obj)\n      ? collectionHandler\n      : objectHandler;\n\n  const proxiedObj = new Proxy(obj, handler);\n  proxyMap.set(obj, proxiedObj);\n  proxyMap.set(proxiedObj, proxiedObj);\n\n  return proxiedObj as T;\n}\n\nconst objectHandler: ProxyHandler<object> = {\n  get(target: IIndexable, key: PropertyKey, receiver: object): unknown {\n    // maybe use symbol?\n    if (key === rawKey) {\n      return target;\n    }\n\n    const connectable = currentConnectable();\n\n    if (!connecting || doNotCollect(target, key) || connectable == null) {\n      return R$get(target, key, receiver);\n    }\n\n    // todo: static\n    connectable.observe(target, key);\n\n    return wrap(R$get(target, key, receiver));\n  },\n  deleteProperty(target, p) {\n    if (__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV:aurelia] deletion of a property will not always be working with Aurelia observation system, as it depends on getter/setter installation.`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n    return delete (target as IIndexable)[p];\n  },\n};\n\nconst arrayHandler: ProxyHandler<unknown[]> = {\n  get(target: unknown[], key: PropertyKey, receiver: unknown): unknown {\n    // maybe use symbol?\n    if (key === rawKey) {\n      return target;\n    }\n\n    if (!connecting || doNotCollect(target, key) || _connectable == null) {\n      return R$get(target, key, receiver);\n    }\n\n    switch (key) {\n      case 'length':\n        _connectable.observe(target, 'length');\n        return target.length;\n      case 'map':\n        return wrappedArrayMap;\n      case 'includes':\n        return wrappedArrayIncludes;\n      case 'indexOf':\n        return wrappedArrayIndexOf;\n      case 'lastIndexOf':\n        return wrappedArrayLastIndexOf;\n      case 'every':\n        return wrappedArrayEvery;\n      case 'filter':\n        return wrappedArrayFilter;\n      case 'find':\n        return wrappedArrayFind;\n      case 'findIndex':\n        return wrappedArrayFindIndex;\n      case 'flat':\n        return wrappedArrayFlat;\n      case 'flatMap':\n        return wrappedArrayFlatMap;\n      case 'join':\n        return wrappedArrayJoin;\n      case 'push':\n        return wrappedArrayPush;\n      case 'pop':\n        return wrappedArrayPop;\n      case 'reduce':\n        return wrappedReduce;\n      case 'reduceRight':\n        return wrappedReduceRight;\n      case 'reverse':\n        return wrappedArrayReverse;\n      case 'shift':\n        return wrappedArrayShift;\n      case 'unshift':\n        return wrappedArrayUnshift;\n      case 'slice':\n        return wrappedArraySlice;\n      case 'splice':\n        return wrappedArraySplice;\n      case 'some':\n        return wrappedArraySome;\n      case 'sort':\n        return wrappedArraySort;\n      case 'keys':\n        return wrappedKeys;\n      case 'values':\n      case Symbol.iterator:\n        return wrappedValues;\n      case 'entries':\n        return wrappedEntries;\n    }\n\n    _connectable.observe(target, key);\n\n    return wrap(R$get(target, key, receiver));\n  },\n  // for (let i in array) ...\n  ownKeys(target: unknown[]): (string | symbol)[] {\n    currentConnectable()?.observe(target, 'length');\n    return Reflect.ownKeys(target);\n  },\n};\n\nfunction wrappedArrayMap(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => unknown, thisArg?: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.map((v, i) =>\n    // do we wrap `thisArg`?\n    unwrap(cb.call(thisArg, wrap(v), i, this))\n  );\n  observeCollection(_connectable, raw);\n  return wrap(res);\n}\n\nfunction wrappedArrayEvery(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => unknown, thisArg?: unknown): boolean {\n  const raw = getRaw(this);\n  const res = raw.every((v, i) => cb.call(thisArg, wrap(v), i, this));\n  observeCollection(_connectable, raw);\n  return res;\n}\n\nfunction wrappedArrayFilter(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): unknown[] {\n  const raw = getRaw(this);\n  const res = raw.filter((v, i) =>\n    // do we wrap `thisArg`?\n    unwrap(cb.call(thisArg, wrap(v), i, this))\n  );\n  observeCollection(_connectable, raw);\n  return wrap(res);\n}\n\nfunction wrappedArrayIncludes(this: unknown[], v: unknown): boolean {\n  const raw = getRaw(this);\n  const res = raw.includes(unwrap(v));\n  observeCollection(_connectable, raw);\n  return res;\n}\n\nfunction wrappedArrayIndexOf(this: unknown[], v: unknown): number {\n  const raw = getRaw(this);\n  const res = raw.indexOf(unwrap(v));\n  observeCollection(_connectable, raw);\n  return res;\n}\nfunction wrappedArrayLastIndexOf(this: unknown[], v: unknown): number {\n  const raw = getRaw(this);\n  const res = raw.lastIndexOf(unwrap(v));\n  observeCollection(_connectable, raw);\n  return res;\n}\nfunction wrappedArrayFindIndex(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): number {\n  const raw = getRaw(this);\n  const res = raw.findIndex((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));\n  observeCollection(_connectable, raw);\n  return res;\n}\n\nfunction wrappedArrayFind(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.find((v, i) => cb(wrap(v), i, this), thisArg);\n  observeCollection(_connectable, raw);\n  return wrap(res);\n}\n\nfunction wrappedArrayFlat(this: unknown[]): unknown[] {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  return wrap(raw.flat());\n}\nfunction wrappedArrayFlatMap(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => unknown, thisArg?: unknown): unknown[] {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  return getProxy(raw.flatMap((v, i) =>\n    wrap(cb.call(thisArg, wrap(v), i, this)))\n  );\n}\nfunction wrappedArrayJoin(this: unknown[], separator?: string): string {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  return raw.join(separator);\n}\n\nfunction wrappedArrayPop(this: unknown[]): unknown {\n  return wrap(getRaw(this).pop());\n}\nfunction wrappedArrayPush(this: unknown[], ...args: unknown[]): number {\n  return getRaw(this).push(...args);\n}\nfunction wrappedArrayShift(this: unknown[]): unknown {\n  return wrap(getRaw(this).shift());\n}\nfunction wrappedArrayUnshift(this: unknown[], ...args: unknown[]): unknown {\n  return getRaw(this).unshift(...args);\n}\nfunction wrappedArraySplice(this: unknown[], ...args: [number, number, ...unknown[]]): unknown {\n  return wrap(getRaw(this).splice(...args));\n}\nfunction wrappedArrayReverse(this: unknown[], ..._args: unknown[]): unknown[] {\n  return wrap(getRaw(this).reverse());\n}\n\nfunction wrappedArraySome(this: unknown[], cb: (v: unknown, i: number, arr: unknown[]) => boolean, thisArg?: unknown): boolean {\n  const raw = getRaw(this);\n  const res = raw.some((v, i) => unwrap(cb.call(thisArg, wrap(v), i, this)));\n  observeCollection(_connectable, raw);\n  return res;\n}\n\nfunction wrappedArraySort(this: unknown[], cb?: (a: unknown, b: unknown) => number): unknown[] {\n  const raw = getRaw(this);\n  const res = raw.sort(cb);\n  observeCollection(_connectable, raw);\n  return wrap(res);\n}\n\nfunction wrappedArraySlice(this: unknown[], start?: number, end?: number): unknown[] {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  return getProxy(raw.slice(start, end));\n}\n\nfunction wrappedReduce(this: unknown[], cb: (curr: unknown, v: unknown, i: number, arr: unknown[]) => unknown, initValue: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.reduce((curr, v, i) => cb(curr, wrap(v), i, this), initValue);\n  observeCollection(_connectable, raw);\n  return wrap(res);\n}\n\nfunction wrappedReduceRight(this: unknown[], cb: (curr: unknown, v: unknown, i: number, arr: unknown[]) => unknown, initValue: unknown): unknown {\n  const raw = getRaw(this);\n  const res = raw.reduceRight((curr, v, i) => cb(curr, wrap(v), i, this), initValue);\n  observeCollection(_connectable, raw);\n  return wrap(res);\n}\n\n// the below logic takes inspiration from Vue, Mobx\n// much thanks to them for working out this\nconst collectionHandler: ProxyHandler<$MapOrSet> = {\n  get(target: $MapOrSet, key: PropertyKey, receiver?): unknown {\n    // maybe use symbol?\n    if (key === rawKey) {\n      return target;\n    }\n\n    const connectable = currentConnectable();\n\n    if (!connecting || doNotCollect(target, key) || connectable == null) {\n      return R$get(target, key, receiver);\n    }\n\n    switch (key) {\n      case 'size':\n        connectable.observe(target, 'size');\n        return target.size;\n      case 'clear':\n        return wrappedClear;\n      case 'delete':\n        return wrappedDelete;\n      case 'forEach':\n        return wrappedForEach;\n      case 'add':\n        if (isSet(target)) {\n          return wrappedAdd;\n        }\n        break;\n      case 'get':\n        if (isMap(target)) {\n          return wrappedGet;\n        }\n        break;\n      case 'set':\n        if (isMap(target)) {\n          return wrappedSet;\n        }\n        break;\n      case 'has':\n        return wrappedHas;\n      case 'keys':\n        return wrappedKeys;\n      case 'values':\n        return wrappedValues;\n      case 'entries':\n        return wrappedEntries;\n      case Symbol.iterator:\n        return isMap(target) ? wrappedEntries : wrappedValues;\n    }\n\n    return wrap(R$get(target, key, receiver));\n  },\n};\n\ntype $MapOrSet = Map<unknown, unknown> | Set<unknown>;\ntype CollectionMethod = (this: unknown, ...args: unknown[]) => unknown;\n\nfunction wrappedForEach(this: $MapOrSet, cb: CollectionMethod, thisArg?: unknown): void {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  return raw.forEach((v: unknown, key: unknown) => {\n    cb.call(/* should wrap or not?? */thisArg, wrap(v), wrap(key), this);\n  });\n}\n\nfunction wrappedHas(this: $MapOrSet, v: unknown): boolean {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  return raw.has(unwrap(v));\n}\n\nfunction wrappedGet(this: Map<unknown, unknown>, k: unknown): unknown {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  return wrap(raw.get(unwrap(k)));\n}\nfunction wrappedSet(this: Map<unknown, unknown>, k: unknown, v: unknown): Map<unknown, unknown> {\n  return wrap(getRaw(this).set(unwrap(k), unwrap(v)));\n}\n\nfunction wrappedAdd(this: Set<unknown>, v: unknown): Set<unknown> {\n  return wrap(getRaw(this).add(unwrap(v)));\n}\n\nfunction wrappedClear(this: $MapOrSet): void {\n  return wrap(getRaw(this).clear());\n}\n\nfunction wrappedDelete(this: $MapOrSet, k: unknown): boolean {\n  return wrap(getRaw(this).delete(unwrap(k)));\n}\n\nfunction wrappedKeys(this: $MapOrSet | unknown[]): IterableIterator<unknown> {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  const iterator = raw.keys();\n\n  return {\n    next(): IteratorResult<unknown, unknown> {\n      const next = iterator.next();\n      const value = next.value;\n      const done = next.done;\n\n      return done\n        ? { value: void 0, done }\n        : { value: wrap(value), done };\n    },\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\nfunction wrappedValues(this: $MapOrSet | unknown[]): IterableIterator<unknown> {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  const iterator = raw.values();\n\n  return {\n    next(): IteratorResult<unknown, unknown> {\n      const next = iterator.next();\n      const value = next.value;\n      const done = next.done;\n\n      return done\n        ? { value: void 0, done }\n        : { value: wrap(value), done };\n    },\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\nfunction wrappedEntries(this: $MapOrSet | unknown[]): IterableIterator<unknown> {\n  const raw = getRaw(this);\n  observeCollection(_connectable, raw);\n  const iterator = raw.entries();\n\n  // return a wrapped iterator which returns observed versions of the\n  // values emitted from the real iterator\n  return {\n    next(): IteratorResult<unknown, unknown> {\n      const next = iterator.next();\n      const value = next.value!;\n      const done = next.done;\n\n      return done\n        ? { value: void 0, done }\n        : { value: [wrap(value[0]), wrap(value[1])], done };\n    },\n    [Symbol.iterator]() {\n      return this;\n    },\n  };\n}\n\nconst observeCollection = (connectable: IConnectable | null, collection: Collection) => connectable?.observeCollection(collection);\nexport const ProxyObservable = /*@__PURE__*/ rtObjectFreeze({\n  getProxy,\n  getRaw,\n  wrap,\n  unwrap,\n  rawKey,\n});\n", "import {\n  ICoercionConfiguration,\n  IObserver,\n  InterceptorFunc,\n  atObserver,\n} from './interfaces';\nimport { subscriberCollection } from './subscriber-collection';\nimport { enterConnectable, exitConnectable } from './connectable-switcher';\nimport { connectable } from './connectable';\nimport { wrap, unwrap } from './proxy-observation';\nimport { areEqual, isFunction } from '@aurelia/kernel';\n\nimport type {\n  AccessorType,\n  ISubscriber,\n  ICollectionSubscriber,\n  ISubscriberCollection,\n  IConnectable,\n} from './interfaces';\nimport type { IObserverLocatorBasedConnectable } from './connectable';\nimport type { IObserverLocator } from './observer-locator';\nimport { ErrorNames, createMappedError } from './errors';\nimport { queueTask } from './queue';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ComputedGetterFn<T = any, R = any> = (this: T, obj: T, observer: IConnectable) => R;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface ComputedObserver<T extends object> extends IObserverLocatorBasedConnectable, ISubscriberCollection { }\n\nexport class ComputedObserver<T extends object> implements\n  IObserver,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  ICollectionSubscriber,\n  ISubscriberCollection {\n  static {\n    connectable(ComputedObserver, null!);\n    subscriberCollection(ComputedObserver, null!);\n  }\n\n  public type: AccessorType = atObserver;\n\n  /** @internal */\n  private _oldValue: unknown = void 0;\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  /** @internal */\n  private _notified = false;\n\n  // todo: maybe use a counter allow recursive call to a certain level\n  /** @internal */\n  private _isQueued: boolean = false;\n\n  /** @internal */\n  private _isDirty: boolean = false;\n\n  /** @internal */\n  private readonly _obj: T;\n\n  /** @internal */\n  private readonly _wrapped: T;\n\n  /** @internal */\n  private _callback?: (newValue: unknown, oldValue: unknown) => void = void 0;\n\n  /** @internal */\n  private _coercer?: InterceptorFunc = void 0;\n\n  /** @internal */\n  private _coercionConfig?: ICoercionConfiguration = void 0;\n\n  /** @internal */\n  private readonly _flush: 'sync' | 'async';\n\n  /**\n   * The getter this observer is wrapping\n   */\n  public readonly $get: ComputedGetterFn<T>;\n\n  /**\n   * The setter this observer is wrapping\n   */\n  public readonly $set: undefined | ((v: unknown) => void);\n\n  /**\n   * A semi-private property used by connectable mixin\n   */\n  public readonly oL: IObserverLocator;\n\n  public constructor(\n    obj: T,\n    get: ComputedGetterFn<T>,\n    set: undefined | ((v: unknown) => void),\n    observerLocator: IObserverLocator,\n    flush: 'sync' | 'async' = 'async',\n  ) {\n    this._obj = obj;\n    this._wrapped = wrap(obj);\n    this.$get = get;\n    this.$set = set;\n    this.oL = observerLocator;\n    this._flush = flush;\n  }\n\n  public init(value: unknown) {\n    this._value = value;\n    this._isDirty = false;\n  }\n\n  public getValue() {\n    if (this.subs.count === 0) {\n      return this.$get.call(this._obj, this._obj, this);\n    }\n    if (this._isDirty) {\n      this.compute();\n      this._isDirty = false;\n      this._notified = false;\n    }\n    return this._value;\n  }\n\n  // deepscan-disable-next-line\n  public setValue(v: unknown): void {\n    if (isFunction(this.$set)) {\n      if (this._coercer !== void 0) {\n        v = this._coercer.call(null, v, this._coercionConfig);\n      }\n      if (!areEqual(v, this._value)) {\n        this.$set.call(this._obj, v);\n        this.run();\n      }\n    } else {\n      throw createMappedError(ErrorNames.assign_readonly_readonly_property_from_computed);\n    }\n  }\n\n  public useCoercer(coercer: InterceptorFunc, coercionConfig?: ICoercionConfiguration | undefined): boolean {\n    this._coercer = coercer;\n    this._coercionConfig = coercionConfig;\n    return true;\n  }\n\n  public useCallback(callback: (newValue: unknown, oldValue: unknown) => void) {\n    this._callback = callback;\n    return true;\n  }\n\n  public handleDirty(): void {\n    if (!this._isDirty) {\n      this._isDirty = true;\n      this.subs.notifyDirty();\n    }\n  }\n\n  public handleChange(): void {\n    this._isDirty = true;\n    if (this.subs.count > 0) {\n      this.run();\n    }\n  }\n\n  public handleCollectionChange(): void {\n    this._isDirty = true;\n    if (this.subs.count > 0) {\n      this.run();\n    }\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    // in theory, a collection subscriber could be added before a property subscriber\n    // and it should be handled similarly in subscribeToCollection\n    // though not handling for now, and wait until the merge of normal + collection subscription\n    if (this.subs.add(subscriber) && this.subs.count === 1) {\n      // start collecting dependencies\n      this._oldValue = this.compute();\n      this._isDirty = false;\n      this._notified = false;\n    }\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    if (this.subs.remove(subscriber) && this.subs.count === 0) {\n      this._isDirty = true;\n      this.obs.clearAll();\n      this._oldValue = void 0;\n      this._notified = true;\n    }\n  }\n\n  private run(): void {\n    if (this._flush === 'sync') {\n      this._run();\n      return;\n    }\n\n    if (this._isQueued) {\n      return;\n    }\n    this._isQueued = true;\n    queueTask(() => {\n      this._isQueued = false;\n      this._run();\n    });\n  }\n\n  /** @internal */\n  private _run() {\n      const currValue = this._value;\n      const oldValue = this._oldValue;\n      const newValue = this.compute();\n\n      this._isDirty = false;\n\n    // there's case where the _value property was updated without notifying subscribers\n    // such is the case when this computed observer value was requested\n    // before the dependencies of this observer notify it of their changes\n    //\n    // if we are to notify whenever we are computing new value, it'd cause a depth first & potentially circular update\n    // (subscriber of this observer requests value -> this observer re-computes -> subscribers gets updated)\n    // so we are only notifying subscribers when it's the actual notify phase\n\n      if (!this._notified || !areEqual(newValue, currValue)) {\n        // todo: wrong timing, this should be after notify\n        this._callback?.(newValue, oldValue);\n        this.subs.notify(newValue, oldValue);\n        this._oldValue = this._value = newValue;\n        this._notified = true;\n      }\n\n  }\n\n  private compute(): unknown {\n    this.obs.version++;\n    try {\n      enterConnectable(this);\n      return this._value = unwrap(this.$get.call(this._wrapped, this._wrapped, this));\n    } finally {\n      this.obs.clear();\n      exitConnectable(this);\n    }\n  }\n}\n", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n", "import { isSymbol } from '@aurelia/kernel';\n\n/** @internal */\nexport const computedPropInfo = (() => {\n  const map = new WeakMap<object, Map<string | symbol, { flush: 'sync' | 'async' }>>();\n  const normalizeKey = (key: PropertyKey): string | symbol => {\n    return isSymbol(key) ? key : String(key);\n  };\n  return {\n    get: (obj: object, key: PropertyKey) => map.get(obj)?.get(normalizeKey(key)),\n    _getFlush: (obj: object, key: PropertyKey): 'sync' | 'async' | undefined => {\n      return map.get(obj)?.get(normalizeKey(key))?.flush;\n    },\n    set: (obj: object, key: PropertyKey, value: { flush: 'sync' | 'async' }) => {\n      if (!map.has(obj)) {\n        map.set(obj, new Map());\n      }\n      map.get(obj)!.set(normalizeKey(key), value);\n    }\n  };\n})();\n", "import { computedPropInfo } from './object-property-info';\n\n/**\n * Decorate a getter to configure various aspects of the computed property created by the getter.\n *\n * Example usage:\n *\n * ```ts\n * export class MyElement {\n *  \\@computed({ flush: 'sync' })\n *   public get prop(): number {\n *     return 24;\n *   }\n * }\n * ```\n */\nexport function computed<\n  TThis extends object\n>(\n  options: {\n    flush?: 'sync' | 'async';\n    // todo: future improvement\n    // dependencies?: (string | symbol)[];\n  }\n) {\n  return function decorator(\n    target: () => unknown,\n    context: ClassGetterDecoratorContext<TThis>\n  ) {\n    context.addInitializer(function (this: object) {\n      const flush = options.flush ?? 'async';\n      computedPropInfo.set(this, context.name, { flush });\n    });\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nfunction testComputed() {\n\n  // normal usages\n  class MyClass {\n    @computed({ flush: 'sync' })\n    public get prop2(): number {\n      return 2;\n    }\n\n    @computed({ flush: 'async' })\n    public get prop3(): number {\n      return 2;\n    }\n  }\n\n  // @ts-expect-error - classes arent supported\n  @computed({ flush: 'sync' })\n  class MyModel {\n    // @ts-expect-error - needs options\n    @computed()\n    public get prop1(): number {\n      return 1;\n    }\n\n    // @ts-expect-error - methods arent supported\n    @computed\n    public prop() {\n      return 1;\n    }\n  }\n\n  class MyModel2 {\n    private v: number = 1;\n    // @ts-expect-error setters arent supported\n    @computed({ flush: 'async' })\n    public set prop(v: number) {\n      this.v = v;\n    }\n  }\n}\n", "import { IContainer, IPlatform, Registration, resolve } from '@aurelia/kernel';\nimport { type AccessorType, type IObserver, type ISubscriberCollection, type IObservable, type ISubscriber, atNone } from './interfaces';\nimport { subscriberCollection } from './subscriber-collection';\nimport { rtCreateInterface } from './utilities';\n\nimport type { IIndexable } from '@aurelia/kernel';\nimport { ErrorNames, createMappedError } from './errors';\nimport { queueRecurringTask, RecurringTask } from './queue';\n\nexport interface IDirtyChecker extends DirtyChecker {}\nexport const IDirtyChecker = /*@__PURE__*/ rtCreateInterface<IDirtyChecker>('IDirtyChecker', __DEV__\n  ? x => x.callback(() => {\n    throw createMappedError(ErrorNames.dirty_check_no_handler);\n  })\n  : void 0\n);\n\nexport const DirtyCheckSettings = {\n  /**\n   * Default: `6`\n   *\n   * Adjust the global dirty check frequency.\n   * Measures in \"timeouts per check\", such that (given a default of 250 timeouts per second in modern browsers):\n   * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)\n   * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)\n   */\n  timeoutsPerCheck: 25,\n  /**\n   * Default: `false`\n   *\n   * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking\n   * or an adapter, will simply not be observed.\n   */\n  disabled: false,\n  /**\n   * Default: `false`\n   *\n   * Throw an error if a property is being dirty-checked.\n   */\n  throw: false,\n  /**\n   * Resets all dirty checking settings to the framework's defaults.\n   */\n  resetToDefault(): void {\n    this.timeoutsPerCheck = 6;\n    this.disabled = false;\n    this.throw = false;\n  }\n};\n\nexport class DirtyChecker {\n  public static register(c: IContainer) {\n    c.register(\n      Registration.singleton(this, this),\n      Registration.aliasTo(this, IDirtyChecker),\n    );\n  }\n  private readonly tracked: DirtyCheckProperty[] = [];\n\n  /** @internal */\n  private _task: RecurringTask | null = null;\n  /** @internal */\n  private _elapsedFrames: number = 0;\n\n  private readonly p = resolve(IPlatform);\n  public constructor(\n  ) {\n    subscriberCollection(DirtyCheckProperty, null!);\n  }\n\n  public createProperty(obj: object, key: PropertyKey): DirtyCheckProperty {\n    if (DirtyCheckSettings.throw) {\n      throw createMappedError(ErrorNames.dirty_check_not_allowed, key);\n    }\n    return new DirtyCheckProperty(this, obj as IIndexable, key as string);\n  }\n\n  public addProperty(property: DirtyCheckProperty): void {\n    this.tracked.push(property);\n\n    if (this.tracked.length === 1) {\n      this._task = queueRecurringTask(this.check, { interval: 0 });\n    }\n  }\n\n  public removeProperty(property: DirtyCheckProperty): void {\n    this.tracked.splice(this.tracked.indexOf(property), 1);\n    if (this.tracked.length === 0) {\n      this._task!.cancel();\n      this._task = null;\n    }\n  }\n\n  private readonly check = () => {\n    if (DirtyCheckSettings.disabled) {\n      return;\n    }\n    if (++this._elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {\n      return;\n    }\n    this._elapsedFrames = 0;\n    const tracked = this.tracked.slice(0);\n    const len = tracked.length;\n    let current: DirtyCheckProperty;\n    let i = 0;\n    for (; i < len; ++i) {\n      current = tracked[i];\n      if (current.isDirty()) {\n        current.flush();\n      }\n    }\n  };\n}\n\nexport interface DirtyCheckProperty extends IObserver, ISubscriberCollection { }\n\nexport class DirtyCheckProperty implements DirtyCheckProperty {\n  public type: AccessorType = atNone;\n\n  /** @internal */\n  private _oldValue: unknown = void 0;\n  /** @internal */\n  private readonly _dirtyChecker: IDirtyChecker;\n\n  public constructor(\n    dirtyChecker: IDirtyChecker,\n    public obj: IObservable & IIndexable,\n    public key: string,\n  ) {\n    this._dirtyChecker = dirtyChecker;\n  }\n\n  public getValue() {\n    return this.obj[this.key];\n  }\n\n  public setValue(_v: unknown) {\n    // todo: this should be allowed, probably\n    // but the construction of dirty checker should throw instead\n    throw createMappedError(ErrorNames.dirty_check_setter_not_allowed, this.key);\n  }\n\n  public isDirty(): boolean {\n    return this._oldValue !== this.obj[this.key];\n  }\n\n  public flush(): void {\n    const oldValue = this._oldValue;\n    const newValue = this.getValue();\n\n    this._oldValue = newValue;\n    this.subs.notify(newValue, oldValue);\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (this.subs.add(subscriber) && this.subs.count === 1) {\n      this._oldValue = this.obj[this.key];\n      this._dirtyChecker.addProperty(this);\n    }\n  }\n\n  public unsubscribe(subscriber: ISubscriber): void {\n    if (this.subs.remove(subscriber) && this.subs.count === 0) {\n      this._dirtyChecker.removeProperty(this);\n    }\n  }\n}\n", "import { atNone } from './interfaces';\n\nimport type { Primitive } from '@aurelia/kernel';\nimport type { AccessorType, IAccessor, ISubscribable } from './interfaces';\n\nexport class PrimitiveObserver implements IAccessor, ISubscribable {\n  public get doNotCache(): true { return true; }\n  public type: AccessorType = atNone;\n  /** @internal */\n  private readonly _obj: Primitive;\n  /** @internal */\n  private readonly _key: PropertyKey;\n\n  public constructor(\n    obj: Primitive,\n    key: PropertyKey,\n  ) {\n    this._obj = obj;\n    this._key = key;\n  }\n\n  public getValue(): unknown {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-explicit-any\n    return (this._obj as any)[this._key];\n  }\n  public setValue(): void { /* do nothing */ }\n  public subscribe(): void { /* do nothing */ }\n  public unsubscribe(): void { /* do nothing */ }\n}\n", "import { atNone } from './interfaces';\nimport type { AccessorType, IAccessor, IObservable } from './interfaces';\n\nexport class PropertyAccessor implements IAccessor {\n  // the only thing can be guaranteed is it's an object\n  // even if this property accessor is used to access an element\n  public type: AccessorType = atNone;\n\n  public getValue(obj: object, key: string): unknown {\n    return (obj as IObservable)[key];\n  }\n\n  public setValue(value: unknown, obj: object, key: string): void {\n    (obj as IObservable)[key] = value;\n  }\n}\n", "import { ICoercionConfiguration, IObserver, InterceptorFunc, atObserver } from './interfaces';\nimport { subscriberCollection } from './subscriber-collection';\nimport { rtDef, rtObjectAssign } from './utilities';\n\nimport { areEqual, type IIndexable } from '@aurelia/kernel';\nimport type {\n  AccessorType,\n  ISubscriber,\n  ISubscriberCollection,\n} from './interfaces';\n\nexport interface SetterObserver extends ISubscriberCollection {}\n\n/**\n * Observer for the mutation of object property value employing getter-setter strategy.\n * This is used for observing object properties that has no decorator.\n */\nexport class SetterObserver implements IObserver, ISubscriberCollection {\n  static {\n    subscriberCollection(SetterObserver, null!);\n  }\n\n  // todo(bigopon): tweak the flag based on typeof obj (array/set/map/iterator/proxy etc...)\n  public type: AccessorType = atObserver;\n\n  /** @internal */\n  private _value: unknown = void 0;\n  /** @internal */\n  private _observing: boolean = false;\n\n  /** @internal */\n  private _callback?: (newValue: unknown, oldValue: unknown) => void = void 0;\n  /** @internal */\n  private _coercer?: InterceptorFunc = void 0;\n  /** @internal */\n  private _coercionConfig?: ICoercionConfiguration = void 0;\n\n  /** @internal */ private readonly _obj: IIndexable;\n  /** @internal */ private readonly _key: PropertyKey;\n\n  public constructor(\n    obj: IIndexable,\n    key: PropertyKey,\n  ) {\n    this._obj = obj;\n    this._key = key;\n  }\n\n  public getValue(): unknown {\n    return this._value;\n  }\n\n  public setValue(newValue: unknown): void {\n    if (this._coercer !== void 0) {\n      newValue = this._coercer.call(void 0, newValue, this._coercionConfig);\n    }\n    const oldValue = this._value;\n    if (this._observing) {\n      if (areEqual(newValue, this._value)) {\n        return;\n      }\n      this._value = newValue;\n      this.subs.notifyDirty();\n      this.subs.notify(newValue, oldValue);\n\n      // only call the callback if _value is the same with newValue\n      // which means if during subs.notify() the value of this observer is changed\n      // then it's the job of that setValue() to call the callback\n      if (areEqual(newValue, this._value)) {\n        this._callback?.(newValue, oldValue);\n      }\n    } else {\n      // If subscribe() has been called, the target property descriptor is replaced by these getter/setter methods,\n      // so calling obj[propertyKey] will actually return this.value.\n      // However, if subscribe() was not yet called (indicated by !this.observing), the target descriptor\n      // is unmodified and we need to explicitly set the property value.\n      // This will happen in one-time, to-view and two-way bindings during bind, meaning that the bind will not actually update the target value.\n      // This wasn't visible in vCurrent due to connect-queue always doing a delayed update, so in many cases it didn't matter whether bind updated the target or not.\n      this._value = this._obj[this._key] = newValue;\n      this._callback?.(newValue, oldValue);\n    }\n  }\n\n  public useCallback(callback: (newValue: unknown, oldValue: unknown) => void): boolean {\n    this._callback = callback;\n    this.start();\n    return true;\n  }\n\n  public useCoercer(coercer: InterceptorFunc, coercionConfig?: ICoercionConfiguration | undefined): boolean {\n    this._coercer = coercer;\n    this._coercionConfig = coercionConfig;\n    this.start();\n    return true;\n  }\n\n  public subscribe(subscriber: ISubscriber): void {\n    if (this._observing === false) {\n      this.start();\n    }\n\n    this.subs.add(subscriber);\n  }\n\n  public start(): this {\n    if (this._observing === false) {\n      this._observing = true;\n      this._value = this._obj[this._key];\n      rtDef(\n        this._obj,\n        this._key,\n        {\n          enumerable: true,\n          configurable: true,\n          get: rtObjectAssign((/* Setter Observer */) => this.getValue(), { getObserver: () => this }),\n          set: (/* Setter Observer */value) => {\n            this.setValue(value);\n          },\n        },\n      );\n    }\n    return this;\n  }\n\n  public stop(): this {\n    if (this._observing) {\n      rtDef(this._obj, this._key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: this._value,\n      });\n      this._observing = false;\n      // todo(bigopon/fred): add .removeAllSubscribers()\n    }\n    return this;\n  }\n}\n", "import { Primitive, isArrayIndex, ILogger, resolve, isFunction, isObject, isSet, isArray, isMap, createLookup } from '@aurelia/kernel';\nimport { ArrayObserver, getArrayObserver } from './array-observer';\nimport { ComputedGetterFn, ComputedObserver } from './computed-observer';\nimport { IDirtyChecker } from './dirty-checker';\nimport { MapObserver, getMapObserver } from './map-observer';\nimport { PrimitiveObserver } from './primitive-observer';\nimport { PropertyAccessor } from './property-accessor';\nimport { SetObserver, getSetObserver } from './set-observer';\nimport { SetterObserver } from './setter-observer';\nimport { rtDef, hasOwnProp, rtCreateInterface, rtObjectAssign } from './utilities';\n\nimport type {\n  Collection,\n  IAccessor,\n  ICollectionObserver,\n  IObservable,\n  IObserver,\n  AccessorOrObserver,\n  CollectionObserver,\n} from './interfaces';\nimport { ErrorNames, createMappedError } from './errors';\nimport { computedPropInfo } from './object-property-info';\n\nconst propertyAccessor = new PropertyAccessor();\n\nexport interface IObjectObservationAdapter {\n  getObserver(object: unknown, key: PropertyKey, descriptor: PropertyDescriptor, requestor: IObserverLocator): IObserver | null;\n}\n\nexport interface IObserverLocator extends ObserverLocator {}\nexport const IObserverLocator = /*@__PURE__*/rtCreateInterface<IObserverLocator>('IObserverLocator', x => x.singleton(ObserverLocator));\n\nexport interface INodeObserverLocator {\n  handles(obj: unknown, key: PropertyKey, requestor: IObserverLocator): boolean;\n  getObserver(obj: object, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver;\n  getAccessor(obj: object, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver;\n}\nexport const INodeObserverLocator = /*@__PURE__*/rtCreateInterface<INodeObserverLocator>('INodeObserverLocator', x => x.cachedCallback(handler => {\n  if (__DEV__) {\n    handler.getAll(ILogger).forEach(logger => {\n      logger.error('Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).');\n    });\n  }\n  return new DefaultNodeObserverLocator();\n}));\n\nclass DefaultNodeObserverLocator implements INodeObserverLocator {\n  public handles(): boolean {\n    return false;\n  }\n  public getObserver(): IAccessor | IObserver {\n    return propertyAccessor;\n  }\n  public getAccessor(): IAccessor | IObserver {\n    return propertyAccessor;\n  }\n}\n\nexport interface IComputedObserverLocator {\n  getObserver(obj: object, key: PropertyKey, pd: ExtendedPropertyDescriptor, requestor: IObserverLocator): IObserver;\n}\nexport const IComputedObserverLocator = /*@__PURE__*/rtCreateInterface<IComputedObserverLocator>(\n  'IComputedObserverLocator',\n  x => x.singleton(class DefaultLocator implements IComputedObserverLocator {\n    public getObserver(obj: object, key: PropertyKey, pd: ExtendedPropertyDescriptor, requestor: IObserverLocator): IObserver {\n      const observer = new ComputedObserver(\n        obj,\n        pd.get!,\n        pd.set,\n        requestor,\n        computedPropInfo._getFlush(obj, key)\n      );\n      rtDef(obj, key, {\n        enumerable: pd.enumerable,\n        configurable: true,\n        get: rtObjectAssign(((/* Computed Observer */) => observer.getValue()) as ObservableGetter, { getObserver: () => observer }),\n        set: (/* Computed Observer */v) => {\n          observer.setValue(v);\n        },\n      });\n\n      return observer;\n    }\n  })\n);\n\nexport type ExtendedPropertyDescriptor = PropertyDescriptor & {\n  get?: ObservableGetter;\n};\nexport type ObservableGetter = PropertyDescriptor['get'] & {\n  getObserver?(obj: unknown): IObserver;\n};\n\nexport class ObserverLocator {\n  /** @internal */ private readonly _adapters: IObjectObservationAdapter[] = [];\n  /** @internal */ private readonly _dirtyChecker = resolve(IDirtyChecker);\n  /** @internal */ private readonly _nodeObserverLocator = resolve(INodeObserverLocator);\n  /** @internal */ private readonly _computedObserverLocator = resolve(IComputedObserverLocator);\n\n  public addAdapter(adapter: IObjectObservationAdapter): void {\n    this._adapters.push(adapter);\n  }\n\n  public getObserver(obj: unknown, key: PropertyKey): IObserver;\n  public getObserver<T, R>(obj: T, key: ComputedGetterFn<T, R>): IObserver<R>;\n  public getObserver(obj: unknown, key: PropertyKey | ComputedGetterFn): IObserver {\n    if (obj == null) {\n      throw createMappedError(ErrorNames.observing_null_undefined, key);\n    }\n    if (!isObject(obj)) {\n      return new PrimitiveObserver(obj as Primitive, isFunction(key) ? '' : key);\n    }\n    if (isFunction(key)) {\n      return new ComputedObserver(obj, key, void 0, this);\n    }\n    const lookup = getObserverLookup(obj);\n    let observer = lookup[key];\n    if (observer === void 0) {\n      observer = this.createObserver((obj as IObservable), key);\n      if (!observer.doNotCache) {\n        lookup[key] = observer;\n      }\n    }\n    return observer;\n  }\n\n  public getAccessor(obj: object, key: PropertyKey): AccessorOrObserver {\n    const cached = (obj as IObservable).$observers?.[key];\n    if (cached !== void 0) {\n      return cached;\n    }\n    if (this._nodeObserverLocator.handles(obj, key, this)) {\n      return this._nodeObserverLocator.getAccessor(obj, key, this) as AccessorOrObserver;\n    }\n\n    return propertyAccessor;\n  }\n\n  public getArrayObserver(observedArray: unknown[]): ICollectionObserver<'array'> {\n    return getArrayObserver(observedArray);\n  }\n\n  public getMapObserver(observedMap: Map<unknown, unknown>): ICollectionObserver<'map'>  {\n    return getMapObserver(observedMap);\n  }\n\n  public getSetObserver(observedSet: Set<unknown>): ICollectionObserver<'set'>  {\n    return getSetObserver(observedSet);\n  }\n\n  private createObserver(obj: IObservable, key: PropertyKey): IObserver {\n    if (this._nodeObserverLocator.handles(obj, key, this)) {\n      return this._nodeObserverLocator.getObserver(obj, key, this) as IObserver;\n    }\n\n    switch (key) {\n      case 'length':\n        if (isArray(obj)) {\n          return getArrayObserver(obj).getLengthObserver();\n        }\n        break;\n      case 'size':\n        if (isMap(obj)) {\n          return getMapObserver(obj).getLengthObserver();\n        } else if (isSet(obj)) {\n          return getSetObserver(obj).getLengthObserver();\n        }\n        break;\n      default:\n        if (isArray(obj) && isArrayIndex(key)) {\n          return getArrayObserver(obj).getIndexObserver(Number(key));\n        }\n        break;\n    }\n\n    let pd = getOwnPropDesc(obj, key) as ExtendedPropertyDescriptor;\n    // Only instance properties will yield a descriptor here, otherwise walk up the proto chain\n    if (pd === void 0) {\n      let proto = getProto(obj) as object | null;\n      while (proto !== null) {\n        pd = getOwnPropDesc(proto, key) as ExtendedPropertyDescriptor;\n        if (pd === void 0) {\n          proto = getProto(proto) as object | null;\n        } else {\n          break;\n        }\n      }\n    }\n\n    // If the descriptor does not have a 'value' prop, it must have a getter and/or setter\n    if (pd !== void 0 && !hasOwnProp.call(pd, 'value')) {\n      let obs: IObserver | undefined | null = this._getAdapterObserver(obj, key, pd);\n      if (obs == null) {\n        obs = (pd.get?.getObserver)?.(obj);\n      }\n\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      return obs == null\n        ? pd.configurable\n          // ? this._createComputedObserver(obj, key, pd, true)\n          ? this._computedObserverLocator.getObserver(obj, key, pd, this)\n          : this._dirtyChecker.createProperty(obj, key)\n        : obs;\n    }\n\n    // Ordinary get/set observation (the common use case)\n    // TODO: think about how to handle a data property that does not sit on the instance (should we do anything different?)\n    return new SetterObserver(obj, key);\n  }\n\n  // /** @internal */\n  // private _createComputedObserver(obj: object, key: PropertyKey, pd: PropertyDescriptor, useProxy?: boolean) {\n  //   const observer = new ComputedObserver(obj, pd.get!, pd.set, this, !!useProxy);\n  //   def(obj, key, {\n  //     enumerable: pd.enumerable,\n  //     configurable: true,\n  //     get: objectAssign(((/* Computed Observer */) => observer.getValue()) as ObservableGetter, { getObserver: () => observer }),\n  //     set: (/* Computed Observer */v) => {\n  //       observer.setValue(v);\n  //     },\n  //   });\n\n  //   return observer;\n  // }\n\n  /** @internal */\n  private _getAdapterObserver(obj: IObservable, key: PropertyKey, pd: PropertyDescriptor): IObserver | null {\n    if (this._adapters.length > 0) {\n      for (const adapter of this._adapters) {\n        const observer = adapter.getObserver(obj, key, pd, this);\n        if (observer != null) {\n          return observer;\n        }\n      }\n    }\n    return null;\n  }\n}\n\nexport type RepeatableCollection = Collection | null | undefined | number;\n// T extends unknown[]\n//   ? ArrayObserver\n//   : T extends Map<unknown, unknown>\n//     ? MapObserver\n//     : T extends Set<unknown>\n//       ? SetObserver\n//       :\nexport const getCollectionObserver: {\n  (array: unknown[]): ArrayObserver;\n  (map: Map<unknown, unknown>): MapObserver;\n  (set: Set<unknown>): SetObserver;\n  (collection: RepeatableCollection): CollectionObserver | undefined;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n} = (collection: RepeatableCollection): any => {\n  let obs: CollectionObserver | undefined;\n  if (isArray(collection)) {\n    obs = getArrayObserver(collection);\n  } else if (isMap(collection)) {\n    obs = getMapObserver(collection);\n  } else if (isSet(collection)) {\n    obs = getSetObserver(collection);\n  }\n  return obs;\n};\n\nconst getProto = Object.getPrototypeOf;\nconst getOwnPropDesc = Object.getOwnPropertyDescriptor;\n\nexport const getObserverLookup = <T extends IObserver>(instance: object): Record<PropertyKey, T> => {\n  let lookup = (instance as IObservable).$observers as Record<PropertyKey, T>;\n  if (lookup === void 0) {\n    rtDef(instance, '$observers', { value: lookup = createLookup() });\n  }\n  return lookup;\n};\n", "import { areEqual, isFunction, resolve } from '@aurelia/kernel';\nimport { IExpressionParser, IsBindingBehavior } from '@aurelia/expression-parser';\nimport { connectable, IObserverLocatorBasedConnectable, type IObserverRecord } from './connectable';\nimport { enterConnectable, exitConnectable } from './connectable-switcher';\nimport { IObserverLocator } from './observer-locator';\nimport { rtCreateInterface } from './utilities';\n\nimport { astEvaluate } from './ast.eval';\nimport { mixinNoopAstEvaluator } from './ast.utilities';\nimport { createMappedError, ErrorNames } from './errors';\nimport type { ICollectionSubscriber, IConnectable, ISubscriber } from './interfaces';\nimport { Scope } from './scope';\n\nexport interface IObservation {\n  /**\n   * Run an effect function an track the dependencies inside it,\n   * to re-run whenever a dependency has changed\n   */\n  run(fn: EffectRunFunc): IEffect;\n  /**\n   * Run a getter based on the given object as its first parameter and track the dependencies via this getter,\n   * to call the callback whenever the value has changed\n   */\n  watch<T, R>(\n    obj: T,\n    getter: (obj: T, watcher: IConnectable) => R,\n    callback: (value: R, oldValue: R | undefined) => unknown,\n    options?: IWatchOptions,\n  ): IEffect;\n  /**\n   * Run a expression based observer and call the callback whenever the value has changed\n   *\n   * Use options.immediate to indicate whether the callback should be called immediately on init\n   */\n  watchExpression<R>(\n    obj: object,\n    expression: string,\n    callback: (value: R, oldValue: R | undefined) => unknown,\n    options?: IWatchOptions,\n  ): IEffect;\n}\nexport const IObservation = /*@__PURE__*/rtCreateInterface<IObservation>('IObservation', x => x.singleton(Observation));\n\nexport interface IWatchOptions {\n  /**\n   * Indicates whether the callback of a watch should be immediately called on init\n   */\n  immediate?: boolean;\n}\n\nexport class Observation implements IObservation {\n  /** @internal */\n  private readonly oL = resolve(IObserverLocator);\n\n  /** @internal */\n  private readonly _parser = resolve(IExpressionParser);\n\n  public run(fn: EffectRunFunc): IEffect {\n    const effect = new RunEffect(this.oL, fn);\n    // todo: batch effect run after it's in\n    effect.run();\n    return effect;\n  }\n\n  public watch<T, R>(\n    obj: T,\n    getter: (obj: T, watcher: IConnectable) => R,\n    callback: (value: R, oldValue: R | undefined) => unknown,\n    options?: IWatchOptions,\n  ): IEffect {\n    // eslint-disable-next-line no-undef-init\n    let $oldValue: R | undefined = undefined;\n    let running = false;\n    let cleanupTask: (() => void) | undefined;\n    const observer = this.oL.getObserver(obj, getter);\n    const handleChange = (newValue: R, oldValue: R) => {\n      cleanupTask?.();\n      cleanupTask = void 0;\n      const result = callback(newValue, $oldValue = oldValue);\n      if (isFunction(result)) {\n        cleanupTask =  result as NonNullable<typeof cleanupTask>;\n      } else {\n        // throw or ignore?\n      }\n    };\n    const handler = {\n      handleChange\n    };\n    const run = () => {\n      if (running) return;\n      running = true;\n      observer.subscribe(handler);\n      handleChange(observer.getValue(), $oldValue as R);\n    };\n    const stop = () => {\n      if (!running) return;\n      running = false;\n      observer.unsubscribe(handler);\n      cleanupTask?.();\n      cleanupTask = void 0;\n    };\n\n    if (options?.immediate !== false) {\n      run();\n    }\n    return { run, stop };\n  }\n\n  public watchExpression<R>(\n    obj: object,\n    expression: string,\n    callback: (value: R, oldValue: R | undefined) => unknown,\n    options?: IWatchOptions\n  ): IEffect {\n    let running = false;\n    let cleanupTask: (() => void) | undefined;\n    const handleChange = (newValue: unknown, oldValue: unknown) => {\n      cleanupTask?.();\n      cleanupTask = void 0;\n      const result = callback(newValue as R, oldValue as R);\n      if (isFunction(result)) {\n        cleanupTask =  result as NonNullable<typeof cleanupTask>;\n      } else {\n        // throw or ignore?\n      }\n    };\n    const observer = new ExpressionObserver(\n      Scope.create(obj),\n      this.oL,\n      this._parser.parse(expression, 'IsProperty'),\n      handleChange,\n    );\n    const run = () => {\n      if (running) return;\n      running = true;\n      observer.run();\n    };\n    const stop = () => {\n      if (!running) return;\n      running = false;\n      observer.stop();\n      cleanupTask?.();\n      cleanupTask = void 0;\n    };\n    if (options?.immediate !== false) {\n      run();\n    }\n    return { run, stop };\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction testObservationWatch(a: IObservation) {\n  a.watch({ b: 5 }, o => o.b + 1, v => v.toFixed());\n  a.watch({ b: { c: '' } }, o => o.b.c === '', v => v);\n  a.watchExpression<number>({ b: { c: { d: 5 }} }, 'b.c.d', v => v.toFixed());\n}\n\nexport type EffectCleanupFunc = () => void;\nexport type EffectRunFunc = (this: IConnectable, runner: IConnectable) => EffectCleanupFunc | void;\nexport interface IEffect {\n  run(): void;\n  stop(): void;\n}\n\ninterface RunEffect extends IConnectable {}\nclass RunEffect implements IEffect, IObserverLocatorBasedConnectable, ISubscriber, ICollectionSubscriber {\n  static {\n    connectable(RunEffect, null!);\n  }\n\n  public readonly obs!: IObserverRecord;\n  // to configure this, potentially a 2nd parameter is needed for run\n  public maxRunCount: number = 10;\n  private queued: boolean = false;\n  private running: boolean = false;\n  private runCount: number = 0;\n  private stopped: boolean = false;\n\n  /** @internal */\n  private _cleanupTask: (() => void) | undefined = undefined;\n\n  public constructor(\n    public readonly oL: IObserverLocator,\n    public readonly fn: EffectRunFunc,\n  ) {\n  }\n\n  public handleChange(): void {\n    this.queued = true;\n    this.run();\n  }\n\n  public handleCollectionChange(): void {\n    this.queued = true;\n    this.run();\n  }\n\n  public run = () => {\n    if (this.stopped) {\n      throw createMappedError(ErrorNames.stopping_a_stopped_effect);\n    }\n    if (this.running) {\n      return;\n    }\n    ++this.runCount;\n    this.running = true;\n    this.queued = false;\n    ++this.obs.version;\n    try {\n      this._cleanupTask?.call(void 0);\n      enterConnectable(this);\n      this._cleanupTask = this.fn(this) as EffectCleanupFunc;\n    } finally {\n      this.obs.clear();\n      this.running = false;\n      exitConnectable(this);\n    }\n    // when doing this.fn(this), there's a chance that it has recursive effect\n    // continue to run for a certain number before bailing\n    // whenever there's a dependency change while running, this.queued will be true\n    // so we use it as an indicator to continue to run the effect\n    if (this.queued) {\n      if (this.runCount > this.maxRunCount) {\n        this.runCount = 0;\n        throw createMappedError(ErrorNames.effect_maximum_recursion_reached);\n      }\n      this.run();\n    } else {\n      this.runCount = 0;\n    }\n  };\n\n  public stop = () => {\n    this._cleanupTask?.call(void 0);\n    this._cleanupTask = void 0;\n    this.stopped = true;\n    this.obs.clearAll();\n  };\n}\n\ninterface ExpressionObserver extends IObserverLocatorBasedConnectable { }\n\nclass ExpressionObserver implements IObserverLocatorBasedConnectable,\n  ISubscriber,\n  ICollectionSubscriber {\n\n  static {\n    connectable(ExpressionObserver, null!);\n    mixinNoopAstEvaluator(ExpressionObserver);\n  }\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  /** @internal */\n  private readonly ast: IsBindingBehavior;\n\n  /** @internal */\n  private readonly _callback: (value: unknown, oldValue: unknown) => void;\n\n  /** @internal */\n  private readonly _scope: Scope;\n\n  public constructor(\n    scope: Scope,\n    public oL: IObserverLocator,\n    expression: IsBindingBehavior,\n    callback: (value: unknown, oldValue: unknown) => void,\n  ) {\n    this._scope = scope;\n    this.ast = expression;\n    this._callback = callback;\n  }\n\n  public handleChange(): void {\n    this.run();\n  }\n\n  public handleCollectionChange(): void {\n    this.run();\n  }\n\n  public run(): void {\n    this.obs.version++;\n    const oldValue = this._value;\n    const value = astEvaluate(this.ast, this._scope, this, this);\n    this.obs.clear();\n    if (!areEqual(value, oldValue)) {\n      this._value = value;\n      this._callback.call(void 0, value, oldValue);\n    }\n  }\n\n  public stop(): void {\n    this.obs.clearAll();\n    this._value = void 0;\n  }\n}\n\n", "import { AccessorType, IAccessor, ISubscriberCollection, atObserver } from './interfaces';\nimport { rtSafeString, rtDef } from './utilities';\nimport { currentConnectable } from './connectable-switcher';\n\nimport { areEqual, emptyObject, isFunction, type Constructable, type IIndexable } from '@aurelia/kernel';\nimport type { InterceptorFunc, IObservable } from './interfaces';\nimport type { ObservableGetter } from './observer-locator';\nimport type { SetterObserver } from './setter-observer';\nimport { subscriberCollection } from './subscriber-collection';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface IObservableDefinition {\n  name?: PropertyKey;\n  callback?: PropertyKey;\n  set?: InterceptorFunc;\n}\n\ntype FieldInitializer<TFThis, TValue> = (this: TFThis, initialValue: TValue) => TValue;\ntype ObservableFieldDecorator<TFThis, TValue> = (target: undefined, context: ClassFieldDecoratorContext<TFThis, TValue>) => FieldInitializer<TFThis, TValue>;\ntype ObservableClassDecorator<TCThis extends Constructable> = (target: TCThis, context: ClassDecoratorContext<TCThis>) => void;\n\nexport const observable = /*@__PURE__*/(() => {\n\n  function getObserversLookup(obj: IObservable): IIndexable<{}, SetterObserver | SetterNotifier> {\n    if (obj.$observers === void 0) {\n      rtDef(obj, '$observers', { value: {} });\n      // todo: define in a weakmap\n    }\n    return obj.$observers as IIndexable<{}, SetterObserver | SetterNotifier>;\n  }\n\n  const noValue: unknown = {};\n  // for\n  //    class {\n  //      @observable prop\n  //    }\n  function observable<TFThis, TValue>(target: undefined, context: ClassFieldDecoratorContext<TFThis, TValue>): FieldInitializer<TFThis, TValue>;\n  // for\n  //    @observable({...})\n  //    class {}\n  // and\n  //    class {\n  //      @observable({...}) prop\n  //    }\n  function observable<TCThis extends Constructable, TFThis, TValue>(config: IObservableDefinition): (target: TCThis | undefined, context: ClassDecoratorContext<TCThis> | ClassFieldDecoratorContext<TFThis, TValue>) => FieldInitializer<TFThis, TValue> | void;\n  // for\n  //    @observable('') class {}\n  //    @observable(5) class {}\n  //    @observable(Symbol()) class {}\n  function observable<TCThis extends Constructable>(key: PropertyKey): ObservableClassDecorator<TCThis>;\n  // for:\n  //    class {\n  //      @observable() prop\n  //    }\n  function observable<TFThis, TValue>(): ObservableFieldDecorator<TFThis, TValue>;\n  // impl, wont be seen\n  function observable<TCThis extends Constructable, TFThis, TValue>(targetOrConfig?: undefined | IObservableDefinition | PropertyKey, context?: ClassFieldDecoratorContext): ObservableClassDecorator<TCThis> | ObservableFieldDecorator<TFThis, TValue> | FieldInitializer<TFThis, TValue> {\n    if (!SetterNotifier.mixed) {\n      SetterNotifier.mixed = true;\n      subscriberCollection(SetterNotifier, null!);\n    }\n\n    let isClassDecorator = false;\n    let config: IObservableDefinition;\n    if (typeof targetOrConfig === 'object') {\n      config = targetOrConfig;\n    } else if (targetOrConfig != null) {\n      config = { name: targetOrConfig };\n      isClassDecorator = true;\n    } else {\n      config = emptyObject;\n    }\n\n    // case: @observable() prop\n    if (arguments.length === 0) {\n      return function (target: unknown, context: DecoratorContext) {\n        if (context.kind !== 'field') throw createMappedError(ErrorNames.invalid_observable_decorator_usage);\n        return createFieldInitializer(context);\n      };\n    }\n\n    // case: @observable prop\n    if (context?.kind === 'field') return createFieldInitializer(context);\n\n    // case:  @observable(PropertyKey) class\n    if (isClassDecorator) {\n      return function (target: TCThis, context: ClassDecoratorContext<TCThis>) {\n        createDescriptor(target, config.name!, () => noValue, true);\n      };\n    }\n\n    // case: @observable({...}) class | @observable({...}) prop\n    return function (target: Constructable | undefined, context: ClassFieldDecoratorContext | ClassDecoratorContext) {\n      switch (context.kind) {\n        case 'field': return createFieldInitializer(context);\n        case 'class': return createDescriptor(target, config.name!, () => noValue, true);\n        default: throw createMappedError(ErrorNames.invalid_observable_decorator_usage);\n      }\n    };\n\n    function createFieldInitializer(context: ClassFieldDecoratorContext): FieldInitializer<TFThis, TValue> {\n      let $initialValue: TValue;\n      context.addInitializer(function (this: unknown) {\n        createDescriptor(this, context.name, () => $initialValue, false);\n      });\n      return function (this: TFThis, initialValue: TValue) {\n        return $initialValue = initialValue;\n      };\n    }\n    function createDescriptor(target: unknown, property: PropertyKey, initialValue: () => unknown, targetIsClass: boolean): void {\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing, @typescript-eslint/strict-boolean-expressions\n      const callback = config.callback || `${rtSafeString(property)}Changed`;\n      const $set = config.set;\n      const observableGetter: ObservableGetter = function (this: IObservable) {\n        const notifier = getNotifier(this, property, callback, initialValue, $set);\n        currentConnectable()?.subscribeTo(notifier);\n        return notifier.getValue();\n      };\n      observableGetter.getObserver = function (obj: IObservable) {\n        return getNotifier(obj, property, callback, initialValue, $set);\n      };\n\n      const descriptor = {\n        enumerable: true,\n        configurable: true,\n        get: observableGetter,\n        set(this: IObservable, newValue: TValue) {\n          getNotifier(this, property, callback, initialValue, $set).setValue(newValue);\n        }\n      };\n      if (targetIsClass) rtDef((target as Constructable).prototype as object, property, descriptor);\n      else rtDef(target as object, property, descriptor);\n    }\n  }\n\n  function getNotifier(\n    obj: IObservable,\n    key: PropertyKey,\n    callbackKey: PropertyKey,\n    initialValue: () => unknown,\n    set: InterceptorFunc | undefined,\n  ): SetterNotifier {\n    const lookup = getObserversLookup(obj) as unknown as Record<PropertyKey, SetterObserver | SetterNotifier>;\n    let notifier = lookup[key as string] as SetterNotifier;\n    if (notifier == null) {\n      const $initialValue = initialValue();\n      notifier = new SetterNotifier(obj, callbackKey, set, $initialValue === noValue ? void 0 : $initialValue);\n      lookup[key as string] = notifier;\n    }\n    return notifier;\n  }\n\n  type ChangeHandlerCallback = (this: object, value: unknown, oldValue: unknown) => void;\n\n  interface SetterNotifier extends IAccessor, ISubscriberCollection { }\n\n  class SetterNotifier implements IAccessor {\n    public static mixed = false;\n    public readonly type: AccessorType = atObserver;\n\n    /** @internal */\n    private _value: unknown = void 0;\n    /** @internal */\n    private _oldValue: unknown = void 0;\n    /** @internal */\n    private readonly cb?: ChangeHandlerCallback;\n    /** @internal */\n    private readonly _obj: object;\n    /** @internal */\n    private readonly _setter: InterceptorFunc | undefined;\n    /** @internal */\n    private readonly _hasSetter: boolean;\n\n    public constructor(\n      obj: object,\n      callbackKey: PropertyKey,\n      set: InterceptorFunc | undefined,\n      initialValue: unknown,\n    ) {\n      this._obj = obj;\n      this._setter = set;\n      this._hasSetter = isFunction(set);\n      const callback = (obj as IIndexable)[callbackKey as string];\n      this.cb = isFunction(callback) ? callback as ChangeHandlerCallback : void 0;\n      this._value = initialValue;\n    }\n\n    public getValue(): unknown {\n      return this._value;\n    }\n\n    public setValue(value: unknown): void {\n      if (this._hasSetter) {\n        value = this._setter!(value);\n      }\n      if (!areEqual(value, this._value)) {\n        this._oldValue = this._value;\n        this._value = value;\n        this.subs.notifyDirty();\n        this.subs.notify(this._value, this._oldValue);\n        // if the value has been changed during the notify, don't call the callback\n        // it's the job of the last .setValue() to call the callback\n        if (areEqual(value, this._value)) {\n          this.cb?.call(this._obj, this._value, this._oldValue);\n        }\n      }\n    }\n  }\n\n  /*\n            | typescript       | babel\n  ----------|------------------|-------------------------\n  property  | config           | config\n  w/parens  | target, key      | target, key, descriptor\n  ----------|------------------|-------------------------\n  property  | target, key      | target, key, descriptor\n  no parens | n/a              | n/a\n  ----------|------------------|-------------------------\n  class     | config           | config\n            | target           | target\n  */\n\n  return observable;\n})();\n", "import { Class, Constructable } from '@aurelia/kernel';\nimport { rtDefineHiddenProp, rtSafeString } from './utilities';\nimport { nowrapClassKey, nowrapPropKey } from './proxy-observation';\n\nexport function nowrap(): (target: unknown, context: ClassDecoratorContext | ClassFieldDecoratorContext) => void;\n/**\n * A decorator to signal proxy observation shouldn't make an effort to wrap an object\n */\n// for\n//    @nowrap\n//    class {}\nexport function nowrap(target: Constructable, context: ClassDecoratorContext): void;\n// for\n//    class {\n//      @nowrap prop\n//    }\nexport function nowrap(target: undefined, context: ClassFieldDecoratorContext): void;\n/**\n * A decorator to signal proxy observation shouldn't make an effort to wrap an object\n */\nexport function nowrap<\n  TThis extends object\n>(\n  target?: Class<TThis> | undefined,\n  context?: ClassDecoratorContext<Class<TThis>> | ClassFieldDecoratorContext<TThis>\n): void\n  | ((target: unknown, context: ClassDecoratorContext | ClassFieldDecoratorContext) => void) {\n  return arguments.length === 0 ? decorator : decorator(target!, context!);\n\n  function decorator(\n    target: unknown,\n    context: ClassDecoratorContext<Class<TThis>> | ClassFieldDecoratorContext<TThis>\n  ): void {\n    switch (context.kind) {\n      case 'class':\n        rtDefineHiddenProp(target as Class<TThis>, nowrapClassKey, true);\n        break;\n      case 'field':\n        context.addInitializer(function (this: object) {\n          const target = this.constructor;\n          const property = `${nowrapPropKey}_${rtSafeString(context.name)}__`;\n          if (property in target) return;\n          rtDefineHiddenProp(target, property, true);\n        });\n        break;\n    }\n  }\n}\n\n/* eslint-disable */\n// this is a test and will be automatically removed by dead code elimination\nfunction testNowrap() {\n  @nowrap\n  class MyModel {}\n\n  @nowrap()\n  class MyModel2 {}\n\n  class MyModel3 {\n    @nowrap public prop = 1;\n    @nowrap() public prop1 = 1;\n  }\n}\n/* eslint-enable */\n", "const tsPending = 'pending' as const;\nconst tsRunning = 'running' as const;\nconst tsCompleted = 'completed' as const;\nconst tsCanceled = 'canceled' as const;\nexport type TaskStatus = typeof tsPending | typeof tsRunning | typeof tsCompleted | typeof tsCanceled;\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst lookup = new Map<object, Platform>();\n\nconst notImplemented = (name: string): (...args: any[]) => any => {\n  return () => {\n    throw __DEV__\n      ? createError(`AUR1005: The PLATFORM did not receive a valid reference to the global function '${name}'.`) // TODO: link to docs describing how to fix this issue\n      : createError(`AUR1005:${name}`);\n  };\n};\n\nexport class Platform<TGlobal extends typeof globalThis = typeof globalThis> {\n  // http://www.ecma-international.org/ecma-262/#sec-value-properties-of-the-global-object\n  public readonly globalThis: TGlobal;\n\n  // http://www.ecma-international.org/ecma-262/#sec-function-properties-of-the-global-object\n  public readonly decodeURI!: TGlobal['decodeURI'];\n  public readonly decodeURIComponent!: TGlobal['decodeURIComponent'];\n  public readonly encodeURI!: TGlobal['encodeURI'];\n  public readonly encodeURIComponent!: TGlobal['encodeURIComponent'];\n\n  // http://www.ecma-international.org/ecma-262/#sec-constructor-properties-of-the-global-object\n  public readonly Date!: TGlobal['Date'];\n\n  // http://www.ecma-international.org/ecma-262/#sec-other-properties-of-the-global-object\n  public readonly Reflect!: TGlobal['Reflect'];\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope\n  // Note: we're essentially assuming that all of these are available, even if we aren't even\n  // in a browser environment. They are available in major envs as well (NodeJS, NativeScript, etc),\n  // or can otherwise be mocked fairly easily. If not, things probably won't work anyway.\n  public readonly clearInterval!: TGlobal['clearInterval'];\n  public readonly clearTimeout!: TGlobal['clearTimeout'];\n  public readonly queueMicrotask!: TGlobal['queueMicrotask'];\n  public readonly setInterval!: TGlobal['setInterval'];\n  public readonly setTimeout!: TGlobal['setTimeout'];\n  public readonly console!: TGlobal['console'];\n\n  public readonly performanceNow: () => number;\n\n  public readonly taskQueue: TaskQueue;\n\n  public constructor(g: TGlobal, overrides: Partial<Exclude<Platform, 'globalThis'>> = {}) {\n    this.globalThis = g;\n    'decodeURI decodeURIComponent encodeURI encodeURIComponent Date Reflect console'.split(' ').forEach(prop => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      (this as any)[prop] = prop in overrides ? overrides[prop as keyof typeof overrides] : g[prop as keyof typeof g];\n    });\n\n    'clearInterval clearTimeout queueMicrotask setInterval setTimeout'.split(' ').forEach(method => {\n      // eslint-disable-next-line\n      (this as any)[method] = method in overrides ? overrides[method as keyof typeof overrides] : (g as any)[method]?.bind(g) ?? notImplemented(method);\n    });\n\n    this.performanceNow = 'performanceNow' in overrides ? overrides.performanceNow! : g.performance?.now?.bind(g.performance) ?? notImplemented('performance.now');\n\n    this.flushMacroTask = this.flushMacroTask.bind(this);\n    this.taskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));\n  }\n\n  public static getOrCreate<TGlobal extends typeof globalThis = typeof globalThis>(\n    g: TGlobal,\n    overrides: Partial<Exclude<Platform, 'globalThis'>> = {},\n  ): Platform<TGlobal> {\n    let platform = lookup.get(g);\n    if (platform === void 0) {\n      lookup.set(g, platform = new Platform(g, overrides));\n    }\n    return platform as Platform<TGlobal>;\n  }\n\n  public static set(g: typeof globalThis, platform: Platform): void {\n    lookup.set(g, platform);\n  }\n\n  protected macroTaskRequested: boolean = false;\n  protected macroTaskHandle: number = -1;\n  protected requestMacroTask(): void {\n    this.macroTaskRequested = true;\n    if (this.macroTaskHandle === -1) {\n      this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);\n    }\n  }\n  protected cancelMacroTask(): void {\n    this.macroTaskRequested = false;\n    if (this.macroTaskHandle > -1) {\n      this.clearTimeout(this.macroTaskHandle);\n      this.macroTaskHandle = -1;\n    }\n  }\n  protected flushMacroTask(): void {\n    this.macroTaskHandle = -1;\n    if (this.macroTaskRequested === true) {\n      this.macroTaskRequested = false;\n      this.taskQueue.flush();\n    }\n  }\n}\n\ntype TaskCallback<T = any> = (delta: number) => T;\n\nexport class TaskQueue {\n\n  /** @internal */ public _suspenderTask: Task | undefined = void 0;\n  /** @internal */ public _pendingAsyncCount: number = 0;\n\n  /** @internal */\n  public _processing: Task[] = [];\n\n  /** @internal */\n  public _pending: Task[] = [];\n\n  /** @internal */\n  public _delayed: Task[] = [];\n\n  /** @internal */\n  public _flushRequested: boolean = false;\n\n  /** @internal */\n  private _yieldPromise: ExposedPromise | undefined = void 0;\n\n  /** @internal */\n  private _lastRequest: number = 0;\n\n  /** @internal */\n  private _lastFlush: number = 0;\n\n  /** @internal */\n  private readonly _now: () => number;\n\n  public get isEmpty(): boolean {\n    return (\n      this._pendingAsyncCount === 0 &&\n      this._processing.length === 0 &&\n      this._pending.length === 0 &&\n      this._delayed.length === 0\n    );\n  }\n\n  /**\n   * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,\n   * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.\n   *\n   * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.\n   *\n   * If that is the case, we can resolve the promise that was created when `yield()` is called.\n   *\n   * @internal\n   */\n  private get _hasNoMoreFiniteWork(): boolean {\n    return (\n      this._pendingAsyncCount === 0 &&\n      this._processing.every(isPersistent) &&\n      this._pending.every(isPersistent) &&\n      this._delayed.every(isPersistent)\n    );\n  }\n\n  /** @internal */ private readonly _tracer: Tracer;\n  public constructor(\n    public readonly platform: Platform,\n    private readonly $request: () => void,\n    private readonly $cancel: () => void,\n  ) {\n    this._now = platform.performanceNow;\n    this._tracer = new Tracer(platform.console);\n  }\n\n  public flush(now: number = this._now()): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'flush'); }\n\n    this._flushRequested = false;\n    this._lastFlush = now;\n\n    // Only process normally if we are *not* currently waiting for an async task to finish\n    if (this._suspenderTask === void 0) {\n      let curr: Task;\n      if (this._pending.length > 0) {\n        this._processing.push(...this._pending);\n        this._pending.length = 0;\n      }\n      if (this._delayed.length > 0) {\n        for (let i = 0; i < this._delayed.length; ++i) {\n          curr = this._delayed[i];\n          if (curr.queueTime <= now) {\n            this._processing.push(curr);\n            this._delayed.splice(i--, 1);\n          }\n        }\n      }\n\n      let cur: Task;\n      while (this._processing.length > 0) {\n        (cur = this._processing.shift()!).run();\n        // If it's still running, it can only be an async task\n        if (cur.status === tsRunning) {\n          if (cur.suspend === true) {\n            this._suspenderTask = cur;\n            this._requestFlush();\n\n            if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'flush early async'); }\n\n            return;\n          } else {\n            ++this._pendingAsyncCount;\n          }\n        }\n      }\n\n      if (this._pending.length > 0) {\n        this._processing.push(...this._pending);\n        this._pending.length = 0;\n      }\n      if (this._delayed.length > 0) {\n        for (let i = 0; i < this._delayed.length; ++i) {\n          curr = this._delayed[i];\n          if (curr.queueTime <= now) {\n            this._processing.push(curr);\n            this._delayed.splice(i--, 1);\n          }\n        }\n      }\n\n      if (this._processing.length > 0 || this._delayed.length > 0 || this._pendingAsyncCount > 0) {\n        this._requestFlush();\n      }\n\n      if (\n        this._yieldPromise !== void 0 &&\n        this._hasNoMoreFiniteWork\n      ) {\n        const p = this._yieldPromise;\n        this._yieldPromise = void 0;\n        p.resolve();\n      }\n    } else {\n      // If we are still waiting for an async task to finish, just schedule the next flush and do nothing else.\n      // Should the task finish before the next flush is invoked,\n      // the callback to `completeAsyncTask` will have reset `this.suspenderTask` back to undefined so processing can return back to normal next flush.\n      this._requestFlush();\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'flush full'); }\n  }\n\n  /**\n   * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.\n   *\n   * This operation is idempotent and will do nothing if no flush is scheduled.\n   */\n  public cancel(): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'cancel'); }\n\n    if (this._flushRequested) {\n      this.$cancel();\n      this._flushRequested = false;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel'); }\n  }\n\n  /**\n   * Returns a promise that, when awaited, resolves when:\n   * - all *non*-persistent (including async) tasks have finished;\n   * - the last-added persistent task has run exactly once;\n   *\n   * This operation is idempotent: the same promise will be returned until it resolves.\n   *\n   * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.\n   */\n  public async yield(): Promise<void> {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'yield'); }\n\n    if (this.isEmpty) {\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'yield empty'); }\n    } else {\n      if (this._yieldPromise === void 0) {\n        if (__DEV__ && this._tracer.enabled) { this._tracer.trace(this, 'yield - creating promise'); }\n        this._yieldPromise = createExposedPromise();\n      }\n\n      await this._yieldPromise;\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'yield task'); }\n    }\n  }\n\n  public queueTask<T = any>(callback: TaskCallback<T>, opts?: QueueTaskOptions): Task<T> {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'queueTask'); }\n\n    const { delay, preempt, persistent, suspend } = { ...defaultQueueTaskOptions, ...opts };\n\n    if (preempt) {\n      if (delay > 0) {\n        throw preemptDelayComboError();\n      }\n      if (persistent) {\n        throw preemptyPersistentComboError();\n      }\n    }\n\n    if (this._processing.length === 0) {\n      this._requestFlush();\n    }\n\n    const time = this._now();\n\n    const task = new Task(this._tracer, this, time, time + delay, preempt, persistent, suspend, callback);\n\n    if (preempt) {\n      this._processing[this._processing.length] = task;\n    } else if (delay === 0) {\n      this._pending[this._pending.length] = task;\n    } else {\n      this._delayed[this._delayed.length] = task;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'queueTask'); }\n\n    return task;\n  }\n\n  /**\n   * Remove the task from this queue.\n   */\n  public remove<T = any>(task: Task<T>): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'remove'); }\n\n    let idx = this._processing.indexOf(task);\n    if (idx > -1) {\n      this._processing.splice(idx, 1);\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove processing'); }\n      return;\n    }\n    idx = this._pending.indexOf(task);\n    if (idx > -1) {\n      this._pending.splice(idx, 1);\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove pending'); }\n      return;\n    }\n    idx = this._delayed.indexOf(task);\n    if (idx > -1) {\n      this._delayed.splice(idx, 1);\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove delayed'); }\n      return;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'remove error'); }\n\n    throw createError(`Task #${task.id} could not be found`);\n  }\n\n  /**\n   * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.\n   *\n   * @internal\n   */\n  public _resetPersistentTask(task: Task): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'resetPersistentTask'); }\n\n    task.reset(this._now());\n\n    if (task.createdTime === task.queueTime) {\n      this._pending[this._pending.length] = task;\n    } else {\n      this._delayed[this._delayed.length] = task;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'resetPersistentTask'); }\n  }\n\n  /**\n   * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.\n   *\n   * @internal\n   */\n  public _completeAsyncTask(task: Task): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'completeAsyncTask'); }\n\n    if (task.suspend === true) {\n      if (this._suspenderTask !== task) {\n        if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'completeAsyncTask error'); }\n\n        throw createError(`Async task completion mismatch: suspenderTask=${this._suspenderTask?.id}, task=${task.id}`);\n      }\n\n      this._suspenderTask = void 0;\n    } else {\n      --this._pendingAsyncCount;\n    }\n\n    if (\n      this._yieldPromise !== void 0 &&\n      this._hasNoMoreFiniteWork\n    ) {\n      const p = this._yieldPromise;\n      this._yieldPromise = void 0;\n      p.resolve();\n    }\n\n    if (this.isEmpty) {\n      this.cancel();\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'completeAsyncTask'); }\n  }\n\n  /** @internal */\n  private readonly _requestFlush: () => void = () => {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'requestFlush'); }\n\n    if (!this._flushRequested) {\n      this._flushRequested = true;\n      this._lastRequest = this._now();\n      this.$request();\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'requestFlush'); }\n  };\n}\n\nexport class TaskAbortError<T = any> extends Error {\n  public constructor(public task: Task<T>) {\n    super('Task was canceled.');\n  }\n}\n\nlet id: number = 0;\n\ntype UnwrapPromise<T> = T extends Promise<infer R> ? R : T;\n\nexport interface ITask<T = any> {\n  readonly result: Promise<UnwrapPromise<T>>;\n  readonly status: TaskStatus;\n  run(): void;\n  cancel(): boolean;\n}\n\nexport class Task<T = any> implements ITask {\n  public readonly id: number = ++id;\n\n  /** @internal */ private _resolve: PResolve<UnwrapPromise<T>> | undefined = void 0;\n  /** @internal */ private _reject: PReject<TaskAbortError<T>> | undefined = void 0;\n\n  /** @internal */\n  private _result: Promise<UnwrapPromise<T>> | undefined = void 0;\n  public get result(): Promise<UnwrapPromise<T>> {\n    const result = this._result;\n    if (result === void 0) {\n      switch (this._status) {\n        case tsPending: {\n          const promise = this._result = createExposedPromise();\n          this._resolve = promise.resolve;\n          this._reject = promise.reject;\n          return promise;\n        }\n        /* istanbul ignore next */\n        case tsRunning:\n          throw createError('Trying to await task from within task will cause a deadlock.');\n        case tsCompleted:\n          return this._result = Promise.resolve() as unknown as Promise<UnwrapPromise<T>>;\n        case tsCanceled:\n          return this._result = Promise.reject(new TaskAbortError(this));\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  private _status: TaskStatus = tsPending;\n  public get status(): TaskStatus {\n    return this._status;\n  }\n\n  /** @internal */\n  private readonly _tracer: Tracer;\n\n  public constructor(\n    tracer: Tracer,\n    public readonly taskQueue: TaskQueue,\n    public createdTime: number,\n    public queueTime: number,\n    public preempt: boolean,\n    public persistent: boolean,\n    public suspend: boolean,\n    public callback: TaskCallback<T>,\n  ) {\n    this._tracer = tracer;\n  }\n\n  public run(time: number = this.taskQueue.platform.performanceNow()): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'run'); }\n\n    if (this._status !== tsPending) {\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run error'); }\n\n      throw createError(`Cannot run task in ${this._status} state`);\n    }\n\n    // this.persistent could be changed while the task is running (this can only be done by the task itself if canceled, and is a valid way of stopping a loop)\n    // so we deliberately reference this.persistent instead of the local variable, but we keep it around to know whether the task *was* persistent before running it,\n    // so we can set the correct cancelation state.\n    const {\n      persistent,\n      taskQueue,\n      callback,\n      _resolve: resolve,\n      _reject: reject,\n      createdTime,\n    } = this;\n    let ret: unknown;\n\n    this._status = tsRunning;\n\n    try {\n      ret = callback(time - createdTime);\n      if (ret instanceof Promise) {\n        ret.then($ret => {\n          if (this.persistent) {\n            taskQueue._resetPersistentTask(this);\n          } else {\n            if (persistent) {\n              // Persistent tasks never reach completed status. They're either pending, running, or canceled.\n              this._status = tsCanceled;\n            } else {\n              this._status = tsCompleted;\n            }\n\n            this.dispose();\n          }\n\n          taskQueue._completeAsyncTask(this);\n\n          if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run async then'); }\n\n          if (resolve !== void 0) {\n            resolve($ret as UnwrapPromise<T>);\n          }\n        })\n        .catch((err: TaskAbortError<T>) => {\n          if (!this.persistent) {\n            this.dispose();\n          }\n\n          taskQueue._completeAsyncTask(this);\n\n          if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run async catch'); }\n\n          if (reject !== void 0) {\n            reject(err);\n          } else {\n            throw err;\n          }\n        });\n      } else {\n        if (this.persistent) {\n          taskQueue._resetPersistentTask(this);\n        } else {\n          if (persistent) {\n            // Persistent tasks never reach completed status. They're either pending, running, or canceled.\n            this._status = tsCanceled;\n          } else {\n            this._status = tsCompleted;\n          }\n\n          this.dispose();\n        }\n\n        if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run sync success'); }\n\n        if (resolve !== void 0) {\n          resolve(ret as UnwrapPromise<T>);\n        }\n      }\n    } catch (err) {\n      if (!this.persistent) {\n        this.dispose();\n      }\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'run sync error'); }\n\n      if (reject !== void 0) {\n        reject(err as TaskAbortError<T>);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  public cancel(): boolean {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'cancel'); }\n\n    if (this._status === tsPending) {\n      const taskQueue = this.taskQueue;\n      const reject = this._reject;\n\n      taskQueue.remove(this);\n\n      if (taskQueue.isEmpty) {\n        taskQueue.cancel();\n      }\n\n      this._status = tsCanceled;\n\n      this.dispose();\n\n      if (reject !== void 0) {\n        reject(new TaskAbortError(this));\n      }\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel true =pending'); }\n\n      return true;\n    } else if (this._status === tsRunning && this.persistent) {\n      this.persistent = false;\n\n      if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel true =running+persistent'); }\n\n      return true;\n    }\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'cancel false'); }\n\n    return false;\n  }\n\n  public reset(time: number): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.enter(this, 'reset'); }\n\n    const delay = this.queueTime - this.createdTime;\n    this.createdTime = time;\n    this.queueTime = time + delay;\n    this._status = tsPending;\n\n    this._resolve = void 0;\n    this._reject = void 0;\n    this._result = void 0;\n\n    if (__DEV__ && this._tracer.enabled) { this._tracer.leave(this, 'reset'); }\n  }\n\n  public dispose(): void {\n    if (__DEV__ && this._tracer.enabled) { this._tracer.trace(this, 'dispose'); }\n\n    this.callback = (void 0)!;\n    this._resolve = void 0;\n    this._reject = void 0;\n    this._result = void 0;\n  }\n}\n\nexport type QueueTaskOptions = {\n  /**\n   * The number of milliseconds to wait before queueing the task.\n   *\n   * NOTE: just like `setTimeout`, there is no guarantee that the task will actually run\n   * after the specified delay. It is merely a *minimum* delay.\n   *\n   * Defaults to `0`\n   */\n  delay?: number;\n  /**\n   * If `true`, the task will be run synchronously if it is the same priority as the\n   * `TaskQueue` that is currently flushing. Otherwise, it will be run on the next tick.\n   *\n   * Defaults to `false`\n   */\n  preempt?: boolean;\n  /**\n   * If `true`, the task will be added back onto the queue after it finished running, indefinitely, until manually canceled.\n   *\n   * Defaults to `false`\n   */\n  persistent?: boolean;\n  /**\n   * If `true`, and the task callback returns a promise, that promise will be awaited before consecutive tasks are run.\n   *\n   * Defaults to `false`.\n   */\n  suspend?: boolean;\n};\n\nclass Tracer {\n  public enabled: boolean = false;\n  private depth: number = 0;\n  public constructor(private readonly console: Platform['console']) {}\n\n  public enter(obj: TaskQueue | Task, method: string): void {\n    this.log(`${'  '.repeat(this.depth++)}> `, obj, method);\n  }\n  public leave(obj: TaskQueue | Task, method: string): void {\n    this.log(`${'  '.repeat(--this.depth)}< `, obj, method);\n  }\n  public trace(obj: TaskQueue | Task, method: string): void {\n    this.log(`${'  '.repeat(this.depth)}- `, obj, method);\n  }\n\n  private log(prefix: string, obj: TaskQueue | Task, method: string): void {\n    if (obj instanceof TaskQueue) {\n      const processing = obj._processing.length;\n      const pending = obj._pending.length;\n      const delayed = obj._delayed.length;\n      const flushReq = obj._flushRequested;\n      const susTask = !!obj._suspenderTask;\n\n      const info = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;\n      this.console.log(`${prefix}[Q.${method}] ${info}`);\n    } else {\n      const id = obj['id'];\n      const created = Math.round(obj['createdTime'] * 10) / 10;\n      const queue = Math.round(obj['queueTime'] * 10) / 10;\n      const preempt = obj['preempt'];\n      const persistent = obj['persistent'];\n      const suspend = obj['suspend'];\n      const status = obj['_status'];\n\n      const info = `id=${id} created=${created} queue=${queue} preempt=${preempt} persistent=${persistent} status=${status} suspend=${suspend}`;\n      this.console.log(`${prefix}[T.${method}] ${info}`);\n    }\n  }\n}\n\nconst defaultQueueTaskOptions: Required<QueueTaskOptions> = {\n  delay: 0,\n  preempt: false,\n  persistent: false,\n  suspend: false,\n};\n\ntype PResolve<T> = (value: T | PromiseLike<T>) => void;\ntype PReject<T = any> = (reason?: T) => void;\nlet $resolve: PResolve<any>;\nlet $reject: PReject;\nconst executor = <T>(resolve: PResolve<T>, reject: PReject): void => {\n  $resolve = resolve;\n  $reject = reject;\n};\n\ntype ExposedPromise<T = void> = Promise<T> & {\n  resolve: PResolve<T>;\n  reject: PReject;\n};\n\n/**\n * Efficiently create a promise where the `resolve` and `reject` functions are stored as properties on the prommise itself.\n */\nconst createExposedPromise = <T>(): ExposedPromise<T> => {\n  const p = new Promise<T>(executor) as ExposedPromise<T>;\n  p.resolve = $resolve;\n  p.reject = $reject;\n  return p;\n};\n\nconst isPersistent = (task: Task): boolean => task.persistent;\n\nconst preemptDelayComboError = () =>\n  __DEV__\n    ? createError(`AUR1006: Invalid arguments: preempt cannot be combined with a greater-than-zero delay`)\n    : createError(`AUR1006`);\nconst preemptyPersistentComboError = () =>\n  __DEV__\n    ? createError(`AUR1007: Invalid arguments: preempt cannot be combined with persistent`)\n    : createError(`AUR1007`);\n\nconst createError = (msg: string) => new Error(msg);\n\n/**\n * Retrieve internal tasks information of a TaskQueue\n */\nexport const reportTaskQueue = (taskQueue: TaskQueue) => {\n  const processing = taskQueue._processing;\n  const pending = taskQueue._pending;\n  const delayed = taskQueue._delayed;\n  const flushReq = taskQueue._flushRequested;\n\n  return { processing, pending, delayed, flushRequested: flushReq };\n};\n\n/**\n * Flush a taskqueue and cancel all the tasks that are queued by the flush\n * Mainly for debugging purposes\n */\nexport const ensureEmpty = (taskQueue: TaskQueue) => {\n  taskQueue.flush();\n  taskQueue._pending.forEach((x: ITask) => x.cancel());\n};\n", "import { Platform, TaskQueue } from '@aurelia/platform';\n\nexport class BrowserPlatform<TGlobal extends typeof globalThis = typeof globalThis> extends Platform<TGlobal> {\n  /** @internal */\n  private static readonly _lookup = new WeakMap<typeof globalThis, BrowserPlatform>();\n\n  public static getOrCreate<TGlobal extends typeof globalThis = typeof globalThis>(\n    g: TGlobal,\n    overrides: Partial<Exclude<BrowserPlatform, 'globalThis'>> = {},\n  ): BrowserPlatform<TGlobal> {\n    let platform = BrowserPlatform._lookup.get(g);\n    if (platform === void 0) {\n      BrowserPlatform._lookup.set(g, platform = new BrowserPlatform(g, overrides));\n    }\n    return platform as BrowserPlatform<TGlobal>;\n  }\n\n  public static set(g: typeof globalThis, platform: BrowserPlatform): void {\n    BrowserPlatform._lookup.set(g, platform);\n  }\n\n  public readonly Node!: TGlobal['Node'];\n  public readonly Element!: TGlobal['Element'];\n  public readonly HTMLElement!: TGlobal['HTMLElement'];\n  public readonly CustomEvent!: TGlobal['CustomEvent'];\n  public readonly CSSStyleSheet!: TGlobal['CSSStyleSheet'];\n  public readonly ShadowRoot!: TGlobal['ShadowRoot'];\n  public readonly MutationObserver!: TGlobal['MutationObserver'];\n\n  public readonly window!: TGlobal['window'];\n  public readonly document!: TGlobal['document'];\n  public readonly customElements!: TGlobal['customElements'];\n\n  public readonly fetch!: TGlobal['window']['fetch'];\n  public readonly requestAnimationFrame!: TGlobal['requestAnimationFrame'];\n  public readonly cancelAnimationFrame!: TGlobal['cancelAnimationFrame'];\n\n  // In environments with nodejs types, the node globalThis for some reason overwrites that of the DOM, changing the signature\n  // of setTimeout etc to those of node.\n  // So, re-declaring these based on the Window type to ensure they have the DOM-based signature.\n  public readonly clearInterval!: TGlobal['window']['clearInterval'];\n  public readonly clearTimeout!: TGlobal['window']['clearTimeout'];\n  public readonly setInterval!: TGlobal['window']['setInterval'];\n  public readonly setTimeout!: TGlobal['window']['setTimeout'];\n  public readonly domQueue: TaskQueue;\n\n  /**\n   * @deprecated Use `platform.domQueue` instead.\n   */\n  public get domWriteQueue() {\n    if (__DEV__) {\n      this.console.log('[DEV:aurelia] platform.domQueue is deprecated, please use platform.domQueue instead.');\n    }\n    return this.domQueue;\n  }\n\n  /**\n   * @deprecated Use `platform.domQueue` instead.\n   */\n  public get domReadQueue() {\n    if (__DEV__) {\n      this.console.log('[DEV:aurelia] platform.domReadQueue has been removed, please use platform.domQueue instead.');\n    }\n    return this.domQueue;\n  }\n\n  public constructor(g: TGlobal, overrides: Partial<Exclude<BrowserPlatform, 'globalThis'>> = {}) {\n    super(g, overrides);\n\n    const notImplemented = (name: string) => () => {\n      // TODO: link to docs describing how to fix this issue\n      throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name}'.`);\n    };\n\n    ('Node Element HTMLElement CustomEvent CSSStyleSheet ShadowRoot MutationObserver '\n      + 'window document customElements')\n      .split(' ')\n      // eslint-disable-next-line\n      .forEach(prop => (this as any)[prop] = prop in overrides ? (overrides as any)[prop] : (g as any)[prop]);\n\n    'fetch requestAnimationFrame cancelAnimationFrame'.split(' ').forEach(prop =>\n      // eslint-disable-next-line\n      (this as any)[prop] = prop in overrides ? (overrides as any)[prop] : ((g as any)[prop]?.bind(g) ?? notImplemented(prop))\n    );\n\n    this.domQueue = (() => {\n      let domRequested: boolean = false;\n      let domHandle: number = -1;\n\n      const requestDomFlush = (): void => {\n        domRequested = true;\n        if (domHandle === -1) {\n          domHandle = this.requestAnimationFrame(flushDomQueue);\n        }\n      };\n\n      const cancelDomFlush = (): void => {\n        domRequested = false;\n        if (domHandle > -1) {\n          this.cancelAnimationFrame(domHandle);\n          domHandle = -1;\n        }\n      };\n\n      const flushDomQueue = (): void => {\n        domHandle = -1;\n        if (domRequested === true) {\n          domRequested = false;\n          domQueue.flush();\n        }\n      };\n\n      const domQueue = new TaskQueue(this, requestDomFlush, cancelDomFlush);\n      return domQueue;\n    })();\n  }\n}\n", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n", "import { TaskQueue } from '@aurelia/platform';\nimport { IDisposable, IServiceLocator } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { BindingMode } from '@aurelia/template-compiler';\nimport { State } from '../templating/controller';\n\n/** @internal */ export const { default: defaultMode, oneTime, toView, fromView, twoWay } = BindingMode;\nexport { BindingMode } from '@aurelia/template-compiler';\n\nexport interface IBindingController {\n  readonly state: State;\n}\n\nexport interface IBinding {\n  readonly isBound: boolean;\n  bind(scope: Scope): void;\n  unbind(): void;\n  get: IServiceLocator['get'];\n  useScope?(scope: Scope): void;\n  limit?(opts: IRateLimitOptions): IDisposable;\n}\n\nexport interface IRateLimitOptions {\n  type: 'throttle' | 'debounce';\n  delay: number;\n  queue: TaskQueue;\n  now: () => number;\n  signals: string[];\n}\n", "import { Metadata } from '@aurelia/metadata';\nimport { Protocol } from '@aurelia/kernel';\n\n/** @internal */ export const getMetadata = Metadata.get;\n/** @internal */ export const hasMetadata = Metadata.has;\n/** @internal */ export const defineMetadata = Metadata.define;\n\nconst { annotation } = Protocol;\n/** @internal */ export const getAnnotationKeyFor = annotation.keyFor;\n", "import { AccessorType, type ISubscriber } from '@aurelia/runtime';\nimport { type ISVGAnalyzer } from './observation/svg-analyzer';\nimport { type ISignaler } from './signaler';\nimport { createLookup, isString } from '@aurelia/kernel';\n\nconst O = Object;\n\n/** @internal */ export const safeString = String;\n\n/** @internal */ export const baseObjectPrototype = O.prototype;\n\n/** @internal */ export const hasOwnProperty = baseObjectPrototype.hasOwnProperty;\n\n/** @internal */ export const objectFreeze = O.freeze;\n\n/** @internal */ export const objectAssign = O.assign;\n\n/** @internal */ export const getOwnPropertyNames = O.getOwnPropertyNames;\n\n/** @internal */ export const objectKeys = O.keys;\n\nconst IsDataAttribute: Record<string, boolean> = /*@__PURE__*/createLookup();\n\n/** @internal */ export const isDataAttribute = (obj: Node, key: PropertyKey, svgAnalyzer: ISVGAnalyzer): boolean => {\n  if (IsDataAttribute[key as string] === true) {\n    return true;\n  }\n  if (!isString(key)) {\n    return false;\n  }\n  const prefix = key.slice(0, 5);\n  // https://html.spec.whatwg.org/multipage/dom.html#wai-aria\n  // https://html.spec.whatwg.org/multipage/dom.html#custom-data-attribute\n  return IsDataAttribute[key] =\n    prefix === 'aria-' ||\n    prefix === 'data-' ||\n    svgAnalyzer.isStandardSvgAttribute(obj, key);\n};\n\n/** @internal */ export const rethrow = (err: unknown) => { throw err; };\n\n/** @internal */\nexport const def = Reflect.defineProperty;\n\n/** @internal */\nexport const defineHiddenProp = <T>(obj: object, key: PropertyKey, value: T): T => {\n  def(obj, key, {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value\n  });\n  return value;\n};\n\n/** @internal */\nexport const addSignalListener = (signaler: ISignaler, signal: string, listener: ISubscriber) => signaler.addSignalListener(signal, listener);\n/** @internal */\nexport const removeSignalListener = (signaler: ISignaler, signal: string, listener: ISubscriber) => signaler.removeSignalListener(signal, listener);\n\n/** ExpressionType */\n/** @internal */ export const etInterpolation = 'Interpolation' as const;\n/** @internal */ export const etIsIterator = 'IsIterator' as const;\n/** @internal */ export const etIsFunction = 'IsFunction' as const;\n/** @internal */ export const etIsProperty = 'IsProperty' as const;\n\n/** TaskStatus */\n/** @internal */ export const tsPending = 'pending' as const;\n/** @internal */ export const tsRunning = 'running' as const;\n\n/** AccessorType */\n/** @internal */ export const atObserver: AccessorType = AccessorType.Observer;\n/** @internal */ export const atNode: AccessorType = AccessorType.Node;\n/** @internal */ export const atLayout: AccessorType = AccessorType.Layout;\n", "/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable prefer-template */\n\nimport { safeString } from './utilities';\n\n/** @internal */\nexport const createMappedError: CreateError = __DEV__\n  ? (code: ErrorNames, ...details: unknown[]) => {\n    const paddedCode = safeString(code).padStart(4, '0');\n    const message = getMessageByCode(code, ...details);\n    const link = `https://docs.aurelia.io/developer-guides/error-messages/runtime-html/aur${paddedCode}`;\n    return new Error(`AUR${paddedCode}: ${message}\\n\\nFor more information, see: ${link}`);\n  }\n  : (code: ErrorNames, ...details: unknown[]) => {\n    const paddedCode = safeString(code).padStart(4, '0');\n    return new Error(`AUR${paddedCode}:${details.map(safeString)}`);\n  };\n\n_START_CONST_ENUM();\n/** @internal */\nexport const enum ErrorNames {\n  method_not_implemented = 99,\n\n  ast_behavior_not_found = 101,\n  ast_behavior_duplicated = 102,\n  ast_converter_not_found = 103,\n  ast_$host_not_found = 105,\n  ast_no_assign_$host = 106,\n  ast_not_a_function = 107,\n  ast_unknown_binary_operator = 108,\n  ast_unknown_unary_operator = 109,\n  ast_tagged_not_a_function = 110,\n  ast_name_is_not_a_function = 111,\n  ast_destruct_null = 112,\n  ast_increment_infinite_loop = 113,\n  ast_nullish_member_access = 114,\n  ast_nullish_keyed_access = 115,\n  ast_nullish_assignment = 116,\n\n  binding_behavior_def_not_found = 151,\n  value_converter_def_not_found = 152,\n  element_existed = 153,\n  attribute_existed = 154,\n  value_converter_existed = 155,\n  binding_behavior_existed = 156,\n  binding_command_existed = 157,\n\n  null_scope = 203,\n  create_scope_with_null_context = 204,\n\n  invalid_bindable_decorator_usage_symbol = 227,\n  invalid_bindable_decorator_usage_class_without_configuration = 228,\n  invalid_bindable_decorator_usage_class_without_property_name_configuration = 229,\n\n  controller_cached_not_found = 500,\n  controller_no_shadow_on_containerless = 501,\n  controller_activating_disposed = 502,\n  controller_activation_unexpected_state = 503,\n  controller_activation_synthetic_no_scope = 504,\n  controller_deactivation_unexpected_state = 505,\n  controller_watch_invalid_callback = 506,\n  controller_property_not_coercible = 507,\n  controller_property_no_change_handler = 508,\n\n  node_observer_strategy_not_found = 652,\n  node_observer_mapping_existed = 653,\n  select_observer_array_on_non_multi_select = 654,\n\n  compiler_primary_already_existed = 714,\n  compiler_attr_mapper_duplicate_mapping = 719,\n  root_not_found = 767,\n  aurelia_instance_existed_in_container = 768,\n  invalid_platform_impl = 769,\n  no_composition_root = 770,\n  invalid_dispose_call = 771,\n\n  not_supported_view_ref_api = 750,\n  ref_not_found = 751,\n\n  element_res_not_found = 752,\n  attribute_res_not_found = 753,\n  attribute_tc_res_not_found = 754,\n  view_factory_provider_not_ready = 755,\n  view_factory_invalid_name = 756,\n\n  rendering_mismatch_length = 757,\n\n  attribute_def_not_found = 759,\n  element_def_not_found = 760,\n  element_only_name = 761,\n  node_is_not_a_host = 762,\n  node_is_not_a_host2 = 763,\n  node_is_not_part_of_aurelia_app = 764,\n  node_is_not_part_of_aurelia_app2 = 765,\n  invalid_process_content_hook = 766,\n\n  watch_null_config = 772,\n  watch_invalid_change_handler = 773,\n  watch_non_method_decorator_usage = 774,\n\n  repeat_invalid_key_binding_command = 775,\n  repeat_extraneous_binding = 776,\n  repeat_non_iterable = 777,\n  repeat_non_countable = 778,\n  repeat_mismatch_length = 814,\n\n  portal_invalid_insert_position = 779,\n\n  self_behavior_invalid_usage = 801,\n  update_trigger_behavior_no_triggers = 802,\n  update_trigger_invalid_usage = 803,\n  au_compose_invalid_scope_behavior = 805,\n  au_compose_component_name_not_found = 806,\n  au_compose_invalid_run = 807,\n  au_compose_duplicate_deactivate = 808,\n  else_without_if = 810,\n  portal_query_empty = 811,\n  portal_no_target = 812,\n  promise_invalid_usage = 813,\n  switch_invalid_usage = 815,\n  switch_no_multiple_default = 816,\n\n  signal_behavior_invalid_usage = 817,\n  signal_behavior_no_signals = 818,\n\n  spreading_bindable_onto_non_component = 819,\n  spreading_invalid_target = 820,\n\n  no_spread_scope_context_found = 9999,\n  no_spread_template_controller = 9998,\n  marker_malformed = 9997,\n  binding_already_has_rate_limited = 9996,\n  binding_already_has_target_subscriber = 9995,\n  attr_behavior_invalid_binding = 9994,\n  update_trigger_behavior_not_supported = 9993,\n  update_trigger_behavior_node_property_not_observable = 9992,\n\n  children_decorator_invalid_usage = 9991,\n  slotted_decorator_invalid_usage = 9990,\n  children_invalid_query = 9989,\n}\n_END_CONST_ENUM();\n\nconst errorsMap: Record<ErrorNames, string> = {\n  [ErrorNames.method_not_implemented]: 'Method {{0}} not implemented',\n\n  [ErrorNames.ast_behavior_not_found]: `Ast eval error: binding behavior \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_behavior_duplicated]: `Ast eval error: binding behavior \"{{0}}\" already applied.`,\n  [ErrorNames.ast_converter_not_found]: `Ast eval error: value converter \"{{0}}\" could not be found. Did you forget to register it as a dependency?`,\n  [ErrorNames.ast_$host_not_found]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,\n  [ErrorNames.ast_no_assign_$host]: `Ast eval error: invalid assignment. \"$host\" is a reserved keyword.`,\n  [ErrorNames.ast_not_a_function]: `Ast eval error: expression is not a function.`,\n  [ErrorNames.ast_unknown_unary_operator]: `Ast eval error: unknown unary operator: \"{{0}}\"`,\n  [ErrorNames.ast_unknown_binary_operator]: `Ast eval error: unknown binary operator: \"{{0}}\"`,\n  [ErrorNames.ast_tagged_not_a_function]: `Ast eval error: left-hand side of tagged template expression is not a function.`,\n  [ErrorNames.ast_name_is_not_a_function]: `Ast eval error: expected \"{{0}}\" to be a function`,\n  [ErrorNames.ast_destruct_null]: `Ast eval error: cannot use non-object value for destructuring assignment.`,\n  [ErrorNames.ast_increment_infinite_loop]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,\n  [ErrorNames.ast_nullish_member_access]: `Ast eval error: cannot access property \"{{0}}\" of {{1}}.`,\n  [ErrorNames.ast_nullish_keyed_access]: `Ast eval error: cannot access key \"{{0}}\" of {{1}}.`,\n  [ErrorNames.ast_nullish_assignment]: `Ast eval error: cannot assign value to property \"{{0}}\" of null/undefined.`,\n\n  [ErrorNames.binding_behavior_def_not_found]: `No binding behavior definition found for type {{0:name}}`,\n  [ErrorNames.value_converter_def_not_found]: `No value converter definition found for type {{0:name}}`,\n  [ErrorNames.element_existed]: `Element \"{{0}}\" has already been registered.`,\n  [ErrorNames.attribute_existed]: `Attribute \"{{0}}\" has already been registered.`,\n  [ErrorNames.value_converter_existed]: `Value converter {{0}} has already been registered.`,\n  [ErrorNames.binding_behavior_existed]: `Binding behavior {{0}} has already been registered.`,\n  [ErrorNames.binding_command_existed]: `Binding command {{0}} has already been registered.`,\n\n  [ErrorNames.null_scope]: `Trying to retrieve a property or build a scope from a null/undefined scope`,\n  [ErrorNames.create_scope_with_null_context]: 'Trying to create a scope with null/undefined binding context',\n\n  [ErrorNames.invalid_bindable_decorator_usage_symbol]: `@bindable is not supported for properties that uses a symbol for name. Use a string for the property name instead.`,\n  [ErrorNames.invalid_bindable_decorator_usage_class_without_configuration]: `@bindable cannot be used as a class decorator when no configuration object is supplied.`,\n  [ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration]: `@bindable cannot be used as a class decorator when no property name is supplied in the configuration object.`,\n\n  [ErrorNames.controller_cached_not_found]: `There is no cached controller for the provided ViewModel: {{0}}`,\n  [ErrorNames.controller_no_shadow_on_containerless]: `Invalid combination: cannot combine the containerless custom element option with Shadow DOM.`,\n  [ErrorNames.controller_activating_disposed]: `Trying to activate a disposed controller: {{0}}.`,\n  [ErrorNames.controller_activation_unexpected_state]: `Controller at {{0}} is in an unexpected state: {{1}} during activation.`,\n  [ErrorNames.controller_activation_synthetic_no_scope]: `Synthetic view at {{0}} is being activated with null/undefined scope.`,\n  [ErrorNames.controller_deactivation_unexpected_state]: `Controller at {{0}} is in an unexpected state: {{1}} during deactivation.`,\n  [ErrorNames.controller_watch_invalid_callback]: `Invalid callback for @watch decorator: {{0}}`,\n  [ErrorNames.controller_property_not_coercible]: `Observer for bindable property {{0}} does not support coercion.`,\n  [ErrorNames.controller_property_no_change_handler]: `Observer for property {{0}} does not support change handler.`,\n\n  [ErrorNames.attribute_def_not_found]: `No attribute definition found for type {{0:name}}`,\n  [ErrorNames.element_def_not_found]: `No element definition found for type {{0:name}}`,\n  [ErrorNames.element_only_name]: `Cannot create a custom element definition with only a name and no type: {{0}}`,\n  [ErrorNames.node_is_not_a_host]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,\n  [ErrorNames.node_is_not_a_host2]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,\n  [ErrorNames.node_is_not_part_of_aurelia_app]: `Trying to retrieve a custom element controller from a node.`\n    + ` But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree,`\n    + ` or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,\n  [ErrorNames.node_is_not_part_of_aurelia_app2]: `Trying to retrieve a custom element controller from a node.`\n    + ` But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree,`\n    + ` or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,\n  [ErrorNames.invalid_process_content_hook]: `Invalid @processContent hook. Expected the hook to be a function (when defined in a class, it needs to be a static function) but got a {{0:typeof}}.`,\n\n  [ErrorNames.node_observer_strategy_not_found]: `Aurelia is unable to observe property {{0}}. Register observation mapping with .useConfig().`,\n  [ErrorNames.node_observer_mapping_existed]: `Mapping for property {{0}} of <{{1}} /> already exists`,\n  [ErrorNames.select_observer_array_on_non_multi_select]: `Array values can only be bound to a multi-select.`,\n\n  [ErrorNames.compiler_primary_already_existed]: `Template compilation error: primary already exists on element/attribute \"{{0}}\"`,\n  [ErrorNames.compiler_attr_mapper_duplicate_mapping]: `Attribute {{0}} has been already registered for {{1:element}}`,\n\n  [ErrorNames.root_not_found]: `Aurelia.root was accessed without a valid root.`,\n  [ErrorNames.aurelia_instance_existed_in_container]: `An instance of Aurelia is already registered with the container or an ancestor of it.`,\n  [ErrorNames.invalid_platform_impl]: `Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView, did you create the host from a DOMParser and forget to call adoptNode()?`,\n  [ErrorNames.no_composition_root]: `Aurelia.start() was called without a composition root`,\n  [ErrorNames.invalid_dispose_call]: `The aurelia instance must be fully stopped before it can be disposed`,\n  [ErrorNames.not_supported_view_ref_api]: `view.ref is not supported. If you are migrating from v1, this can be understood as the controller.`,\n  [ErrorNames.ref_not_found]: `Attempted to reference \"{{0}}\", but it was not found amongst the target's API.`,\n  [ErrorNames.element_res_not_found]: `Element {{0:.res}} is not registered in {{1:name}}.`,\n  [ErrorNames.attribute_res_not_found]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,\n  [ErrorNames.attribute_tc_res_not_found]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,\n  [ErrorNames.view_factory_provider_not_ready]: `Cannot resolve ViewFactory before the provider was prepared.`,\n  [ErrorNames.view_factory_invalid_name]: `Cannot resolve ViewFactory without a (valid) name.`,\n\n  [ErrorNames.rendering_mismatch_length]: `AUR0757: The compiled template is not aligned with the render instructions. There are {{0}} targets and {{1}} instructions.`,\n\n  [ErrorNames.watch_null_config]: `Invalid @watch decorator config. Expected an expression or a fn but received null/undefined.`,\n  [ErrorNames.watch_invalid_change_handler]: `Invalid @watch decorator change handler config.`\n    + `Method \"{{0}}\" not found in class {{1}}`,\n  [ErrorNames.watch_non_method_decorator_usage]: `Invalid @watch decorator usage: decorated target {{0}} is not a class method.`,\n\n  [ErrorNames.repeat_invalid_key_binding_command]: `Invalid command \"{{0}}\" usage with [repeat]`,\n  [ErrorNames.repeat_extraneous_binding]: `Invalid [repeat] usage, found extraneous target \"{{0}}\"`,\n  [ErrorNames.repeat_non_iterable]: `Unsupported: [repeat] cannot iterate over {{0:toString}}`,\n  [ErrorNames.repeat_non_countable]: `Unsupported: [repeat] cannot count {{0:toString}}`,\n  [ErrorNames.repeat_mismatch_length]: `[repeat] encountered an error: number of views != number of items {{0:join(!=)}}`,\n\n  [ErrorNames.portal_invalid_insert_position]: 'Invalid portal insertion position: {{0}}',\n\n  [ErrorNames.self_behavior_invalid_usage]: `\"& self\" binding behavior only supports listener binding via trigger/capture command.`,\n  [ErrorNames.update_trigger_behavior_no_triggers]: `\"& updateTrigger\" invalid usage. This binding behavior requires at least one event name argument: eg <input value.bind=\"firstName & updateTrigger:'blur'\">`,\n  [ErrorNames.update_trigger_invalid_usage]: `\"& updateTrigger\" invalid usage. This binding behavior can only be applied to two-way/ from-view bindings.`,\n  [ErrorNames.au_compose_invalid_scope_behavior]: `Invalid scope behavior \"{{0}}\" on <au-compose />. Only \"scoped\" or \"auto\" allowed.`,\n  // originally not supported\n  [ErrorNames.au_compose_component_name_not_found]: `<au-compose /> couldn't find a custom element with name \"{{0}}\", did you forget to register it locally or globally?`,\n  [ErrorNames.au_compose_invalid_run]: `Composition has already been activated/deactivated. Id: {{0:controller}}`,\n  [ErrorNames.au_compose_duplicate_deactivate]: `Composition has already been deactivated.`,\n  [ErrorNames.else_without_if]: `Invalid [else] usage, it should follow an [if]`,\n  [ErrorNames.portal_query_empty]: `Invalid portal strict target query, empty query.`,\n  [ErrorNames.portal_no_target]: `Invalid portal strict target resolution, target not found.`,\n  [ErrorNames.promise_invalid_usage]: `Invalid [pending]/[then]/[catch] usage. The parent [promise].resolve not found; only \"*[promise.resolve] > *[pending|then|catch]\" relation is supported.`,\n  [ErrorNames.switch_invalid_usage]: `Invalid [case/default-case] usage. The parent [switch] not found; only \"*[switch] > *[case|default-case]\" relation is supported.`,\n  [ErrorNames.switch_no_multiple_default]: `Invalid [default-case] usage. Multiple 'default-case's are not allowed.`,\n  [ErrorNames.signal_behavior_invalid_usage]: `\"& signal\" binding behavior can only be used with bindings that have a \"handleChange\" method`,\n  [ErrorNames.signal_behavior_no_signals]: `\"& signal\" invalid usage. At least one signal name must be passed to the signal behavior, e.g. \"expr & signal:'my-signal'\"`,\n\n  [ErrorNames.spreading_bindable_onto_non_component]: 'Spreading to bindables onto non custom element',\n  [ErrorNames.spreading_invalid_target]: `Invalid spread target {{0}}`,\n\n  [ErrorNames.no_spread_scope_context_found]: 'No scope context for spread binding.',\n  [ErrorNames.no_spread_template_controller]: 'Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?',\n  [ErrorNames.marker_malformed]: `Marker is malformed. This likely happens when a compiled template has been modified.`\n    + ` Did you accidentally modified some compiled template? You can modify template before compilation with compiling Template compiler hook.`,\n  [ErrorNames.binding_already_has_rate_limited]: `Invalid usage, a rate limit has already been applied. Did you have both throttle and debounce on the same binding?`,\n  [ErrorNames.binding_already_has_target_subscriber]: `The binding already has a target subscriber.`,\n  [ErrorNames.attr_behavior_invalid_binding]: `\"& attr\" can be only used on property binding. It's used on {{0:ctor}}`,\n  [ErrorNames.update_trigger_behavior_not_supported]: '\"& updateTrigger\" binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger',\n  [ErrorNames.update_trigger_behavior_node_property_not_observable]: `\"& updateTrigger\" uses node observer to observe, but it does not know how to use events to observe property <{{0:target@property}} />`,\n\n  [ErrorNames.children_decorator_invalid_usage]: `Invalid @children usage. @children decorator can only be used on a field`,\n  [ErrorNames.slotted_decorator_invalid_usage]: `Invalid @slotted usage. @slotted decorator can only be used on a field`,\n  [ErrorNames.children_invalid_query]: `Invalid query selector. Only selectors with alpha-numeric characters, or $all are allowed. Got {{0}} instead.`\n};\n\nconst getMessageByCode = (name: ErrorNames, ...details: unknown[]) => {\n  let cooked: string = errorsMap[name];\n  for (let i = 0; i < details.length; ++i) {\n    const regex = new RegExp(`{{${i}(:.*)?}}`, 'g');\n    let matches = regex.exec(cooked);\n    while (matches != null) {\n      const method = matches[1]?.slice(1);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let value = details[i] as any;\n      if (value != null) {\n        switch (method) {\n          case 'nodeName': value = (value as Node).nodeName.toLowerCase(); break;\n          case 'name': value = (value as { name: string }).name; break;\n          case 'typeof': value = typeof value; break;\n          case 'ctor': value = (value as object).constructor.name; break;\n          case 'controller': value = value.controller.name; break;\n          case 'target@property': value = `${value.target}@${value.targetProperty}`; break;\n          case 'toString': value = Object.prototype.toString.call(value); break;\n          case 'join(!=)': value = (value as unknown[]).join('!='); break;\n          case 'bindingCommandHelp': value = getBindingCommandHelp(value); break;\n          case 'element': value = value === '*' ? 'all elements' : `<${value} />`; break;\n          default: {\n            // property access\n            if (method?.startsWith('.')) {\n              value = safeString(value[method.slice(1)]);\n            } else {\n              value = safeString(value);\n            }\n          }\n        }\n      }\n      cooked = cooked.slice(0, matches.index) + value + cooked.slice(regex.lastIndex);\n      matches = regex.exec(cooked);\n    }\n  }\n  return cooked;\n};\n\ntype CreateError = (code: ErrorNames, ...details: unknown[]) => Error;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction pleaseHelpCreateAnIssue(title: string, body?: string) {\n  return `\\nThis is likely an issue with Aurelia.\\n Please help create an issue by clicking the following link\\n`\n    + `https://github.com/aurelia/aurelia/issues/new?title=${encodeURIComponent(title)}`\n    + (body != null ? `&body=${encodeURIComponent(body)}` : '&template=bug_report.md');\n}\n\nfunction getBindingCommandHelp(name: string) {\n  switch (name) {\n    case 'delegate':\n      return `\\nThe \".delegate\" binding command has been removed in v2.`\n      + ` Binding command \".trigger\" should be used instead.`\n      + ` If you are migrating v1 application, install compat package`\n      + ` to add back the \".delegate\" binding command for ease of migration.`;\n    case 'call':\n      return `\\nThe \".call\" binding command has been removed in v2.`\n      + ` If you want to pass a callback that preserves the context of the function call,`\n      + ` you can use lambda instead. Refer to lambda expression doc for more details.`;\n    default:\n      return '';\n  }\n}\n", "import { kebabCase, getPrototypeChain, noop, type Class, createLookup, isString, type Constructable } from '@aurelia/kernel';\nimport { ICoercionConfiguration } from '@aurelia/runtime';\nimport { defaultMode, toView, twoWay } from './binding/interfaces-bindings';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata } from './utilities-metadata';\nimport { objectFreeze, objectKeys } from './utilities';\n\nimport type { InterceptorFunc } from '@aurelia/runtime';\nimport { ErrorNames, createMappedError } from './errors';\nimport { BindingMode, IComponentBindablePropDefinition } from '@aurelia/template-compiler';\n\ntype PropertyType = typeof Number | typeof String | typeof Boolean | typeof BigInt | { coercer: InterceptorFunc } | Class<unknown>;\n\nexport type PartialBindableDefinition = Omit<IComponentBindablePropDefinition, 'name'> & {\n  // mode?: BindingMode;\n  callback?: string;\n  // attribute?: string;\n  name?: string;\n  // primary?: boolean;\n  set?: InterceptorFunc;\n  type?: PropertyType;\n\n  /**\n   * When set to `false` and automatic type-coercion is enabled, `null` and `undefined` will be coerced into target type.\n   *\n   * @default true\n   */\n  nullable?: boolean;\n};\n\n// Note: there is a invisible separator character the precedes the `@` in the jsdoc example. Otherwise the eslint rule will complain.\n// Refer:\n// - https://stackoverflow.com/a/55214510/2270340\n// - https://unicode-explorer.com/c/2063\n/**\n * Decorator: Specifies a bindable property on a class property.\n *\n * @example\n * ```ts\n * class Foo {\n *   @bindable bar: string;\n * }\n * ```\n */\nexport function bindable(_: undefined, context: ClassFieldDecoratorContext): void;\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function bindable(_: Function, context: ClassGetterDecoratorContext): void;\n/**\n * Decorator: Specifies custom behavior for a bindable property.\n * This can be either be a property decorator or a class decorator.\n *\n * @param config - The overrides\n */\nexport function bindable(config?: Omit<PartialBindableDefinition, 'name'>): (target: unknown, context: ClassDecoratorContext | ClassFieldDecoratorContext | ClassGetterDecoratorContext) => void;\n/**\n * Decorator: Specifies a bindable property on a class.\n *\n * @param prop - The property name\n */\nexport function bindable(prop: string): (target: Constructable, context: ClassDecoratorContext) => void;\nexport function bindable(\n  configOrPropOrTarget: PartialBindableDefinition | string | Constructable | undefined,\n  context?: ClassDecoratorContext | ClassFieldDecoratorContext | ClassGetterDecoratorContext\n):\n  | void\n  | ((target: Constructable, context: ClassDecoratorContext) => void)\n  | ((target: undefined, context: ClassFieldDecoratorContext) => void)\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  | ((target: Function, context: ClassGetterDecoratorContext) => void) {\n\n  let configOrProp: PartialBindableDefinition | string | undefined = void 0;\n  function decorator(_target: unknown, context: ClassDecoratorContext | ClassFieldDecoratorContext | ClassGetterDecoratorContext): void {\n    let $prop: string;\n\n    switch (context.kind) {\n      case 'getter':\n      case 'field': {\n        const prop = context.name;\n        // We are not supporting a bindable that uses a symbol for name.\n        // Maybe we can later have a binding command like foo.sym=\"bar\" that creates bindable instruction for `Symbol.for('sym')`, as target property.\n        if (typeof prop !== 'string') throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_symbol);\n        $prop = prop;\n        break;\n      }\n      case 'class':\n        if (configOrProp == null) throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_class_without_configuration);\n        if (typeof configOrProp == 'string') {\n          $prop = configOrProp;\n        } else {\n          const prop = configOrProp.name;\n          if (!prop) throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration);\n          if (typeof prop !== 'string') throw createMappedError(ErrorNames.invalid_bindable_decorator_usage_symbol);\n          $prop = prop;\n        }\n        break;\n    }\n\n    const config = configOrProp == null || typeof configOrProp === 'string'\n      ? { name: $prop }\n      : configOrProp;\n\n    const metadata = (context.metadata[baseName] ??= createLookup()) as Record<string, BindableDefinition>;\n    metadata[$prop] = BindableDefinition.create($prop, config);\n  }\n\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @bindable\n    configOrProp = {};\n    decorator(configOrPropOrTarget as Constructable | undefined, context!);\n    return;\n  } else if (isString(configOrPropOrTarget)) {\n    // ClassDecorator\n    // - @bindable('bar')\n    // Direct call:\n    // - @bindable('bar')(Foo)\n    configOrProp = configOrPropOrTarget;\n    return decorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @bindable()\n  // - @bindable({...opts})\n  configOrProp = configOrPropOrTarget === void 0 ? {} satisfies PartialBindableDefinition : configOrPropOrTarget as string | PartialBindableDefinition;\n  return decorator;\n}\n\nconst baseName = /*@__PURE__*/getAnnotationKeyFor('bindables');\n\nexport const Bindable = objectFreeze({\n  name: baseName,\n  keyFrom: (name: string): string => `${baseName}:${name}`,\n  from(...bindableLists: readonly (BindableDefinition | Record<string, Exclude<PartialBindableDefinition, 'name'> | true> | readonly (string | PartialBindableDefinition & { name: string })[] | undefined)[]): Record<string, BindableDefinition> {\n    const bindables: Record<string, BindableDefinition> = {};\n\n    const isArray = Array.isArray as <T>(arg: unknown) => arg is readonly T[];\n\n    function addName(name: string): void {\n      bindables[name] = BindableDefinition.create(name);\n    }\n\n    function addDescription(name: string, def: Exclude<PartialBindableDefinition, 'name'> | true): void {\n      bindables[name] = def instanceof BindableDefinition ? def : BindableDefinition.create(name, def === true ? { } : def);\n    }\n\n    function addList(maybeList: BindableDefinition | Record<string, Exclude<PartialBindableDefinition, 'name'> | true> | readonly (string | PartialBindableDefinition & { name: string })[] | undefined): void {\n      if (isArray(maybeList)) {\n        maybeList.forEach(nameOrDef => isString(nameOrDef) ? addName(nameOrDef) : addDescription(nameOrDef.name, nameOrDef));\n      } else if (maybeList instanceof BindableDefinition) {\n        bindables[maybeList.name] = maybeList;\n      } else if (maybeList !== void 0) {\n        objectKeys(maybeList).forEach(name => addDescription(name, maybeList[name]));\n      }\n    }\n\n    bindableLists.forEach(addList);\n\n    return bindables;\n  },\n  getAll(Type: Constructable): readonly BindableDefinition[] {\n    const defs: BindableDefinition[] = [];\n    const prototypeChain = getPrototypeChain(Type);\n\n    let iProto = prototypeChain.length;\n    let Class: Constructable;\n    while (--iProto >= 0) {\n      Class = prototypeChain[iProto];\n      const bindableMetadata = getMetadata<Record<PropertyKey, BindableDefinition>>(baseName, Class);\n      if (bindableMetadata == null) continue;\n      defs.push(...Object.values<BindableDefinition>(bindableMetadata));\n    }\n    return defs;\n  },\n  /** @internal */\n  _add(bindable: BindableDefinition, Type: Constructable) {\n    let bindables = getMetadata<Record<string, BindableDefinition>>(baseName, Type);\n    if (bindables == null) {\n      defineMetadata(bindables = createLookup(), Type, baseName);\n    }\n    bindables[bindable.name] = bindable;\n  }\n});\n\nexport class BindableDefinition {\n  private constructor(\n    public readonly attribute: string,\n    public readonly callback: string,\n    public readonly mode: BindingMode,\n    public readonly primary: boolean,\n    public readonly name: string,\n    public readonly set: InterceptorFunc,\n  ) { }\n\n  public static create(prop: string, def: PartialBindableDefinition = {}): BindableDefinition {\n    const mode = (def.mode ?? toView) as BindingMode;\n    return new BindableDefinition(\n      def.attribute ?? kebabCase(prop),\n      def.callback ?? `${prop}Changed`,\n      isString(mode) ? BindingMode[mode as keyof typeof BindingMode] ?? defaultMode : mode,\n      def.primary ?? false,\n      def.name ?? prop,\n      def.set ?? getInterceptor(def),\n    );\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars,spaced-comment */\n/**\n * This function serves two purposes:\n * - A playground for contributors to try their changes to the APIs.\n * - Cause the API surface to be properly type-checked and protected against accidental type regressions.\n *\n * It will be automatically removed by dead code elimination.\n */\nfunction apiTypeCheck() {\n\n  @bindable('prop')\n  // > expected error - class decorator only accepts a string\n  //@bindable({})\n  class Foo {\n    @bindable\n    @bindable()\n    @bindable({})\n    // > expected error - 'property' does not exist on decorator input object\n    //@bindable({ property: 'prop' })\n    @bindable({ mode: twoWay })\n    @bindable({ callback: 'propChanged' })\n    @bindable({ attribute: 'prop' })\n    @bindable({ primary: true })\n    @bindable({ set: value => String(value) })\n    @bindable({ set: value => Number(value) })\n    @bindable({\n      mode: twoWay,\n      callback: 'propChanged',\n      attribute: 'prop',\n      primary: true,\n      set: value => String(value)\n    })\n    public prop: unknown;\n  }\n}\n\ntype CoercerFunction<This extends Constructable> = (this: This, value: unknown) => InstanceType<This>;\nexport function coercer<\n  This extends Constructable,\n  TCoercer extends CoercerFunction<This>\n>(\n  target: TCoercer,\n  context: ClassMethodDecoratorContext<This, TCoercer>\n): void {\n  context.addInitializer(function (this: This) {\n    Coercer.define(this, context.name);\n  });\n}\n\nconst Coercer = {\n  key: /*@__PURE__*/getAnnotationKeyFor('coercer'),\n  define(target: Constructable<unknown>, property: string | symbol) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    defineMetadata(((target as any)[property] as InterceptorFunc).bind(target), target, Coercer.key);\n  },\n  for(target: Constructable<unknown>) {\n    return getMetadata<InterceptorFunc>(Coercer.key, target);\n  }\n};\n\nfunction getInterceptor(def: PartialBindableDefinition = {}) {\n  // TS5.x does not emit design:type metadata any longer for the new TC39 decorator proposal implementation.\n  // Hence, we needs to be solely reliant on the user-provided type in the bindable definition.\n  const type: PropertyType | null = def.type ?? null;\n  if (type == null) { return noop; }\n  let coercer: InterceptorFunc;\n  switch (type) {\n    case Number:\n    case Boolean:\n    case String:\n    case BigInt:\n      coercer = type as InterceptorFunc;\n      break;\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n      const $coercer: InterceptorFunc = (type as any).coerce as InterceptorFunc;\n      coercer = typeof $coercer === 'function'\n        ? $coercer.bind(type)\n        : (Coercer.for(type as Constructable) ?? noop);\n      break;\n    }\n  }\n  return coercer === noop\n    ? coercer\n    : createCoercer(coercer, def.nullable);\n}\n\nfunction createCoercer<TInput, TOutput>(coercer: InterceptorFunc<TInput, TOutput>, nullable: boolean | undefined): InterceptorFunc<TInput, TOutput> {\n  return function (value: TInput, coercionConfiguration?: ICoercionConfiguration): TOutput {\n    if (!coercionConfiguration?.enableCoercion) return value as unknown as TOutput;\n    return ((nullable ?? ((coercionConfiguration?.coerceNullish ?? false) ? false : true)) && value == null)\n      ? value as unknown as TOutput\n      : coercer(value, coercionConfiguration);\n  };\n}\n", "import {\n  DI,\n  Registration,\n  type IResolver,\n  type Key,\n  type Constructable,\n  type IContainer,\n  type IDisposableResolver,\n} from '@aurelia/kernel';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata } from './utilities-metadata';\nimport { IResourceKind } from './resources/resources-shared';\n\n/** @internal */\nexport const createInterface = DI.createInterface;\n\n/** @internal */\nexport const singletonRegistration = Registration.singleton;\n\n/** @internal */\nexport const aliasRegistration = Registration.aliasTo;\n\n/** @internal */\nexport const instanceRegistration = Registration.instance;\n\n/** @internal */\nexport const callbackRegistration = Registration.callback;\n\n/** @internal */\nexport const transientRegistration = Registration.transient;\n\n/** @internal */\nexport const registerResolver = <T extends IResolver | IDisposableResolver>(ctn: IContainer, key: Key, resolver: T): T =>\n  ctn.registerResolver(key, resolver);\n\nexport function alias(...aliases: readonly string[]) {\n  return function (target: Constructable, context: ClassDecoratorContext) {\n    context.addInitializer(function (this) {\n      const key = getAnnotationKeyFor('aliases');\n      const existing = getMetadata<string[] | undefined>(key, this);\n      if (existing === void 0) {\n        defineMetadata(aliases, this, key);\n      } else {\n        existing.push(...aliases);\n      }\n    });\n  };\n}\n\nexport function registerAliases(aliases: readonly string[], resource: IResourceKind, key: string, container: IContainer) {\n  for (let i = 0, ii = aliases.length; i < ii; ++i) {\n    aliasRegistration(key, resource.keyFrom(aliases[i])).register(container);\n  }\n}\n", "import { Constructable, PartialResourceDefinition, ResourceDefinition, StaticResourceType } from '@aurelia/kernel';\nimport { defineMetadata, getMetadata } from '../utilities-metadata';\n\n/** @internal */ export const dtElement = 'custom-element';\n/** @internal */ export const dtAttribute = 'custom-attribute';\n\nexport interface IResourceKind {\n  readonly name: string;\n  keyFrom(name: string): string;\n}\n\n/** @internal */ export const getDefinitionFromStaticAu = <Def extends ResourceDefinition, C extends Constructable = Constructable>(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Type: C | Function,\n  typeName: string,\n  createDef: (au: PartialResourceDefinition<Def>, Type: C) => Def,\n  metadataKey = '__au_static_resource__'\n): Def => {\n  let def = getMetadata(metadataKey, Type) as Def;\n  if (def == null) {\n    if ((Type as StaticResourceType<Def>).$au?.type === typeName) {\n      def = createDef((Type as StaticResourceType<Def>).$au!, Type as C);\n      defineMetadata(def, Type, metadataKey);\n    }\n  }\n  return def;\n};\n", "import { firstDefined, getResourceKeyFor, mergeArrays, resource, resourceBaseName, ResourceType, isFunction, isString } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { objectFreeze } from '../utilities';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\n\nimport type { Constructable, IContainer, IServiceLocator, PartialResourceDefinition, ResourceDefinition, StaticResourceType } from '@aurelia/kernel';\nimport { createMappedError, ErrorNames } from '../errors';\nimport { getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\nimport { IBinding } from '../binding/interfaces-bindings';\n\nexport type PartialBindingBehaviorDefinition = PartialResourceDefinition;\nexport type BindingBehaviorStaticAuDefinition = PartialBindingBehaviorDefinition & {\n  type: 'binding-behavior';\n};\n\nexport type BindingBehaviorType<T extends Constructable = Constructable> = ResourceType<T, BindingBehaviorInstance>;\n\nexport type BindingBehaviorInstance<T extends {} = {}> = {\n  type?: 'instance' | 'factory';\n  bind?(scope: Scope, binding: IBinding, ...args: unknown[]): void;\n  unbind?(scope: Scope, binding: IBinding, ...args: unknown[]): void;\n} & T;\n\nexport type BindingBehaviorKind = IResourceKind & {\n  isType<T>(value: T): value is (T extends Constructable ? BindingBehaviorType<T> : never);\n  define<T extends Constructable>(name: string, Type: T): BindingBehaviorType<T>;\n  define<T extends Constructable>(def: PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T>;\n  getDefinition<T extends Constructable>(Type: T): BindingBehaviorDefinition<T>;\n  find(container: IContainer, name: string): BindingBehaviorDefinition | null;\n  get(container: IServiceLocator, name: string): BindingBehaviorInstance;\n};\n\nexport type BindingBehaviorDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => BindingBehaviorType<T>;\n\nexport function bindingBehavior(definition: PartialBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(name: string): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDef: string | PartialBindingBehaviorDefinition): BindingBehaviorDecorator;\nexport function bindingBehavior(nameOrDef: string | PartialBindingBehaviorDefinition): BindingBehaviorDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext): BindingBehaviorType<T>  {\n    context.addInitializer(function (this) {\n      BindingBehavior.define(nameOrDef, this as Constructable);\n    });\n    return target as BindingBehaviorType<T>;\n  };\n}\n\nexport class BindingBehaviorDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, BindingBehaviorInstance> {\n  private constructor(\n    public readonly Type: BindingBehaviorType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialBindingBehaviorDefinition,\n    Type: BindingBehaviorType<T>,\n  ): BindingBehaviorDefinition<T> {\n\n    let name: string;\n    let def: PartialBindingBehaviorDefinition;\n    if (isString(nameOrDef)) {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    return new BindingBehaviorDefinition(\n      Type,\n      firstDefined(getBehaviorAnnotation(Type, 'name'), name),\n      mergeArrays(getBehaviorAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      BindingBehavior.keyFrom(name),\n    );\n  }\n\n  public register(container: IContainer, aliasName?: string | undefined): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getBindingBehaviorKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    if (!container.has(key, false)) {\n      container.register(\n        container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n        aliasRegistration($Type, key),\n        ...aliases.map(alias => aliasRegistration($Type, getBindingBehaviorKeyFrom(alias))),\n      );\n    } /* istanbul ignore next */ else if (__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV:aurelia] ${createMappedError(ErrorNames.binding_behavior_existed, this.name)}`);\n    }\n  }\n}\n\n/** @internal */ export const behaviorTypeName = 'binding-behavior';\nconst bbBaseName = /*@__PURE__*/getResourceKeyFor(behaviorTypeName);\nconst getBehaviorAnnotation = <K extends keyof PartialBindingBehaviorDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialBindingBehaviorDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\nconst getBindingBehaviorKeyFrom = (name: string): string => `${bbBaseName}:${name}`;\n\nexport const BindingBehavior = /*@__PURE__*/ objectFreeze<BindingBehaviorKind>({\n  name: bbBaseName,\n  keyFrom: getBindingBehaviorKeyFrom,\n  isType<T>(value: T): value is (T extends Constructable ? BindingBehaviorType<T> : never) {\n    return isFunction(value) && (hasMetadata(bbBaseName, value) || (value as StaticResourceType).$au?.type === behaviorTypeName);\n  },\n  define<T extends Constructable<BindingBehaviorInstance>>(nameOrDef: string | PartialBindingBehaviorDefinition, Type: T): BindingBehaviorType<T> {\n    const definition = BindingBehaviorDefinition.create(nameOrDef, Type as Constructable<BindingBehaviorInstance>);\n    const $Type = definition.Type as BindingBehaviorType<T>;\n\n    // registration of resource name is a requirement for the resource system in kernel (module-loader)\n    defineMetadata(definition, $Type, bbBaseName, resourceBaseName);\n\n    return $Type;\n  },\n  getDefinition<T extends Constructable>(Type: T): BindingBehaviorDefinition<T> {\n    const def: BindingBehaviorDefinition<T> = getMetadata<BindingBehaviorDefinition<T>>(bbBaseName, Type)\n      ?? getDefinitionFromStaticAu(Type as BindingBehaviorType<T>, behaviorTypeName, BindingBehaviorDefinition.create);\n    if (def === void 0) {\n      throw createMappedError(ErrorNames.binding_behavior_def_not_found, Type);\n    }\n\n    return def;\n  },\n  find(container, name) {\n    const Type = container.find<BindingBehaviorType>(behaviorTypeName, name);\n    return Type == null\n      ? null\n      : getMetadata<BindingBehaviorDefinition>(bbBaseName, Type) ?? getDefinitionFromStaticAu<BindingBehaviorDefinition>(Type, behaviorTypeName, BindingBehaviorDefinition.create) ?? null;\n  },\n  get(container, name) {\n    if (__DEV__) {\n      try {\n        return container.get<BindingBehaviorInstance>(resource(getBindingBehaviorKeyFrom(name)));\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.error('[DEV:aurelia] Cannot retrieve binding behavior with name', name);\n        throw ex;\n      }\n    }\n    return container.get<BindingBehaviorInstance>(resource(getBindingBehaviorKeyFrom(name)));\n  },\n});\n", "import { type Scope } from '@aurelia/runtime';\nimport { type IBinding, fromView, oneTime, toView, twoWay, type BindingMode } from '../../binding/interfaces-bindings';\nimport { BindingBehaviorInstance, behaviorTypeName, type BindingBehaviorStaticAuDefinition } from '../binding-behavior';\n\nconst originalModesMap = new Map<IBinding & { mode: BindingMode }, BindingMode>();\nconst createConfig = (name: string): BindingBehaviorStaticAuDefinition => ({ type: behaviorTypeName, name });\n\nexport abstract class BindingModeBehavior implements BindingBehaviorInstance {\n  public abstract readonly mode: BindingMode;\n\n  public bind(scope: Scope, binding: IBinding & { mode: BindingMode }): void {\n    originalModesMap.set(binding, binding.mode);\n    binding.mode = this.mode;\n  }\n\n  public unbind(scope: Scope, binding: IBinding & { mode: BindingMode }): void {\n    binding.mode = originalModesMap.get(binding)!;\n    originalModesMap.delete(binding);\n  }\n}\n\nexport class OneTimeBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('oneTime');\n  public get mode(): typeof BindingMode.oneTime { return oneTime; }\n}\n\nexport class ToViewBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('toView');\n  public get mode(): typeof BindingMode.toView { return toView; }\n}\n\nexport class FromViewBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('fromView');\n  public get mode(): typeof BindingMode.fromView { return fromView; }\n}\n\nexport class TwoWayBindingBehavior extends BindingModeBehavior {\n  public static readonly $au = /*@__PURE__*/createConfig('twoWay');\n  public get mode(): typeof BindingMode.twoWay { return twoWay; }\n}\n", "import { isString, type IDisposable, IPlatform, emptyArray, resolve } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { type BindingBehaviorInstance, BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\n\nimport { type IBinding, type IRateLimitOptions } from '../../binding/interfaces-bindings';\n\nconst bindingHandlerMap: WeakMap<IBinding, IDisposable> = new WeakMap();\nconst defaultDelay = 200;\n\nexport class DebounceBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'debounce',\n  };\n  /** @internal */\n  private readonly _platform = resolve(IPlatform);\n\n  public bind(scope: Scope, binding: IBinding, delay?: number, signals?: string | string[]) {\n    const opts: IRateLimitOptions = {\n      type: 'debounce',\n      delay: delay ?? defaultDelay,\n      now: this._platform.performanceNow,\n      queue: this._platform.taskQueue,\n      signals: isString(signals) ? [signals] : (signals ?? emptyArray),\n    };\n    const handler = binding.limit?.(opts);\n    if (handler == null) {\n      /* istanbul ignore next */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);\n      }\n    } else {\n      bindingHandlerMap.set(binding, handler);\n    }\n  }\n\n  public unbind(scope: Scope, binding: IBinding) {\n    bindingHandlerMap.get(binding)?.dispose();\n    bindingHandlerMap.delete(binding);\n  }\n}\n", "import { createLookup } from '@aurelia/kernel';\nimport type { ISubscriber } from '@aurelia/runtime';\nimport { createInterface } from './utilities-di';\n\nexport interface ISignaler extends Signaler {}\nexport const ISignaler = /*@__PURE__*/ createInterface<ISignaler>('ISignaler', x => x.singleton(Signaler));\n\nexport class Signaler {\n  public signals: Record<string, Set<ISubscriber> | undefined> = createLookup();\n\n  public dispatchSignal(name: string): void {\n    const listeners = this.signals[name];\n    if (listeners === undefined) {\n      return;\n    }\n    let listener: ISubscriber;\n    for (listener of listeners.keys()) {\n      listener.handleChange(undefined, undefined);\n    }\n  }\n\n  public addSignalListener(name: string, listener: ISubscriber): void {\n    (this.signals[name] ??= new Set()).add(listener);\n  }\n\n  public removeSignalListener(name: string, listener: ISubscriber): void {\n    this.signals[name]?.delete(listener);\n  }\n}\n", "import { resolve } from '@aurelia/kernel';\nimport { type Scope, type ISubscriber } from '@aurelia/runtime';\nimport { ISignaler } from '../../signaler';\nimport { type BindingBehaviorInstance, type BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\nimport { addSignalListener, removeSignalListener } from '../../utilities';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { IBinding } from '../../binding/interfaces-bindings';\n\ntype ISignalableBinding = IBinding & ISubscriber;\n\nexport class SignalBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'signal',\n  };\n  /** @internal */\n  private readonly _lookup: Map<IBinding, string[]> = new Map();\n  /** @internal */\n  private readonly _signaler = resolve(ISignaler);\n\n  public bind(scope: Scope, binding: IBinding, ...names: string[]): void {\n    if (!('handleChange' in binding)) {\n      throw createMappedError(ErrorNames.signal_behavior_invalid_usage);\n    }\n    if (names.length === 0) {\n      throw createMappedError(ErrorNames.signal_behavior_no_signals);\n    }\n\n    this._lookup.set(binding, names);\n    let name: string;\n    for (name of names) {\n      addSignalListener(this._signaler, name, binding as ISignalableBinding);\n    }\n  }\n\n  public unbind(scope: Scope, binding: IBinding): void {\n    const names = this._lookup.get(binding)!;\n    this._lookup.delete(binding);\n    let name: string;\n    for (name of names) {\n      removeSignalListener(this._signaler, name, binding as ISignalableBinding);\n    }\n  }\n}\n", "import { TaskQueue } from '@aurelia/platform';\nimport { isString, IPlatform, type IDisposable, emptyArray, resolve } from '@aurelia/kernel';\nimport { type Scope } from '@aurelia/runtime';\nimport { type BindingBehaviorInstance, BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\nimport { type IBinding, type IRateLimitOptions } from '../../binding/interfaces-bindings';\n\nconst bindingHandlerMap: WeakMap<IBinding, IDisposable> = new WeakMap();\nconst defaultDelay = 200;\n\nexport class ThrottleBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'throttle',\n  };\n  /** @internal */\n  private readonly _now: () => number;\n  /** @internal */\n  private readonly _taskQueue: TaskQueue;\n\n  public constructor() {\n    ({ performanceNow: this._now, taskQueue: this._taskQueue } = resolve(IPlatform));\n  }\n\n  public bind(scope: Scope, binding: IBinding, delay?: number, signals?: string | string[]) {\n    const opts: IRateLimitOptions = {\n      type: 'throttle',\n      delay: delay ?? defaultDelay,\n      now: this._now,\n      queue: this._taskQueue,\n      signals: isString(signals) ? [signals] : (signals ?? emptyArray),\n    };\n    const handler = binding.limit?.(opts);\n    if (handler == null) {\n      /* istanbul ignore next */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);\n      }\n    } else {\n      bindingHandlerMap.set(binding, handler);\n    }\n  }\n\n  public unbind(scope: Scope, binding: IBinding) {\n    bindingHandlerMap.get(binding)?.dispose();\n    bindingHandlerMap.delete(binding);\n  }\n}\n", "import {  objectFreeze } from './utilities';\nimport { createInterface, instanceRegistration } from './utilities-di';\nimport { isFunction, type IContainer, type IRegistry, type Key, type Resolved } from '@aurelia/kernel';\n\nexport type TaskSlot =\n  | 'creating'\n  | 'hydrating'\n  | 'hydrated'\n  | 'activating'\n  | 'activated'\n  | 'deactivating'\n  | 'deactivated';\n\nexport const IAppTask = /*@__PURE__*/createInterface<IAppTask>('IAppTask');\nexport interface IAppTask {\n  readonly slot: TaskSlot;\n  register(c: IContainer): IContainer;\n  run(): void | Promise<void>;\n}\n\nclass $AppTask<K extends Key = Key> implements IAppTask {\n  public readonly slot: TaskSlot;\n  /** @internal */\n  private c: IContainer = (void 0)!;\n  /** @internal */\n  private readonly k: K | null;\n  /** @internal */\n  private readonly cb: AppTaskCallback<K> | AppTaskCallbackNoArg;\n\n  public constructor(\n    slot: TaskSlot,\n    key: K | null,\n    cb: AppTaskCallback<K> | AppTaskCallbackNoArg,\n  ) {\n    this.slot = slot;\n    this.k = key;\n    this.cb = cb;\n  }\n\n  public register(container: IContainer): IContainer {\n    return this.c = container.register(instanceRegistration(IAppTask, this));\n  }\n\n  public run(): void | Promise<void> {\n    const key = this.k;\n    const cb = this.cb;\n    return (key === null\n      ? (cb as AppTaskCallbackNoArg)()\n      : cb(this.c.get(key))) as Promise<void>;\n  }\n}\n\nexport const AppTask = objectFreeze({\n  /**\n   * Returns a task that will run just before the root component is created by DI\n   */\n  creating: createAppTaskSlotHook('creating'),\n  /**\n   * Returns a task that will run after instantiating the root controller,\n   * but before compiling its view (thus means before instantiating the child elements inside it)\n   *\n   * good chance for a router to do some initial work, or initial routing related in general\n   */\n  hydrating: createAppTaskSlotHook('hydrating'),\n  /**\n   * Return a task that will run after the hydration of the root controller,\n   * but before hydrating the child element inside\n   *\n   * good chance for a router to do some initial work, or initial routing related in general\n   */\n  hydrated: createAppTaskSlotHook('hydrated'),\n  /**\n   * Return a task that will run right before the root component is activated.\n   * In this phase, scope hierarchy is formed, and bindings are getting bound\n   */\n  activating: createAppTaskSlotHook('activating'),\n  /**\n   * Return a task that will run right after the root component is activated - the app is now running\n   */\n  activated: createAppTaskSlotHook('activated'),\n  /**\n   * Return a task that will runs right before the root component is deactivated.\n   * In this phase, scope hierarchy is unlinked, and bindings are getting unbound\n   */\n  deactivating: createAppTaskSlotHook('deactivating'),\n  /**\n   * Return a task that will run right after the root component is deactivated\n   */\n  deactivated: createAppTaskSlotHook('deactivated'),\n});\n\n// unknown as the return of an app task will be ignored\n// only cares whether it's a promise or not\n// the benefit of unknown is that application can avoid having to write () => { doThingsThatDoesNotReturnVoid() }\nexport type AppTaskCallbackNoArg = () => unknown;\nexport type AppTaskCallback<T> = (arg: Resolved<T>) => unknown;\n\nfunction createAppTaskSlotHook(slotName: TaskSlot) {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function appTaskFactory<T extends Key = Key>(callback: AppTaskCallbackNoArg): IRegistry;\n  function appTaskFactory<T extends Key = Key>(key: T, callback: AppTaskCallback<T>): IRegistry;\n  function appTaskFactory<T extends Key = Key>(keyOrCallback: T | AppTaskCallback<T> | AppTaskCallbackNoArg, callback?: AppTaskCallback<T>): IRegistry {\n    if (isFunction(callback)) {\n      return new $AppTask(slotName, keyOrCallback as T, callback);\n    }\n    return new $AppTask(slotName, null, keyOrCallback as Exclude<typeof keyOrCallback, T>);\n  }\n  return appTaskFactory;\n}\n", "import { BrowserPlatform } from '@aurelia/platform-browser';\nimport { InterfaceSymbol, IPlatform as $IPlatform } from '@aurelia/kernel';\n\nexport interface IPlatform extends BrowserPlatform {}\nexport const IPlatform = $IPlatform as InterfaceSymbol<IPlatform>;\n", "import type { Writable } from '@aurelia/kernel';\nimport type { IHydratedController } from './templating/controller';\nimport { createInterface } from './utilities-di';\n\nclass Refs {\n  [key: string]: IHydratedController | undefined;\n}\n\nexport type INodeControllerRefs = {\n  hideProp: boolean;\n  get(node: INode, name: string): IHydratedController | null;\n  set<T extends IHydratedController>(node: INode, name: string, controller: T): T;\n};\nexport const refs: INodeControllerRefs = /*@__PURE__*/ (() => {\n  const refsMap = new WeakMap<Node, Refs>();\n  let hideProp = false;\n\n  return new class {\n    public get hideProp() {\n      return hideProp;\n    }\n    public set hideProp(value: boolean) {\n      hideProp = value;\n    }\n    public get(node: INode, name: string): IHydratedController | null {\n      return refsMap.get(node)?.[name] ?? null;\n    }\n    public set<T extends IHydratedController>(node: INode, name: string, controller: T): T {\n      const ref = refsMap.get(node) ?? (refsMap.set(node, new Refs()), refsMap.get(node)!);\n      if (name in ref) {\n        throw new Error(`Node already associated with a controller, remove the ref \"${name}\" first before associating with another controller`);\n      }\n      if (!hideProp) {\n        (node as Writable<INode>).$au ??= ref;\n      }\n      return (ref[name] = controller) as T;\n    }\n  }();\n})();\n\nexport type INode<T extends Node = Node> = T & {\n  readonly $au?: Refs;\n};\nexport const INode = /*@__PURE__*/ createInterface<INode>('INode');\n", "import { emptyArray, isFunction } from '@aurelia/kernel';\nimport { getAttributeDefinition, isAttributeType } from './resources/custom-attribute';\nimport { getElementDefinition, isElementType } from './resources/custom-element';\nimport { objectFreeze, safeString } from './utilities';\n\nimport type { Constructable } from '@aurelia/kernel';\nimport type { IConnectable } from '@aurelia/runtime';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport type IDepCollectionFn<TType extends object, TReturn = unknown> = (vm: TType, watcher: IConnectable) => TReturn;\nexport type IWatcherCallback<TType extends object, TValue = unknown>\n  = (this: TType, newValue: TValue, oldValue: TValue, vm: TType) => unknown;\n\nexport interface IWatchDefinition<T extends object = object> {\n  expression: PropertyKey | IDepCollectionFn<T>;\n  callback: keyof T | IWatcherCallback<T>;\n  flush: 'async' | 'sync';\n}\n\nexport type IWatchOptions = {\n  flush?: 'async' | 'sync';\n};\n\ntype AnyMethod<R = unknown> = (...args: unknown[]) => R;\ntype WatchClassDecorator<T extends object> = (target: Constructable<T>, context: ClassDecoratorContext<Constructable<T>>) => void;\ntype WatchMethodDecorator<T, TV extends AnyMethod> = (target: TV, context: ClassMethodDecoratorContext<T, TV>) => void;\ntype MethodsOf<Type> = {\n  [Key in keyof Type]: Type[Key] extends AnyMethod ? Key : never\n}[keyof Type];\n\n// for\n//    @watch('some.expression', (v) => ...)\n//    @watch('some.expression', 'method')\n//    @watch(Symbol, (v) => ...)\n//    @watch(Symbol, 'method')\n//    @watch(a => ..., 'method')\n//    @watch(a => ..., v => ...)\n//    class A {\n//      method() {...}\n//    }\nexport function watch<T extends object, D = unknown>(\n  expressionOrPropertyAccessFn: PropertyKey,\n  changeHandlerOrCallback: MethodsOf<T> | IWatcherCallback<T, D>,\n  options?: IWatchOptions,\n): WatchClassDecorator<T>;\n\nexport function watch<T extends object, D = unknown>(\n  expressionOrPropertyAccessFn: IDepCollectionFn<T, D>,\n  changeHandlerOrCallback: MethodsOf<T> | IWatcherCallback<T, D>,\n  options?: IWatchOptions,\n): WatchClassDecorator<T>;\n\n// for\n// class A {\n//    @watch('some.expression')\n//    @watch(Symbol)\n//    @watch(a => ...)\n//    method() {...}\n// }\nexport function watch<T extends object = object, D = unknown, TV extends AnyMethod = AnyMethod>(\n  expressionOrPropertyAccessFn: PropertyKey | IDepCollectionFn<T, D>,\n  options?: IWatchOptions,\n): WatchMethodDecorator<T, TV>;\n\nexport function watch<T extends object = object, TV extends AnyMethod = AnyMethod>(\n  expressionOrPropertyAccessFn: PropertyKey | IDepCollectionFn<object>,\n  changeHandlerOrCallbackOrOptions?: PropertyKey | IWatcherCallback<T> | IWatchOptions,\n  optionsOrUndefined?: IWatchOptions,\n): WatchClassDecorator<T> | WatchMethodDecorator<T, TV> {\n  if (expressionOrPropertyAccessFn == null) {\n    throw createMappedError(ErrorNames.watch_null_config);\n  }\n\n  return function decorator(\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    target: Function | IWatcherCallback<T>,\n    context: ClassDecoratorContext<Constructable<T>> | ClassMethodDecoratorContext<T>\n  ): void {\n    const isClassDecorator = context.kind === 'class';\n    let options: IWatchOptions | undefined;\n    let changeHandler: IWatcherCallback<T>;\n\n    // basic validation\n    if (isClassDecorator) {\n      if (!isFunction(changeHandlerOrCallbackOrOptions)\n        && (changeHandlerOrCallbackOrOptions == null\n          || !(changeHandlerOrCallbackOrOptions as PropertyKey in target.prototype)\n        )\n      ) {\n        throw createMappedError(\n          ErrorNames.watch_invalid_change_handler,\n          `${safeString(changeHandlerOrCallbackOrOptions)}@${target.name}}`\n        );\n      }\n      changeHandler = changeHandlerOrCallbackOrOptions as IWatcherCallback<T>;\n      options = optionsOrUndefined ?? {};\n    } else {\n      if (!isFunction(target) || context.static) {\n        throw createMappedError(ErrorNames.watch_non_method_decorator_usage, context.name);\n      }\n      changeHandler = target as IWatcherCallback<T>;\n      options = changeHandlerOrCallbackOrOptions as IWatchOptions ?? {};\n    }\n\n    const watchDef = new WatchDefinition<T>(\n      expressionOrPropertyAccessFn,\n      changeHandler,\n      options.flush,\n    );\n\n    if (isClassDecorator) {\n      addDefinition(target as Constructable);\n    } else {\n      // instance method decorator initializer is called for each instance\n      let added = false;\n      context.addInitializer(function (this: T) {\n        if (!added) {\n          added = true;\n          addDefinition(this.constructor as Constructable);\n        }\n      });\n    }\n\n    function addDefinition(type: Constructable) {\n      Watch.add(type, watchDef as IWatchDefinition);\n\n      // if the code looks like this:\n      // @watch(...)\n      // @customAttribute(...)\n      // class Abc {}\n      //\n      // then @watch is called after @customAttribute\n      // which means the attribute definition won't have the watch definition\n      //\n      // temporarily works around this order sensitivity by manually add the watch def\n      // manual\n      if (isAttributeType(type)) {\n        getAttributeDefinition(type).watches.push(watchDef as IWatchDefinition);\n      }\n      if (isElementType(type)) {\n        getElementDefinition(type).watches.push(watchDef as IWatchDefinition);\n      }\n    }\n  };\n}\n\nclass WatchDefinition<T extends object> implements IWatchDefinition<T> {\n  public constructor(\n    public expression: PropertyKey | IDepCollectionFn<T>,\n    public callback: IWatcherCallback<T>,\n    public flush: 'async' | 'sync' = 'async',\n  ) {}\n}\n\nexport const Watch = /*@__PURE__*/(() => {\n  const watches = new WeakMap<Constructable, IWatchDefinition[]>();\n  return objectFreeze({\n    add(Type: Constructable, definition: IWatchDefinition): void {\n      let defs = watches.get(Type);\n      if (defs == null) {\n        watches.set(Type, defs = []);\n      }\n      defs.push(definition);\n    },\n    getDefinitions(Type: Constructable): IWatchDefinition[] {\n      return watches.get(Type) ?? emptyArray;\n    }\n  });\n})();\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-unsafe-member-access */\nfunction testWatchDeco() {\n  @watch('some.property', (_, __, vm) => vm.prop, { flush: 'sync' })\n  @watch('some.property', (_, __, vm) => vm.prop, { flush: 'async' })\n  // @ts-expect-error - typo\n  @watch('some.property', (_, __, vm) => vm.prop, { flush: 'asyn' })\n  @watch('some.property', (_, __, vm) => vm.prop)\n  @watch(vm => vm.prop, (_, __, vm) => vm.prop)\n  @watch(vm => vm.prop, (_, __, vm) => vm.prop, { flush: 'sync' })\n  @watch(vm => vm.prop, (_, __, vm) => vm.prop, { flush: 'async' })\n  // @ts-expect-error - typo\n  @watch(vm => vm.prop, (_, __, vm) => vm.prop, { flush: 'asyn' })\n  class MyClass {\n    public prop = 1;\n\n    @watch('some.property')\n    @watch('some.property', { flush: 'sync' })\n    @watch('some.property', { flush: 'async' })\n    // @ts-expect-error - typo\n    @watch('some.property', { flush: 'asyn' })\n    public myMethod() {/*  */}\n\n    @watch((vm) => vm.prop)\n    public myMethod2() {/*  */}\n\n    @watch((vm) => vm.prop, {  })\n    @watch((vm) => vm.prop, { flush: 'sync' })\n    @watch((vm) => vm.prop, { flush: 'async' })\n    // @ts-expect-error - type\n    @watch((vm) => vm.prop, { flush: 'asyn' })\n    public myMethod3() {/*  */}\n  }\n}\n", "import { mergeArrays, firstDefined, Key, resourceBaseName, getResourceKeyFor, isFunction, isString, ILogger } from '@aurelia/kernel';\nimport { Bindable } from '../bindable';\nimport { Watch } from '../watch';\nimport { getEffectiveParentNode } from '../dom';\nimport { INode, refs } from '../dom.node';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\nimport { objectFreeze } from '../utilities';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\nimport { defaultMode, toView, BindingMode } from '../binding/interfaces-bindings';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceDefinition,\n  PartialResourceDefinition,\n  ResourceType,\n  StaticResourceType,\n} from '@aurelia/kernel';\nimport type { BindableDefinition, PartialBindableDefinition } from '../bindable';\nimport type { ICustomAttributeViewModel, ICustomAttributeController, Controller } from '../templating/controller';\nimport type { IWatchDefinition } from '../watch';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { dtAttribute, getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\nimport { IAttributeComponentDefinition } from '@aurelia/template-compiler';\n\nexport type PartialCustomAttributeDefinition<TBindables extends string = string> = PartialResourceDefinition<Omit<IAttributeComponentDefinition, 'type'> & {\n  readonly defaultBindingMode?: string | number;\n  readonly isTemplateController?: boolean;\n  readonly bindables?: (Record<TBindables, true | Omit<PartialBindableDefinition, 'name'>>) | (TBindables | PartialBindableDefinition & { name: TBindables })[];\n  /**\n   * A config that can be used by template compliler to change attr value parsing mode\n   * `true` to always parse as a single value, mostly will be string in URL scenario\n   * Example:\n   * ```html\n   * <div goto=\"http://bla.bla.com\">\n   * ```\n   * With `noMultiBinding: true`, user does not need to escape the `:` with `\\`\n   * or use binding command to escape it.\n   *\n   * With `noMultiBinding: false (default)`, the above will be parsed as it's binding\n   * to a property name `http`, with value equal to literal string `//bla.bla.com`\n   */\n  readonly noMultiBindings?: boolean;\n  readonly watches?: IWatchDefinition[];\n  readonly dependencies?: readonly Key[];\n  /**\n   * **Only used by template controller custom attributes.**\n   *\n   * Container strategy for the view factory of this template controller.\n   *\n   * By default, the view factory will be reusing the container of the parent view (controller),\n   * as this container has information about the resources registered.\n   *\n   * Specify `'new'` to create a new container for the view factory.\n   */\n  readonly containerStrategy?: 'reuse' | 'new';\n}>;\n\nexport type CustomAttributeStaticAuDefinition<TBindables extends string = string> = PartialCustomAttributeDefinition<TBindables> & {\n  type: 'custom-attribute';\n};\n\nexport type CustomAttributeType<T extends Constructable = Constructable> = ResourceType<T, ICustomAttributeViewModel, PartialCustomAttributeDefinition>;\nexport type CustomAttributeKind = IResourceKind & {\n  for<C extends ICustomAttributeViewModel = ICustomAttributeViewModel>(node: Node, name: string): ICustomAttributeController<C> | undefined;\n  closest<A extends object | Constructable, TType extends A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A> = A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A>>(node: Node, Type: CustomAttributeType<TType>): ICustomAttributeController<InstanceType<TType>> | null;\n  closest<A extends object | Constructable, TType extends A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A> = A extends Constructable<infer T extends object> ? Constructable<T> : Constructable<A>>(node: Node, name: string): ICustomAttributeController<InstanceType<TType>> | null;\n  isType<T>(value: T): value is (T extends Constructable ? CustomAttributeType<T> : never);\n  define<T extends Constructable>(name: string, Type: T): CustomAttributeType<T>;\n  define<T extends Constructable>(def: PartialCustomAttributeDefinition, Type: T): CustomAttributeType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialCustomAttributeDefinition, Type: T): CustomAttributeType<T>;\n  getDefinition<T extends Constructable>(Type: T, context?: DecoratorContext | null): CustomAttributeDefinition<T>;\n  // eslint-disable-next-line\n  getDefinition<T extends Constructable>(Type: Function, context?: DecoratorContext | null): CustomAttributeDefinition<T>;\n  annotate<K extends keyof PartialCustomAttributeDefinition>(Type: Constructable, prop: K, value: PartialCustomAttributeDefinition[K]): void;\n  getAnnotation<K extends keyof PartialCustomAttributeDefinition>(Type: Constructable, prop: K, context: DecoratorContext | undefined | null): PartialCustomAttributeDefinition[K] | undefined;\n  find(c: IContainer, name: string): CustomAttributeDefinition | null;\n};\n\nexport type CustomAttributeDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => CustomAttributeType<T>;\n\n/**\n * Decorator: Indicates that the decorated class is a custom attribute.\n */\nexport function customAttribute(definition: PartialCustomAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(name: string): CustomAttributeDecorator;\nexport function customAttribute(nameOrDef: string | PartialCustomAttributeDefinition): CustomAttributeDecorator;\nexport function customAttribute(nameOrDef: string | PartialCustomAttributeDefinition): CustomAttributeDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext): CustomAttributeType<T> {\n    context.addInitializer(function (this) {\n      defineAttribute(nameOrDef, this as Constructable);\n    });\n    return target as CustomAttributeType<T>;\n  };\n}\n\n/**\n * Decorator: Applied to custom attributes. Indicates that whatever element the\n * attribute is placed on should be converted into a template and that this\n * attribute controls the instantiation of the template.\n */\nexport function templateController(definition: Omit<PartialCustomAttributeDefinition, 'isTemplateController' | 'type'>): CustomAttributeDecorator;\nexport function templateController(name: string): CustomAttributeDecorator;\nexport function templateController(nameOrDef: string | Omit<PartialCustomAttributeDefinition, 'isTemplateController' | 'type'>): CustomAttributeDecorator;\nexport function templateController(nameOrDef: string | Omit<PartialCustomAttributeDefinition, 'isTemplateController' | 'type'>): CustomAttributeDecorator {\n  return function (target, context) {\n    context.addInitializer(function (this) {\n      defineAttribute(\n        isString(nameOrDef)\n          ? { isTemplateController: true, name: nameOrDef }\n          : { isTemplateController: true, ...nameOrDef },\n        this as Constructable,\n      );\n    });\n    return target;\n  } as CustomAttributeDecorator;\n}\n\nexport class CustomAttributeDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, ICustomAttributeViewModel, PartialCustomAttributeDefinition> {\n  public static warnDuplicate = true;\n  // a simple marker to distinguish between Custom Element definition & Custom attribute definition\n  public get type(): 'custom-attribute' { return dtAttribute; }\n\n  private constructor(\n    public readonly Type: CustomAttributeType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n    public readonly defaultBindingMode: BindingMode,\n    public readonly isTemplateController: boolean,\n    public readonly bindables: Record<string, BindableDefinition>,\n    public readonly noMultiBindings: boolean,\n    public readonly watches: IWatchDefinition[],\n    public readonly dependencies: Key[],\n    public readonly containerStrategy: 'reuse' | 'new',\n  ) {}\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialCustomAttributeDefinition,\n    Type: CustomAttributeType<T>,\n  ): CustomAttributeDefinition<T> {\n    let name: string;\n    let def: PartialCustomAttributeDefinition;\n    if (isString(nameOrDef)) {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n\n    const mode = firstDefined(getAttributeAnnotation(Type, 'defaultBindingMode'), def.defaultBindingMode, Type.defaultBindingMode, toView) as string | BindingMode;\n\n    for(const bindable of Object.values(Bindable.from(def.bindables))) {\n      Bindable._add(bindable, Type);\n    }\n    return new CustomAttributeDefinition(\n      Type,\n      firstDefined(getAttributeAnnotation(Type, 'name'), name),\n      mergeArrays(getAttributeAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      getAttributeKeyFrom(name),\n      isString(mode) ? BindingMode[mode as keyof typeof BindingMode] ?? defaultMode : mode,\n      firstDefined(getAttributeAnnotation(Type, 'isTemplateController'), def.isTemplateController, Type.isTemplateController, false),\n      Bindable.from(...Bindable.getAll(Type), getAttributeAnnotation(Type, 'bindables'), Type.bindables, def.bindables),\n      firstDefined(getAttributeAnnotation(Type, 'noMultiBindings'), def.noMultiBindings, Type.noMultiBindings, false),\n      mergeArrays(Watch.getDefinitions(Type), Type.watches),\n      mergeArrays(getAttributeAnnotation(Type, 'dependencies'), def.dependencies, Type.dependencies),\n      firstDefined(getAttributeAnnotation(Type, 'containerStrategy'), def.containerStrategy, Type.containerStrategy, 'reuse'),\n    );\n  }\n\n  public register(container: IContainer, aliasName?: string | undefined): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getAttributeKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    if (!container.has(key, false)) {\n      container.register(\n        container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n        aliasRegistration($Type, key),\n        ...aliases.map(alias => aliasRegistration($Type, getAttributeKeyFrom(alias)))\n      );\n    } /* istanbul ignore next */ else {\n      if (CustomAttributeDefinition.warnDuplicate) {\n        container.get(ILogger).warn(createMappedError(ErrorNames.attribute_existed, this.name));\n      }\n      /* istanbul ignore if */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`[DEV:aurelia] ${createMappedError(ErrorNames.attribute_existed, this.name)}`);\n      }\n    }\n  }\n\n  public toString() {\n    return `au:ca:${this.name}`;\n  }\n}\n\n/** @internal */ export const attrTypeName = 'custom-attribute';\nconst attributeBaseName = /*@__PURE__*/getResourceKeyFor(attrTypeName);\nconst getAttributeKeyFrom = (name: string): string => `${attributeBaseName}:${name}`;\n\nconst getAttributeAnnotation = <K extends keyof PartialCustomAttributeDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialCustomAttributeDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\n/** @internal */\nexport const isAttributeType = <T>(value: T): value is (T extends Constructable ? CustomAttributeType<T> : never) => {\n  return isFunction(value) && (\n    hasMetadata(attributeBaseName, value)\n    || (value as StaticResourceType).$au?.type === attrTypeName\n  );\n};\n\n/** @internal */\nexport const findAttributeControllerFor = <C extends ICustomAttributeViewModel = ICustomAttributeViewModel>(node: Node, name: string): ICustomAttributeController<C> | undefined => {\n  return (refs.get(node, getAttributeKeyFrom(name)) ?? void 0) as ICustomAttributeController<C> | undefined;\n};\n\n/** @internal */\nexport const defineAttribute = <T extends Constructable>(nameOrDef: string | PartialCustomAttributeDefinition, Type: T): CustomAttributeType<T> => {\n  const definition = CustomAttributeDefinition.create(nameOrDef, Type as Constructable);\n  const $Type = definition.Type as CustomAttributeType<T>;\n\n  defineMetadata(definition, $Type, attributeBaseName, resourceBaseName);\n\n  return $Type;\n};\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const getAttributeDefinition = <T extends Constructable>(Type: T | Function): CustomAttributeDefinition<T> => {\n  const def: CustomAttributeDefinition<T> = getMetadata<CustomAttributeDefinition<T>>(attributeBaseName, Type)\n    ?? getDefinitionFromStaticAu(Type as CustomAttributeType<T>, attrTypeName, CustomAttributeDefinition.create);\n  if (def === void 0) {\n    throw createMappedError(ErrorNames.attribute_def_not_found, Type);\n  }\n\n  return def;\n};\n\nconst findClosestControllerByName = (node: Node, attrNameOrType: string | CustomAttributeType): ICustomAttributeController | null => {\n  let key = '';\n  let attrName = '';\n  if (isString(attrNameOrType)) {\n    key = getAttributeKeyFrom(attrNameOrType);\n    attrName = attrNameOrType;\n  } else {\n    const definition = getAttributeDefinition(attrNameOrType);\n    key = definition.key;\n    attrName = definition.name;\n  }\n  let cur = node as INode | null;\n  while (cur !== null) {\n    const controller = refs.get(cur, key) as Controller | null;\n    if (controller?.is(attrName)) {\n      return controller as ICustomAttributeController;\n    }\n\n    cur = getEffectiveParentNode(cur);\n  }\n\n  return null;\n};\n\nexport const CustomAttribute = /*@__PURE__*/ objectFreeze<CustomAttributeKind>({\n  name: attributeBaseName,\n  keyFrom: getAttributeKeyFrom,\n  isType: isAttributeType,\n  for: findAttributeControllerFor,\n  closest: findClosestControllerByName,\n  define: defineAttribute,\n  getDefinition: getAttributeDefinition,\n  annotate<K extends keyof PartialCustomAttributeDefinition>(Type: Constructable, prop: K, value: PartialCustomAttributeDefinition[K]): void {\n    defineMetadata(value, Type, getAnnotationKeyFor(prop));\n  },\n  getAnnotation: getAttributeAnnotation,\n  find(c, name) {\n    const Type = c.find<CustomAttributeType>(attrTypeName, name);\n    return Type === null\n      ? null\n      : getMetadata<CustomAttributeDefinition>(attributeBaseName, Type)\n      ?? getDefinitionFromStaticAu<CustomAttributeDefinition>(Type, attrTypeName, CustomAttributeDefinition.create)\n      ?? null;\n  },\n});\n", "import { createInterface, singletonRegistration } from '../utilities-di';\nimport { getOwnPropertyNames, objectFreeze, baseObjectPrototype } from '../utilities';\n\nimport { type Constructable, type IContainer, type AnyFunction, type FunctionPropNames, IRegistry, registrableMetadataKey } from '@aurelia/kernel';\n\nexport type LifecycleHook<TViewModel, TKey extends keyof TViewModel> =\n  TViewModel[TKey] extends (AnyFunction | undefined)\n    ? (vm: TViewModel, ...args: Parameters<NonNullable<TViewModel[TKey]>>) => ReturnType<NonNullable<TViewModel[TKey]>>\n    : never;\n\nexport type ILifecycleHooks<TViewModel = {}, TKey extends keyof TViewModel = keyof TViewModel> = { [K in TKey]-?: LifecycleHook<TViewModel, K>; };\nexport const ILifecycleHooks = /*@__PURE__*/createInterface<ILifecycleHooks<object>>('ILifecycleHooks');\n\nexport type LifecycleHooksLookup<TViewModel = {}> = {\n  [K in FunctionPropNames<TViewModel>]?: readonly LifecycleHooksEntry<TViewModel, K>[];\n};\nexport class LifecycleHooksEntry<TViewModel = {}, TKey extends keyof TViewModel = keyof TViewModel, THooks extends Constructable = Constructable> {\n  public constructor(\n    public readonly definition: LifecycleHooksDefinition<THooks>,\n    public readonly instance: ILifecycleHooks<TViewModel, TKey>,\n  ) {}\n}\n\n/**\n * This definition has no specific properties yet other than the type, but is in place for future extensions.\n *\n * See: https://github.com/aurelia/aurelia/issues/1044\n */\nexport class LifecycleHooksDefinition<T extends Constructable = Constructable> {\n  private constructor(\n    public readonly Type: T,\n    public readonly propertyNames: ReadonlySet<string>,\n  ) {}\n\n  /**\n   * @param def - Placeholder for future extensions. Currently always an empty object.\n   */\n  public static create<T extends Constructable>(def: {}, Type: T): LifecycleHooksDefinition<T> {\n    const propertyNames = new Set<string>();\n    let proto = Type.prototype;\n    while (proto !== baseObjectPrototype) {\n      for (const name of getOwnPropertyNames(proto)) {\n        // This is the only check we will do for now. Filtering on e.g. function types might not always work properly when decorators come into play. This would need more testing first.\n        if (name !== 'constructor' && !name.startsWith('_')) {\n          propertyNames.add(name);\n        }\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n\n    return new LifecycleHooksDefinition(Type, propertyNames);\n  }\n}\n\nexport const LifecycleHooks = /*@__PURE__*/(() => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const containerLookup = new WeakMap<IContainer, LifecycleHooksLookup<any>>();\n  // const lhBaseName = getAnnotationKeyFor('lifecycle-hooks');\n  const definitionMap = new WeakMap<Constructable, LifecycleHooksDefinition>();\n\n  return objectFreeze({\n    // name: lhBaseName,\n    /**\n     * @param def - Placeholder for future extensions. Currently always an empty object.\n     */\n    define<T extends Constructable>(def: {}, Type: T): IRegistry {\n      const definition = LifecycleHooksDefinition.create(def, Type);\n      const $Type = definition.Type;\n\n      definitionMap.set($Type, definition);\n\n      return {\n        register(container: IContainer): void {\n          singletonRegistration(ILifecycleHooks, $Type).register(container);\n        }\n      };\n    },\n    /**\n     * @param ctx - The container where the resolution starts\n     * @param Type - The constructor of the Custom element/ Custom attribute with lifecycle metadata\n     */\n    resolve(ctx: IContainer): LifecycleHooksLookup {\n      let lookup = containerLookup.get(ctx);\n      if (lookup === void 0) {\n        containerLookup.set(ctx, lookup = new LifecycleHooksLookupImpl());\n        const root = ctx.root;\n        const instances = root === ctx\n          ? ctx.getAll(ILifecycleHooks)\n          // if it's not root, only resolve it from the current context when it has the resolver\n          // to maintain resources semantic: current -> root\n          : ctx.has(ILifecycleHooks, false)\n            ? root.getAll(ILifecycleHooks).concat(ctx.getAll(ILifecycleHooks))\n            : root.getAll(ILifecycleHooks);\n\n        let instance: ILifecycleHooks;\n        let definition: LifecycleHooksDefinition;\n        let entry: LifecycleHooksEntry;\n        let name: string;\n        let entries: LifecycleHooksEntry[];\n\n        for (instance of instances) {\n          definition = definitionMap.get(instance.constructor as Constructable)!;\n          entry = new LifecycleHooksEntry(definition, instance);\n          for (name of definition.propertyNames) {\n            entries = lookup[name] as LifecycleHooksEntry[];\n            if (entries === void 0) {\n              lookup[name] = [entry];\n            } else {\n              entries.push(entry);\n            }\n          }\n        }\n      }\n      return lookup;\n    },\n  });\n})();\n\nclass LifecycleHooksLookupImpl implements LifecycleHooksLookup {}\n\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function lifecycleHooks(): <T extends Constructable>(target: T, context: ClassDecoratorContext) => T;\nexport function lifecycleHooks<T extends Constructable>(target: T, context: ClassDecoratorContext): T;\nexport function lifecycleHooks<T extends Constructable>(target?: T, context?: ClassDecoratorContext<T>): T | (<T extends Constructable>(target: T, context: ClassDecoratorContext) => T) {\n  function decorator<T extends Constructable>(target: T, context: ClassDecoratorContext): T {\n    const metadata = context?.metadata ?? (target[Symbol.metadata] ??= Object.create(null));\n    metadata[registrableMetadataKey] = LifecycleHooks.define({}, target);\n    return target;\n  }\n  return target == null ? decorator : decorator(target, context!);\n}\n", "import {\n  mergeArrays,\n  firstDefined,\n  resourceBaseName,\n  getResourceKeyFor,\n  resource,\n  isFunction,\n  isString,\n} from '@aurelia/kernel';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\nimport { objectFreeze } from '../utilities';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceDefinition,\n  ResourceType,\n  PartialResourceDefinition,\n  IServiceLocator,\n  StaticResourceType,\n} from '@aurelia/kernel';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\n\nexport type PartialValueConverterDefinition = PartialResourceDefinition;\nexport type ValueConverterStaticAuDefinition = PartialValueConverterDefinition & {\n  type: 'value-converter';\n};\n\nexport type ValueConverterType<T extends Constructable = Constructable> = ResourceType<T, ValueConverterInstance>;\nexport type ValueConverterInstance<T extends {} = {}> = {\n  signals?: string[];\n  withContext?: boolean;\n  toView(input: unknown, ...args: unknown[]): unknown;\n  fromView?(input: unknown, ...args: unknown[]): unknown;\n} & T;\nexport interface ICallerContext {\n  source?: unknown;\n  binding: unknown;\n}\n\nexport type ValueConverterKind = IResourceKind & {\n  isType<T>(value: T): value is (T extends Constructable ? ValueConverterType<T> : never);\n  define<T extends Constructable>(name: string, Type: T, decoratorContext?: DecoratorContext): ValueConverterType<T>;\n  define<T extends Constructable>(def: PartialValueConverterDefinition, Type: T, decoratorContext?: DecoratorContext): ValueConverterType<T>;\n  define<T extends Constructable>(nameOrDef: string | PartialValueConverterDefinition, Type: T, decoratorContext?: DecoratorContext): ValueConverterType<T>;\n  getDefinition<T extends Constructable>(Type: T): ValueConverterDefinition<T>;\n  annotate<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, value: PartialValueConverterDefinition[K]): void;\n  getAnnotation<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, context: DecoratorContext | null): PartialValueConverterDefinition[K] | undefined;\n  find(container: IContainer, name: string): ValueConverterDefinition | null;\n  get(container: IServiceLocator, name: string): ValueConverterInstance;\n};\n\nexport type ValueConverterDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => ValueConverterType<T>;\n\nexport function valueConverter(definition: PartialValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(name: string): ValueConverterDecorator;\nexport function valueConverter(nameOrDef: string | PartialValueConverterDefinition): ValueConverterDecorator;\nexport function valueConverter(nameOrDef: string | PartialValueConverterDefinition): ValueConverterDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext): ValueConverterType<T> {\n    context.addInitializer(function (this) {\n      ValueConverter.define(nameOrDef, this as Constructable);\n    });\n    return target as ValueConverterType<T>;\n  };\n}\n\nexport class ValueConverterDefinition<T extends Constructable = Constructable> implements ResourceDefinition<T, ValueConverterInstance> {\n  private constructor(\n    public readonly Type: ValueConverterType<T>,\n    public readonly name: string,\n    public readonly aliases: readonly string[],\n    public readonly key: string,\n  ) {\n  }\n\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialValueConverterDefinition,\n    Type: ValueConverterType<T>,\n  ): ValueConverterDefinition<T> {\n    let name: string;\n    let def: PartialValueConverterDefinition;\n    if (isString(nameOrDef)) {\n      name = nameOrDef;\n      def = { name };\n    } else {\n      name = nameOrDef.name;\n      def = nameOrDef;\n    }\n    return new ValueConverterDefinition(\n      Type,\n      firstDefined(getConverterAnnotation(Type, 'name'), name),\n      mergeArrays(getConverterAnnotation(Type, 'aliases'), def.aliases, Type.aliases),\n      ValueConverter.keyFrom(name),\n    );\n  }\n\n  public register(container: IContainer, aliasName?: string): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getValueConverterKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    if (!container.has(key, false)) {\n      container.register(\n        container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n        aliasRegistration($Type, key),\n        ...aliases.map(alias => aliasRegistration($Type, getValueConverterKeyFrom(alias)))\n      );\n    } /* istanbul ignore next */ else if(__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV:aurelia] ${createMappedError(ErrorNames.value_converter_existed, this.name)}`);\n    }\n  }\n}\n\n/** @internal */ export const converterTypeName = 'value-converter';\nconst vcBaseName = /*@__PURE__*/getResourceKeyFor(converterTypeName);\nconst getConverterAnnotation = <K extends keyof PartialValueConverterDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialValueConverterDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\nconst getValueConverterKeyFrom = (name: string): string => `${vcBaseName}:${name}`;\n\nexport const ValueConverter = objectFreeze<ValueConverterKind>({\n  name: vcBaseName,\n  keyFrom: getValueConverterKeyFrom,\n  isType<T>(value: T): value is (T extends Constructable ? ValueConverterType<T> : never) {\n    return isFunction(value)\n      && (hasMetadata(vcBaseName, value) || (value as StaticResourceType).$au?.type === converterTypeName);\n  },\n  define<T extends Constructable<ValueConverterInstance>>(nameOrDef: string | PartialValueConverterDefinition, Type: T): ValueConverterType<T> {\n    const definition = ValueConverterDefinition.create(nameOrDef, Type as Constructable<ValueConverterInstance>);\n    const $Type = definition.Type as ValueConverterType<T>;\n\n    // registration of resource name is a requirement for the resource system in kernel (module-loader)\n    defineMetadata(definition, $Type, vcBaseName, resourceBaseName);\n\n    return $Type;\n  },\n  getDefinition<T extends Constructable>(Type: T): ValueConverterDefinition<T> {\n    const def = getMetadata<ValueConverterDefinition<T>>(vcBaseName, Type) ?? getDefinitionFromStaticAu<ValueConverterDefinition<T>, ValueConverterType<T>>(Type as ValueConverterType, converterTypeName, ValueConverterDefinition.create);\n    if (def === void 0) {\n      throw createMappedError(ErrorNames.value_converter_def_not_found, Type);\n    }\n\n    return def;\n  },\n  annotate<K extends keyof PartialValueConverterDefinition>(Type: Constructable, prop: K, value: PartialValueConverterDefinition[K]): void {\n    defineMetadata(value, Type, getAnnotationKeyFor(prop));\n  },\n  getAnnotation: getConverterAnnotation,\n  find(container, name) {\n    const Type = container.find<ValueConverterType>(converterTypeName, name);\n    return Type == null\n      ? null\n      : getMetadata<ValueConverterDefinition>(vcBaseName, Type) ?? getDefinitionFromStaticAu<ValueConverterDefinition, ValueConverterType>(Type, converterTypeName, ValueConverterDefinition.create) ?? null;\n  },\n  get(container, name) {\n    if (__DEV__) {\n      try {\n        return container.get<ValueConverterInstance>(resource(getValueConverterKeyFrom(name)));\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.error('[DEV:aurelia] Cannot retrieve value converter with name', name);\n        throw ex;\n      }\n    }\n    return container.get<ValueConverterInstance>(resource(getValueConverterKeyFrom(name)));\n  },\n});\n", "import { type IServiceLocator, Key, type Constructable, IDisposable, IContainer } from '@aurelia/kernel';\nimport { type ISubscriber, astEvaluate, type Scope, queueAsyncTask, Task } from '@aurelia/runtime';\nimport { type IBinding, type IRateLimitOptions } from './interfaces-bindings';\nimport { BindingBehavior, BindingBehaviorInstance } from '../resources/binding-behavior';\nimport { ValueConverter, ValueConverterInstance } from '../resources/value-converter';\nimport { addSignalListener, defineHiddenProp, removeSignalListener, tsPending } from '../utilities';\nimport { createInterface } from '../utilities-di';\nimport { PropertyBinding } from './property-binding';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { ISignaler } from '../signaler';\nimport { IHydrationContext } from '../templating/controller';\nimport type { ICallerContext } from '../resources/value-converter';\n\n/**\n * A subscriber that is used for subcribing to target observer & invoking `updateSource` on a binding\n */\nexport class BindingTargetSubscriber implements ISubscriber {\n  /** @internal */\n  private readonly b: PropertyBinding;\n  // flush queue is a way to handle the notification order in a synchronous change notification system\n  // without a flush queue, changes are notified depth first\n  // with    a flush queue, changes are notified breadth first\n  //\n  // though we are only queueing target->source direction and that's already enough to prevent such issues\n  /** @internal */\n  private readonly _flushQueue: IFlushQueue;\n  /** @internal */\n  private _value: unknown = void 0;\n\n  public constructor(\n    b: PropertyBinding,\n    // flush queue is a way to handle the notification order in a synchronous change notification system\n    // without a flush queue, changes are notified depth first\n    // with    a flush queue, changes are notified breadth first\n    flushQueue: IFlushQueue,\n  ) {\n    this.b = b;\n    this._flushQueue = flushQueue;\n  }\n\n  public flush() {\n    // when the owning binding is unbound, there's cases where this subscriber still queued\n    // and will be flushed\n    // adding this check so that it does flush at an inappropriate time\n    // todo: maybe consider a way to dequeue this as well if necessary\n    if (this.b.isBound) {\n      this.b.updateSource(this._value);\n    }\n  }\n\n  // deepscan-disable-next-line\n  public handleChange(value: unknown, _: unknown): void {\n    const b = this.b;\n    if (value !== astEvaluate(b.ast, b._scope!, b, null)) {\n      this._value = value;\n      this._flushQueue.add(this);\n    }\n  }\n}\n\n/**\n * Implement method `useScope` in a common way for a binding. For internal use only for size saving.\n */\nexport const mixinUseScope = /*@__PURE__*/(() => {\n  function useScope<T extends { _scope?: Scope }>(this: T, scope: Scope) {\n    this._scope = scope;\n  }\n  return <T extends { _scope?: Scope }>(target: Constructable<T>) => {\n    defineHiddenProp(target.prototype, 'useScope', useScope);\n  };\n})();\n\n/**\n * Turns a class into AST evaluator with support for value converter & binding behavior. For internal use only\n */\nexport const mixinAstEvaluator = /*@__PURE__*/(() => {\n  type IHasServiceLocator = { l: IServiceLocator };\n\n  class ResourceLookup {\n    [key: string]: ValueConverterInstance | BindingBehaviorInstance;\n  }\n\n  const converterResourceLookupCache = new WeakMap<{ l: IServiceLocator }, Record<string, ValueConverterInstance>>();\n  const behaviorResourceLookupCache = new WeakMap<{ l: IServiceLocator }, Record<string, BindingBehaviorInstance>>();\n  const appliedBehaviors = new WeakMap<{ l: IServiceLocator }, Record<string, boolean>>();\n\n  function evaluatorGet<T extends IHasServiceLocator>(this: T, key: Key) {\n    return this.l.get(key);\n  }\n  function evaluatorGetBehavior<T extends IHasServiceLocator>(b: T, name: string) {\n    let resourceLookup = behaviorResourceLookupCache.get(b);\n    if (resourceLookup == null) {\n      behaviorResourceLookupCache.set(b, resourceLookup = new ResourceLookup() as Record<string, BindingBehaviorInstance>);\n    }\n    return resourceLookup[name] ??= BindingBehavior.get(b.l, name);\n  }\n  function evaluatorBindBehavior<T extends IHasServiceLocator>(this: T, name: string, scope: Scope, args: unknown[]) {\n    const behavior = evaluatorGetBehavior(this, name);\n    if (behavior == null) {\n      throw createMappedError(ErrorNames.ast_behavior_not_found, name);\n    }\n\n    let applied = appliedBehaviors.get(this);\n    if (applied == null) {\n      appliedBehaviors.set(this, applied = {});\n    }\n    if (applied[name]) {\n      throw createMappedError(ErrorNames.ast_behavior_duplicated, name);\n    }\n    // todo: remove casting\n    // there should be a base \"mixinAstEvaluator\" factory that takes parameters to handle behaviors/converters\n    // so observation infra can be free of template oriented features: behaviors/converters\n    // or anything that is not supposed to be supporting binding behavior shouldn't be using this mixin\n    behavior.bind?.(scope, this as unknown as IBinding, ...args);\n  }\n\n  function evaluatorUnbindBehavior<T extends IHasServiceLocator>(this: T, name: string, scope: Scope) {\n    const behavior = evaluatorGetBehavior(this, name);\n    const applied = appliedBehaviors.get(this);\n\n    // todo: remove casting\n    // there should be a base \"mixinAstEvaluator\" factory that takes parameters to handle behaviors/converters\n    // so observation infra can be free of template oriented features: behaviors/converters\n    // or anything that is not supposed to be supporting binding behavior shouldn't be using this mixin\n    behavior?.unbind?.(scope, this as unknown as IBinding);\n    if (applied != null) {\n      applied[name] = false;\n    }\n  }\n\n  function evaluatorGetConverter<T extends IHasServiceLocator>(b: T, name: string) {\n    let resourceLookup = converterResourceLookupCache.get(b);\n    if (resourceLookup == null) {\n      converterResourceLookupCache.set(b, resourceLookup = new ResourceLookup() as Record<string, ValueConverterInstance>);\n    }\n    return resourceLookup[name] ??= ValueConverter.get(b.l as IContainer, name);\n  }\n  function evaluatorBindConverter<T extends IHasServiceLocator>(this: T, name: string) {\n    const vc = evaluatorGetConverter(this, name);\n    if (vc == null) {\n      throw createMappedError(ErrorNames.ast_converter_not_found, name);\n    }\n    const signals = vc.signals;\n    if (signals != null) {\n      const signaler = this.l.get(ISignaler);\n      const ii = signals.length;\n      let i = 0;\n      for (; i < ii; ++i) {\n        // note: the cast is expected. To connect, it just needs to be a IConnectable\n        // though to work with signal, it needs to have `handleChange`\n        // so having `handleChange` as a guard in the connectable as a safe measure is needed\n        // to make sure signaler works\n        signaler.addSignalListener(signals[i], this as unknown as ISubscriber);\n      }\n    }\n  }\n\n  function evaluatorUnbindConverter<T extends IHasServiceLocator>(this: T, name: string) {\n    const vc = evaluatorGetConverter(this, name);\n    if (vc?.signals === void 0) {\n      return;\n    }\n    const signaler = this.l.get(ISignaler);\n    let i = 0;\n    for (; i < vc.signals.length; ++i) {\n      signaler.removeSignalListener(vc.signals[i], this as unknown as ISubscriber);\n    }\n  }\n\n  function evaluatorUseConverter<T extends IHasServiceLocator>(this: T, name: string, mode: 'toView' | 'fromView', value: unknown, args: unknown[]) {\n    const vc = evaluatorGetConverter(this, name);\n    if (vc == null) {\n      throw createMappedError(ErrorNames.ast_converter_not_found, name);\n    }\n    // Get the value converter instance to check for withContext\n    const withContext = vc.withContext === true;\n    // Compose caller context\n    let callerContext: ICallerContext | null = null;\n    if (withContext) {\n      const hydrationContext = this.l.get(IHydrationContext);\n      const controller = hydrationContext.controller;\n      const viewModel = controller.viewModel;\n      callerContext = {\n        source: viewModel,\n        binding: this,\n      };\n    }\n    switch (mode) {\n      case 'toView': {\n        if ('toView' in vc) {\n          return withContext\n            ? vc.toView(value, callerContext, ...args)\n            : vc.toView(value, ...args);\n        }\n        return value;\n      }\n      case 'fromView': {\n        if ('fromView' in vc) {\n          return withContext\n            ? vc.fromView?.(value, callerContext, ...args)\n            : vc.fromView?.(value, ...args);\n        }\n        return value;\n      }\n    }\n  }\n\n  return <T extends IHasServiceLocator>(target: Constructable<T>) => {\n    const proto = target.prototype;\n    defineHiddenProp(proto, 'get', evaluatorGet<T>);\n    defineHiddenProp(proto, 'bindBehavior', evaluatorBindBehavior<T>);\n    defineHiddenProp(proto, 'unbindBehavior', evaluatorUnbindBehavior<T>);\n    defineHiddenProp(proto, 'bindConverter', evaluatorBindConverter<T>);\n    defineHiddenProp(proto, 'unbindConverter', evaluatorUnbindConverter<T>);\n    defineHiddenProp(proto, 'useConverter', evaluatorUseConverter<T>);\n  };\n})();\n\n/**\n * A synchronous queue used internally for ensuring update source are not called depth first\n */\nexport interface IFlushable {\n  flush(): void;\n}\n\nexport const IFlushQueue = /*@__PURE__*/createInterface<IFlushQueue>('IFlushQueue', x => x.singleton(FlushQueue));\nexport interface IFlushQueue {\n  get count(): number;\n  add(flushable: IFlushable): void;\n}\n\nexport class FlushQueue implements IFlushQueue {\n  /** @internal */\n  private _flushing: boolean = false;\n  /** @internal */\n  private readonly _items: Set<IFlushable> = new Set();\n\n  public get count(): number {\n    return this._items.size;\n  }\n\n  public add(flushable: IFlushable): void {\n    this._items.add(flushable);\n    if (this._flushing) {\n      return;\n    }\n    this._flushing = true;\n    try {\n      this._items.forEach(flushItem);\n    } finally {\n      this._flushing = false;\n    }\n  }\n\n  public clear(): void {\n    this._items.clear();\n    this._flushing = false;\n  }\n}\n\nconst flushItem = function (item: IFlushable, _: IFlushable, items: Set<IFlushable>) {\n  items.delete(item);\n  item.flush();\n};\n\n/**\n * A mixing for bindings to implement a set of default behvaviors for rate limiting their calls.\n *\n * For internal use only\n */\nexport const mixingBindingLimited = /*@__PURE__*/ (() => {\n  const withLimitationBindings = new WeakSet<IBinding>();\n  /**\n   * A helper for creating rated limited functions for binding. For internal use only\n   */\n  const debounced = <T extends (v?: unknown) => unknown>(opts: IRateLimitOptions, callOriginal: T, binding: IBinding): LimiterHandle => {\n    let limiterTask: Task | undefined;\n    let task: Task | undefined;\n    let latestValue: unknown;\n    let isPending = false;\n    const callOriginalCallback = () => callOriginal(latestValue);\n    const fn = (v: unknown) => {\n      latestValue = v;\n      if (binding.isBound) {\n        task = limiterTask;\n        limiterTask = queueAsyncTask(callOriginalCallback, { delay: opts.delay });\n        task?.cancel();\n      } else {\n        callOriginalCallback();\n      }\n    };\n    const dispose = fn.dispose = () => {\n      task?.cancel();\n      limiterTask?.cancel();\n      task = limiterTask = void 0;\n    };\n    fn.flush = () => {\n      // only call callback when there's actually task being queued\n      isPending = limiterTask?.status === tsPending;\n      dispose();\n      if (isPending) {\n        callOriginalCallback();\n      }\n    };\n\n    return fn;\n  };\n\n  /**\n   * A helper for creating rated limited functions for binding. For internal use only\n   */\n  const throttled = <T extends (v?: unknown) => unknown>(opts: IRateLimitOptions, callOriginal: T, binding: IBinding): LimiterHandle => {\n    let limiterTask: Task | undefined;\n    let task: Task | undefined;\n    let last: number = 0;\n    let elapsed = 0;\n    let latestValue: unknown;\n    let isPending = false;\n    const now = () => opts.now();\n    const callOriginalCallback = () => callOriginal(latestValue);\n    const fn = (v: unknown) => {\n      latestValue = v;\n      if (binding.isBound) {\n        elapsed = now() - last;\n        task = limiterTask;\n        if (elapsed > opts.delay) {\n          last = now();\n          callOriginalCallback();\n        } else {\n          // Queue the new one before canceling the old one, to prevent early yield\n          limiterTask = queueAsyncTask(() => {\n            last = now();\n            callOriginalCallback();\n          }, { delay: opts.delay - elapsed });\n        }\n        task?.cancel();\n      } else {\n        callOriginalCallback();\n      }\n    };\n    const dispose = fn.dispose = () => {\n      task?.cancel();\n      limiterTask?.cancel();\n      task = limiterTask = void 0;\n    };\n    fn.flush = () => {\n      // only call callback when there's actually task being queued\n      isPending = limiterTask?.status === tsPending;\n      dispose();\n      if (isPending) {\n        callOriginalCallback();\n      }\n    };\n    return fn;\n  };\n\n  type LimiterHandle = IDisposable & {\n    (v: unknown, oV?: unknown): void;\n    flush(): void;\n  };\n\n  return <T extends IBinding>(target: Constructable<T>, getMethodName: (binding: T, opts: IRateLimitOptions) => keyof T) => {\n    defineHiddenProp(target.prototype, 'limit', function (this: T, opts: IRateLimitOptions) {\n      if (withLimitationBindings.has(this)) {\n        throw createMappedError(ErrorNames.binding_already_has_rate_limited);\n      }\n      withLimitationBindings.add(this);\n      const prop = getMethodName(this, opts);\n      const signals = opts.signals;\n      const signaler = signals.length > 0 ? this.get(ISignaler) : null;\n      const originalFn = this[prop] as unknown as (...args: unknown[]) => unknown;\n      const callOriginal = (...args: unknown[]) => originalFn.call(this, ...args);\n      const limitedFn = opts.type === 'debounce'\n        ? debounced(opts, callOriginal, this)\n        : throttled(opts, callOriginal, this);\n      const signalListener = signaler ? { handleChange: limitedFn.flush } : null;\n      this[prop] = limitedFn as unknown as typeof this[typeof prop];\n      if (signaler) {\n        signals.forEach(s => addSignalListener(signaler, s, signalListener!));\n      }\n\n      return {\n        dispose: () => {\n          if (signaler) {\n            signals.forEach(s => removeSignalListener(signaler, s, signalListener!));\n          }\n          withLimitationBindings.delete(this);\n          limitedFn.dispose();\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete this[prop];\n        }\n      };\n    });\n  };\n})();\n\nexport const createPrototypeMixer = ((mixed = new WeakSet<Constructable<IBinding>>()) => {\n  return (mixer: () => void) => {\n    return function<T extends Constructable<IBinding>>(this: T) {\n      if (!mixed.has(this)) {\n        mixed.add(this);\n        mixer.call(this);\n      }\n    };\n  };\n})();\n", "import { type IServiceLocator, isString } from '@aurelia/kernel';\nimport {\n  connectable,\n  type IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  ICollectionSubscriber,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  type IAstEvaluator,\n  type Scope,\n  queueTask,\n} from '@aurelia/runtime';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { oneTime, toView } from './interfaces-bindings';\n\nimport type { INode } from '../dom.node';\nimport type { IBinding, BindingMode, IBindingController } from './interfaces-bindings';\nimport { safeString } from '../utilities';\nimport { ForOfStatement, IsBindingBehavior } from '@aurelia/expression-parser';\n\n// the 2 interfaces implemented come from mixin\nexport interface AttributeBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\n\n/**\n * Attribute binding. Handle attribute binding betwen view/view model. Understand Html special attributes\n */\nexport class AttributeBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n      mixinUseScope(AttributeBinding);\n      mixingBindingLimited(AttributeBinding, () => 'updateTarget');\n      connectable(AttributeBinding, null!);\n      mixinAstEvaluator(AttributeBinding);\n  });\n\n  /** @internal */\n  private static readonly _splitString: Map<string, string[]> = new Map();\n\n  public isBound: boolean = false;\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /** @internal */\n  private _isQueued: boolean = false;\n\n  public target: HTMLElement;\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  /** @internal */\n  public readonly l: IServiceLocator;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public ast: IsBindingBehavior | ForOfStatement;\n\n  /** @internal */\n  private readonly _isMulti: boolean = false;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    ast: IsBindingBehavior | ForOfStatement,\n    target: INode,\n    // some attributes may have inner structure\n    // such as class -> collection of class names\n    // such as style -> collection of style rules\n    //\n    // for normal attributes, targetAttribute and targetProperty are the same and can be ignore\n    public targetAttribute: string,\n    // is the classes to be toggled\n    public targetProperty: string,\n    public mode: BindingMode,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this.ast = ast;\n    this._controller = controller;\n    this.target = target as HTMLElement;\n    this.oL = observerLocator;\n    // eslint-disable-next-line @typescript-eslint/prefer-includes\n    if ((this._isMulti = targetProperty.indexOf(' ') > -1)\n      && !AttributeBinding._splitString.has(targetProperty)\n    ) {\n      // split the string once and cache it\n      AttributeBinding._splitString.set(targetProperty, targetProperty.split(' '));\n    }\n  }\n\n  public updateTarget(value: unknown): void {\n    const target = this.target;\n    const targetAttribute = this.targetAttribute;\n    const targetProperty = this.targetProperty;\n    switch (targetAttribute) {\n      case 'class':\n        if (this._isMulti) {\n          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n          const force = !!value;\n          for (const cls of AttributeBinding._splitString.get(targetProperty)!) {\n            target.classList.toggle(cls, force);\n          }\n        } else {\n          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n          target.classList.toggle(targetProperty, !!value);\n        }\n        break;\n      case 'style': {\n        let priority = '';\n        let newValue = safeString(value);\n        if (isString(newValue) && newValue.includes('!important')) {\n          priority = 'important';\n          newValue = newValue.replace('!important', '');\n        }\n        target.style.setProperty(targetProperty, newValue, priority);\n        break;\n      }\n      default: {\n        if (value == null) {\n          target.removeAttribute(targetAttribute);\n        } else {\n          target.setAttribute(targetAttribute, safeString(value));\n        }\n      }\n    }\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) return;\n    if (this._isQueued) return;\n    this._isQueued = true;\n\n    queueTask(() => {\n      this._isQueued = false;\n      if (!this.isBound) return;\n\n      this.obs.version++;\n      const newValue = astEvaluate(this.ast, this._scope!, this, (this.mode & toView) > 0 ? this : null);\n      this.obs.clear();\n\n      if (newValue !== this._value) {\n        this._value = newValue;\n        this.updateTarget(newValue);\n      }\n    });\n  }\n\n  // todo: based off collection and handle update accordingly instead off always start\n  public handleCollectionChange(): void {\n    this.handleChange();\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    if (this.mode & (toView | oneTime)) {\n      this.updateTarget(\n        this._value = astEvaluate(this.ast, scope, this, (this.mode & toView) > 0 ? this : null)\n      );\n    }\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this._value = void 0;\n    this.obs.clearAll();\n  }\n}\n", "import { type IServiceLocator, isArray } from '@aurelia/kernel';\nimport {\n  connectable,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  IAstEvaluator,\n  queueTask,\n} from '@aurelia/runtime';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { toView } from './interfaces-bindings';\n\nimport type {\n  AccessorOrObserver,\n  IAccessor,\n  ICollectionSubscriber,\n  IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  Scope,\n} from '@aurelia/runtime';\nimport type { IBinding, BindingMode, IBindingController } from './interfaces-bindings';\nimport { type Interpolation, IsExpression } from '@aurelia/expression-parser';\nimport { activating } from '../templating/controller';\nimport { atLayout } from '../utilities';\n\n// a pseudo binding to manage multiple InterpolationBinding s\n// ========\n// Note: the child expressions of an Interpolation expression are full Aurelia expressions, meaning they may include\n// value converters and binding behaviors.\n// Each expression represents one ${interpolation}, and for each we create a child InterpolationPartBinding\n\nexport interface InterpolationBinding extends IObserverLocatorBasedConnectable, IAstEvaluator, IServiceLocator {}\nexport class InterpolationBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /** @internal */\n  private _isQueued: boolean = false;\n\n  public partBindings: InterpolationPartBinding[];\n\n  /** @internal */\n  public _targetObserver: AccessorOrObserver;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    public ast: Interpolation,\n    public target: object,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public strict: boolean,\n  ) {\n    this._controller = controller;\n    this.oL = observerLocator;\n    this._targetObserver = observerLocator.getAccessor(target, targetProperty);\n    const expressions = ast.expressions;\n    const partBindings = this.partBindings = Array(expressions.length);\n    const ii = expressions.length;\n    let i = 0;\n    for (; ii > i; ++i) {\n      partBindings[i] = new InterpolationPartBinding(expressions[i], target, targetProperty, locator, observerLocator, strict, this);\n    }\n  }\n\n  /** @internal */\n  public _handlePartChange() {\n    if (!this.isBound) return;\n\n    const shouldQueue = this._controller.state !== activating && (this._targetObserver.type & atLayout) > 0;\n\n    if (shouldQueue) {\n      if (this._isQueued) return;\n      this._isQueued = true;\n\n      queueTask(() => {\n        this._isQueued = false;\n        if (!this.isBound) return;\n\n        this.updateTarget();\n      });\n    } else {\n      this.updateTarget();\n    }\n  }\n\n  public updateTarget(): void {\n    const partBindings = this.partBindings;\n    const ast = this.ast;\n    const target = this.target;\n    const targetProperty = this.targetProperty;\n    const staticParts = ast.parts;\n    const ii = partBindings.length;\n    let result = '';\n    let i = 0;\n    if (ii === 1) {\n      // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n      result = staticParts[0] + partBindings[0]._evaluate() + staticParts[1];\n    } else {\n      result = staticParts[0];\n      for (; ii > i; ++i) {\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        result += partBindings[i]._evaluate() + staticParts[i + 1];\n      }\n    }\n\n    this._targetObserver.setValue(result, target, targetProperty);\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this._scope = scope;\n\n    const partBindings = this.partBindings;\n    const ii = partBindings.length;\n    let i = 0;\n    for (; ii > i; ++i) {\n      partBindings[i].bind(scope);\n    }\n    this.updateTarget();\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n    this._scope = void 0;\n    const partBindings = this.partBindings;\n    const ii = partBindings.length;\n    let i = 0;\n    for (; ii > i; ++i) {\n      partBindings[i].unbind();\n    }\n  }\n\n  /**\n   * Start using a given observer to update the target\n   */\n  public useAccessor(accessor: IAccessor): void {\n    this._targetObserver = accessor;\n  }\n}\n\n// a pseudo binding, part of a larger interpolation binding\n// employed to support full expression per expression part of an interpolation\nexport interface InterpolationPartBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator {}\n\nexport class InterpolationPartBinding implements IBinding, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(InterpolationPartBinding);\n    mixingBindingLimited(InterpolationPartBinding, () => 'updateTarget');\n    connectable(InterpolationPartBinding, null!);\n    mixinAstEvaluator(InterpolationPartBinding);\n  });\n\n  // at runtime, mode may be overriden by binding behavior\n  // but it wouldn't matter here, just start with something for later check\n  public readonly mode: BindingMode = toView;\n  public _scope?: Scope;\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _value: unknown = '';\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public readonly l: IServiceLocator;\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  /** @internal */\n  private _isDirty = false;\n\n  public constructor(\n    public readonly ast: IsExpression,\n    public readonly target: object,\n    public readonly targetProperty: string,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    public strict: boolean,\n    public readonly owner: InterpolationBinding,\n  ) {\n    this.l = locator;\n    this.oL = observerLocator;\n  }\n\n  public updateTarget() {\n    this.owner._handlePartChange();\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) return;\n    this._isDirty = true;\n    this.updateTarget();\n  }\n\n  public handleCollectionChange(): void {\n    if (!this.isBound) return;\n    this._isDirty = true;\n    this.updateTarget();\n  }\n\n  /** @internal */\n  public _evaluate() {\n    if (!this._isDirty) return this._value;\n\n    this.obs.version++;\n    const newValue = astEvaluate(this.ast, this._scope!, this, (this.mode & toView) > 0 ? this : null);\n    this.obs.clear();\n\n    // unlike handleChange, this is always called\n    this._value = newValue;\n    if (isArray(newValue)) {\n      this.observeCollection(newValue);\n    }\n\n    this._isDirty = false;\n    return this._value;\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ?  this : null);\n    if (isArray(this._value)) {\n      this.observeCollection(this._value);\n    }\n\n    this._isDirty = false;\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n    this._value = void 0;\n    this._isDirty = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this.obs.clearAll();\n  }\n}\n", "import {\n  connectable,\n  IAstEvaluator,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  queueTask,\n} from '@aurelia/runtime';\nimport { toView } from './interfaces-bindings';\nimport { type IServiceLocator, isArray } from '@aurelia/kernel';\nimport type {\n  ICollectionSubscriber,\n  IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  Scope,\n} from '@aurelia/runtime';\nimport type { IPlatform } from '../platform';\nimport { safeString } from '../utilities';\nimport type { BindingMode, IBinding, IBindingController } from './interfaces-bindings';\nimport { mixinUseScope, mixingBindingLimited, mixinAstEvaluator, createPrototypeMixer } from './binding-utils';\nimport { IsExpression } from '@aurelia/expression-parser';\n\nexport interface ContentBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\n\n/**\n * A binding for handling the element content interpolation\n */\n\nexport class ContentBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(ContentBinding);\n    mixingBindingLimited(ContentBinding, () => 'updateTarget');\n    connectable(ContentBinding, null!);\n    mixinAstEvaluator(ContentBinding);\n  });\n\n  public isBound: boolean = false;\n\n  // at runtime, mode may be overriden by binding behavior\n  // but it wouldn't matter here, just start with something for later check\n  public readonly mode: BindingMode = toView;\n\n  /** @internal */\n  public _scope?: Scope;\n\n  /** @internal */\n  public _isQueued: boolean = false;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public readonly l: IServiceLocator;\n\n  /** @internal */\n  private _value: unknown = '';\n  /** @internal */\n  private readonly _controller: IBindingController;\n  /** @internal */\n  private _needsRemoveNode: boolean = false;\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    private readonly p: IPlatform,\n    public readonly ast: IsExpression,\n    public readonly target: Text,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this._controller = controller;\n    this.oL = observerLocator;\n  }\n\n  public updateTarget(value: unknown): void {\n    const target = this.target;\n    const oldValue = this._value;\n    this._value = value;\n    if (this._needsRemoveNode) {\n      (oldValue as Node).parentNode?.removeChild(oldValue as Node);\n      this._needsRemoveNode = false;\n    }\n    if (value instanceof this.p.Node) {\n      target.parentNode?.insertBefore(value, target);\n      value = '';\n      this._needsRemoveNode = true;\n    }\n    target.textContent = safeString(value ?? '');\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) return;\n    if (this._isQueued) return;\n    this._isQueued = true;\n\n    queueTask(() => {\n      this._isQueued = false;\n      if (!this.isBound) return;\n\n      this.obs.version++;\n      const newValue = astEvaluate(this.ast, this._scope!, this, (this.mode & toView) > 0 ? this : null);\n      this.obs.clear();\n\n      if (newValue !== this._value) {\n        this.updateTarget(newValue);\n      }\n    });\n  }\n\n  public handleCollectionChange(): void {\n    if (!this.isBound) return;\n    if (this._isQueued) return;\n    this._isQueued = true;\n\n    queueTask(() => {\n      this._isQueued = false;\n      if (!this.isBound) return;\n\n      this.obs.version++;\n      const v = this._value = astEvaluate(this.ast, this._scope!, this, (this.mode & toView) > 0 ? this : null);\n      this.obs.clear();\n\n      if (isArray(v)) {\n        this.observeCollection(v);\n      }\n      this.updateTarget(v);\n    });\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    const v = this._value = astEvaluate(\n      this.ast,\n      this._scope,\n      this,\n      (this.mode & toView) > 0 ? this : null\n    );\n    if (isArray(v)) {\n      this.observeCollection(v);\n    }\n    this.updateTarget(v);\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n    if (this._needsRemoveNode) {\n      (this._value as Node).parentNode?.removeChild(this._value as Node);\n    }\n\n    // TODO: should existing value (either connected node, or a string)\n    // be removed when this binding is unbound?\n    // this.updateTarget('');\n    this._scope = void 0;\n    this.obs.clearAll();\n  }\n}\n", "import {\n  ICollectionSubscriber,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  connectable,\n  type IObservable,\n  type IObserverLocator,\n  type Scope,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  type IAstEvaluator,\n} from '@aurelia/runtime';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\n\nimport type { IIndexable, IServiceLocator } from '@aurelia/kernel';\nimport { IsExpression } from '@aurelia/expression-parser';\nimport { IBinding } from './interfaces-bindings';\nexport interface LetBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator {}\n\nexport class LetBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /**\n   * The renderer can call this method to prepare the prototype,\n   * so that it can be effectively tree shaken before decorator can be officially applied with tree shaking.\n   * @internal\n   */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(LetBinding);\n    mixingBindingLimited(LetBinding, () => 'updateTarget');\n    connectable(LetBinding, null!);\n    mixinAstEvaluator(LetBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  public target: (IObservable & IIndexable) | null = null;\n  /** @internal */\n  private readonly _toBindingContext: boolean;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  /** @internal */\n  private _value: unknown;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public strict: boolean;\n\n  public constructor(\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    public ast: IsExpression,\n    public targetProperty: string,\n    toBindingContext: boolean,\n    strict: boolean,\n  ) {\n    this.l = locator;\n    this.oL = observerLocator;\n    this.strict = strict;\n    this._toBindingContext = toBindingContext;\n  }\n\n  public updateTarget() {\n    this.target![this.targetProperty] = this._value;\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) return;\n    this.obs.version++;\n    this._value = astEvaluate(this.ast, this._scope!, this, this);\n    this.obs.clear();\n    this.updateTarget();\n  }\n\n  public handleCollectionChange(): void {\n    this.handleChange();\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === _scope) return;\n      this.unbind();\n    }\n    this._scope = _scope;\n    this.target = (this._toBindingContext ? _scope.bindingContext : _scope.overrideContext) as IIndexable;\n\n    astBind(this.ast, _scope, this);\n\n    this._value = astEvaluate(this.ast, this._scope, this, this);\n    this.updateTarget();\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this.obs.clearAll();\n  }\n}\n", "import {\n  connectable,\n  ISubscriber,\n  astAssign,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  IAstEvaluator,\n  type Scope,\n  type AccessorOrObserver,\n  type ICollectionSubscriber,\n  type IObserver,\n  type IObserverLocator,\n  type IObserverLocatorBasedConnectable,\n  queueTask,\n} from '@aurelia/runtime';\nimport { BindingTargetSubscriber, IFlushQueue, createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { IBinding, fromView, oneTime, toView } from './interfaces-bindings';\n\nimport type { IServiceLocator } from '@aurelia/kernel';\nimport type { BindingMode, IBindingController } from './interfaces-bindings';\nimport { createMappedError, ErrorNames } from '../errors';\nimport { atLayout } from '../utilities';\nimport { type IsBindingBehavior, ForOfStatement } from '@aurelia/expression-parser';\nimport { activating } from '../templating/controller';\n\nexport interface PropertyBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\n\nexport class PropertyBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(PropertyBinding);\n    mixingBindingLimited(PropertyBinding, (propBinding: PropertyBinding) => (propBinding.mode & fromView) ? 'updateSource' : 'updateTarget');\n    connectable(PropertyBinding, null!);\n    mixinAstEvaluator(PropertyBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /** @internal */\n  private _targetObserver?: AccessorOrObserver = void 0;\n\n  /** @internal */\n  private _isQueued: boolean = false;\n\n  /** @internal */\n  private _targetSubscriber: ISubscriber | null = null;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  public constructor(\n    controller: IBindingController,\n    locator: IServiceLocator,\n    observerLocator: IObserverLocator,\n    public ast: IsBindingBehavior | ForOfStatement,\n    public target: object,\n    public targetProperty: string,\n    public mode: BindingMode,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this._controller = controller;\n    this.oL = observerLocator;\n  }\n\n  public updateTarget(value: unknown): void {\n    this._targetObserver!.setValue(value, this.target, this.targetProperty);\n  }\n\n  public updateSource(value: unknown): void {\n    astAssign(this.ast, this._scope!, this, null, value);\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) return;\n\n    const shouldQueue = this._controller.state !== activating && (this._targetObserver!.type & atLayout) > 0;\n    if (shouldQueue) {\n      if (this._isQueued) return;\n      this._isQueued = true;\n\n      queueTask(() => {\n        this._isQueued = false;\n        if (!this.isBound) return;\n\n        this._handleChange();\n      });\n    } else {\n      this._handleChange();\n    }\n  }\n\n  /** @internal */\n  private _handleChange() {\n    this.obs.version++;\n    const newValue = astEvaluate(this.ast, this._scope!, this, (this.mode & toView) > 0 ? this : null);\n    this.obs.clear();\n\n    this.updateTarget(newValue);\n  }\n\n  // todo: based off collection and handle update accordingly instead off always start\n  public handleCollectionChange(): void {\n    this.handleChange();\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    const observerLocator = this.oL;\n    const $mode = this.mode;\n    let targetObserver = this._targetObserver;\n    if (!targetObserver) {\n      if ($mode & fromView) {\n        targetObserver = observerLocator.getObserver(this.target, this.targetProperty);\n      } else {\n        targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);\n      }\n      this._targetObserver = targetObserver;\n    }\n\n    const shouldConnect = ($mode & toView) > 0;\n\n    if ($mode & (toView | oneTime)) {\n      this.updateTarget(\n        astEvaluate(this.ast, this._scope, this, shouldConnect ? this : null),\n      );\n    }\n\n    if ($mode & fromView) {\n      (targetObserver as IObserver).subscribe(this._targetSubscriber ??= new BindingTargetSubscriber(this, this.l.get(IFlushQueue)));\n      if (!shouldConnect) {\n        this.updateSource(targetObserver.getValue(this.target, this.targetProperty));\n      }\n    }\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n\n    if (this._targetSubscriber) {\n      (this._targetObserver as IObserver).unsubscribe(this._targetSubscriber);\n      this._targetSubscriber = null;\n    }\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n\n    this.obs.clearAll();\n  }\n\n  /**\n   * Start using a given observer to listen to changes on the target of this binding\n   */\n  public useTargetObserver(observer: IObserver): void {\n    (this._targetObserver as IObserver)?.unsubscribe(this);\n    (this._targetObserver = observer).subscribe(this);\n  }\n\n  /**\n   * Provide a subscriber for target change observation.\n   *\n   * Binding behaviors can use this to setup custom observation handling during bind lifecycle\n   * to alter the update source behavior during bind phase of this binding.\n   */\n  public useTargetSubscriber(subscriber: ISubscriber): void {\n    if (this._targetSubscriber != null) {\n      throw createMappedError(ErrorNames.binding_already_has_target_subscriber);\n    }\n    this._targetSubscriber = subscriber;\n  }\n}\n", "import type { IServiceLocator } from '@aurelia/kernel';\nimport {\n  type ICollectionSubscriber,\n  type IObserverLocatorBasedConnectable,\n  type ISubscriber,\n  type Scope,\n  astAssign,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  type IAstEvaluator,\n  connectable,\n  IObserverLocator,\n} from '@aurelia/runtime';\nimport { createPrototypeMixer, mixinAstEvaluator, mixingBindingLimited, mixinUseScope } from './binding-utils';\nimport { type IsBindingBehavior } from '@aurelia/expression-parser';\nimport { IBinding } from './interfaces-bindings';\n\nexport interface RefBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator { }\nexport class RefBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    connectable(RefBinding, null!);\n    mixingBindingLimited(RefBinding, () => 'updateSource');\n    mixinUseScope(RefBinding);\n    mixinAstEvaluator(RefBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  public constructor(\n    locator: IServiceLocator,\n    public oL: IObserverLocator,\n    public ast: IsBindingBehavior,\n    public target: object,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n  }\n\n  public updateSource() {\n    if (this.isBound) {\n      this.obs.version++;\n      astAssign(this.ast, this._scope!, this, this, this.target);\n      this.obs.clear();\n    } else {\n      astAssign(this.ast, this._scope!, this, null, null);\n    }\n  }\n\n  public handleChange(): void {\n    if (this.isBound) {\n      this.updateSource();\n    }\n  }\n\n  public handleCollectionChange(): void {\n    if (this.isBound) {\n      this.updateSource();\n    }\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n    this.isBound = true;\n\n    this.updateSource();\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n    this.obs.clearAll();\n\n    if (astEvaluate(this.ast, this._scope!, this, null) === this.target) {\n      this.updateSource();\n    }\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n  }\n}\n", "import { type IsBindingBehavior } from '@aurelia/expression-parser';\nimport { isArray, isFunction, isString, resolve, type IServiceLocator, all, IContainer } from '@aurelia/kernel';\nimport { objectFreeze } from '../utilities';\nimport { createInterface, singletonRegistration } from '../utilities-di';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\n\nimport {\n  ICollectionSubscriber,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  type Scope,\n  astBind,\n  astEvaluate,\n  astUnbind,\n  IAstEvaluator,\n} from '@aurelia/runtime';\nimport { IBinding } from './interfaces-bindings';\n\nexport class ListenerBindingOptions {\n  public constructor(\n    public readonly prevent: boolean,\n    public readonly capture: boolean = false,\n    public readonly onError: (event: Event, error: unknown) => void,\n  ) {}\n}\n\nexport interface ListenerBinding extends IAstEvaluator, IObserverLocatorBasedConnectable, IServiceLocator {}\n/**\n * Listener binding. Handle event binding between view and view model\n */\nexport class ListenerBinding implements IBinding, ISubscriber, ICollectionSubscriber {\n  /** @internal */\n  public static mix = createPrototypeMixer(function () {\n    mixinUseScope(ListenerBinding);\n    mixingBindingLimited(ListenerBinding, () => 'callSource');\n    mixinAstEvaluator(ListenerBinding);\n  });\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  public _scope?: Scope;\n\n  /** @internal */\n  private readonly _options: ListenerBindingOptions;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  /**\n   * Whether this binding only handles events originate from the target this binding is bound to\n   */\n  public self: boolean = false;\n\n  /**\n   * Indicates if this binding evaluates an ast and get a function, that function should be bound\n   * to the instance it is on\n   *\n   * @internal\n   */\n  public readonly boundFn = true;\n\n  /** @internal */\n  private readonly _modifiedEventHandler: IModifiedEventHandler | null = null;\n\n  public constructor(\n    locator: IServiceLocator,\n    public ast: IsBindingBehavior,\n    public target: Node,\n    public targetEvent: string,\n    options: ListenerBindingOptions,\n    modifiedEventHandler: IModifiedEventHandler | null,\n    public strict: boolean,\n  ) {\n    this.l = locator;\n    this._options = options;\n    this._modifiedEventHandler = modifiedEventHandler;\n  }\n\n  public callSource(event: Event): void {\n    const overrideContext = this._scope!.overrideContext;\n    overrideContext.$event = event;\n\n    let result = astEvaluate(this.ast, this._scope!, this, null);\n\n    delete overrideContext.$event;\n\n    if (isFunction(result)) {\n      result = result(event);\n    }\n\n    if (result !== true && this._options.prevent) {\n      event.preventDefault();\n    }\n  }\n\n  public handleEvent(event: Event): void {\n    if (this.self) {\n      if (this.target !== event.composedPath()[0]) {\n      /* istanbul ignore next */\n        return;\n      }\n    }\n    if (this._modifiedEventHandler?.(event) !== false) {\n      try {\n        this.callSource(event);\n      } catch (ex) {\n        this._options.onError(event, ex);\n      }\n    }\n  }\n\n  public bind(scope: Scope): void {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    this.target.addEventListener(this.targetEvent, this, this._options);\n\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n\n    astUnbind(this.ast, this._scope!, this);\n\n    this._scope = void 0;\n    this.target.removeEventListener(this.targetEvent, this, this._options);\n  }\n}\n\nexport type IModifiedEventHandler = (event: Event) => boolean;\n\nexport interface IModifiedEventHandlerCreator {\n  readonly type: string | string[];\n  getHandler(modifier: string): IModifiedEventHandler;\n}\nexport const IModifiedEventHandlerCreator = /*@__PURE__*/createInterface<IModifiedEventHandlerCreator>('IEventModifier');\n\nexport interface IKeyMapping {\n  readonly meta: string[];\n  readonly keys: Record</* modifier */string, /* key */ string>;\n}\nexport const IKeyMapping = /*@__PURE__*/createInterface<IKeyMapping>('IKeyMapping', x => x.instance({\n  meta: objectFreeze(['ctrl', 'alt', 'shift', 'meta']) as string[],\n  keys: {\n    escape: 'Escape',\n    enter: 'Enter',\n    space: 'Space',\n    tab: 'tab',\n    // by default, maps the key a-z and A-Z to their respective keycodes\n    ...Array.from({ length: 25 }).reduce((acc: Record<string, string>, _, idx) => {\n      // map keycode of upper case character from A-Z\n      let char = String.fromCharCode(idx + 65);\n      acc[idx + 65] = char;\n\n      // map keycode and character code of lower case character from a-z\n      char = String.fromCharCode(idx + 97);\n      acc[idx + 97] = acc[char] = char;\n      return acc;\n    }, {})\n  },\n}));\n\nclass ModifiedMouseEventHandler implements IModifiedEventHandlerCreator {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedMouseEventHandler));\n  }\n\n  public readonly type = ['click', 'mousedown', 'mousemove', 'mouseup', 'dblclick', 'contextmenu'];\n  /** @internal */\n  private readonly _mapping = resolve(IKeyMapping);\n  /** @internal */\n  private readonly _mouseButtons = ['left', 'middle', 'right'];\n\n  public getHandler(modifier: string): IModifiedEventHandler {\n    const modifiers = modifier.split(/[:+.]/);\n    if (__DEV__) {\n      // verify modifiers and add warnings if necessary\n    }\n    return ((event: MouseEvent) => {\n      let prevent = false;\n      let stop = false;\n      let m: string;\n\n      for (m of modifiers) {\n        switch (m) {\n          case 'prevent': prevent = true; continue;\n          case 'stop': stop = true; continue;\n          case 'left':\n          case 'middle':\n          case 'right':\n            if (event.button !== this._mouseButtons.indexOf(m)) return false;\n            continue;\n        }\n        if (this._mapping.meta.includes(m) && event[`${m}Key` as keyof MouseEvent] !== true) {\n          return false;\n        }\n\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`Modifier '${m}' is not supported for mouse events.`);\n        }\n      }\n\n      if (prevent) event.preventDefault();\n      if (stop) event.stopPropagation();\n\n      return true;\n    }) as IModifiedEventHandler;\n  }\n}\n\nclass ModifiedKeyboardEventHandler implements IModifiedEventHandlerCreator {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedKeyboardEventHandler));\n  }\n\n  /** @internal */\n  private readonly _mapping = resolve(IKeyMapping);\n  public readonly type = ['keydown', 'keyup'];\n  public getHandler(modifier: string): IModifiedEventHandler {\n    const modifiers = modifier.split(/[:+.]/);\n    return ((event: KeyboardEvent) => {\n      let prevent = false;\n      let stop = false;\n      let mod: string;\n\n      for (mod of modifiers) {\n        switch (mod) {\n          case 'prevent': prevent = true; continue;\n          case 'stop': stop = true; continue;\n        }\n        if (this._mapping.meta.includes(mod)) {\n          if (event[`${mod}Key` as keyof KeyboardEvent] !== true) {\n            return false;\n          }\n          continue;\n        }\n\n        const mappedKey = this._mapping.keys[mod];\n        if (mappedKey !== event.key) {\n          return false;\n        }\n\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`Modifier '${mod}' is not supported for keyboard event with key \"${event.key}\".`);\n        }\n      }\n\n      if (prevent) event.preventDefault();\n      if (stop) event.stopPropagation();\n\n      return true;\n    }) as IModifiedEventHandler;\n  }\n}\n\n/**\n * A generic event handler that can be used for any event type\n */\nclass ModifiedEventHandler implements IModifiedEventHandlerCreator {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedEventHandler));\n  }\n\n  public readonly type = ['$ALL'];\n  public getHandler(modifier: string): IModifiedEventHandler {\n    const modifiers = modifier.split(/[:+.]/);\n    return ((event: Event) => {\n      let prevent = false;\n      let stop = false;\n      let mod: string;\n\n      for (mod of modifiers) {\n        switch (mod) {\n          case 'prevent': prevent = true; continue;\n          case 'stop': stop = true; continue;\n        }\n\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`Modifier '${mod}' is not supported for event \"${event.type}\".`);\n        }\n      }\n\n      if (prevent) event.preventDefault();\n      if (stop) event.stopPropagation();\n\n      return true;\n    }) as IModifiedEventHandler;\n  }\n}\n\nexport interface IEventModifier {\n  getHandler(type: string, modifier: string | null): IModifiedEventHandler | null;\n}\nexport const IEventModifier = /*@__PURE__*/createInterface<IEventModifier>('IEventModifierHandler', x => x.instance({\n  getHandler: () => {\n    if (__DEV__) {\n      // eslint-disable-next-line no-console\n      console.warn('No event modifier handler registered');\n    }\n    /* istanbul ignore next */\n    return null;\n  }\n}));\n\nexport class EventModifier implements IEventModifier {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IEventModifier, EventModifier));\n  }\n  /** @internal */\n  private readonly _reg = resolve(all(IModifiedEventHandlerCreator))\n    .reduce((acc: Record<string, IModifiedEventHandlerCreator>, cur) => {\n      const types = isArray(cur.type) ? cur.type : [cur.type];\n      types.forEach(t => acc[t] = cur);\n      return acc;\n    }, {});\n\n  public getHandler(type: string, modifier: string | null): IModifiedEventHandler | null {\n    return isString(modifier) ? (this._reg[type] ?? this._reg.$ALL)?.getHandler(modifier) ?? null : null;\n  }\n}\n\nexport const EventModifierRegistration = {\n  register(c: IContainer) {\n    c.register(\n      EventModifier,\n      ModifiedMouseEventHandler,\n      ModifiedKeyboardEventHandler,\n      ModifiedEventHandler,\n    );\n  }\n};\n", "import { isString, type IContainer } from '@aurelia/kernel';\nimport { CustomElementDefinition } from '../resources/custom-element';\nimport { createInterface } from '../utilities-di';\nimport { Controller } from './controller';\n\nimport type { ICustomAttributeController, ICustomElementController, ISyntheticView } from './controller';\n\nexport interface IViewFactory {\n  name: string;\n  readonly container: IContainer;\n  def: CustomElementDefinition;\n  isCaching: boolean;\n\n  setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void;\n\n  canReturnToCache(_controller: ISyntheticView): boolean;\n\n  tryReturnToCache(controller: ISyntheticView): boolean;\n\n  create(parentController?: ISyntheticView | ICustomElementController | ICustomAttributeController | undefined): ISyntheticView;\n}\nexport const IViewFactory = /*@__PURE__*/createInterface<IViewFactory>('IViewFactory');\n\nexport class ViewFactory implements IViewFactory {\n  public static maxCacheSize: number = 0xFFFF;\n\n  public name: string;\n  public readonly container: IContainer;\n  public def: CustomElementDefinition;\n  public isCaching: boolean = false;\n\n  /** @internal */\n  private _cache: ISyntheticView[] = null!;\n  /** @internal */\n  private _cacheSize: number = -1;\n\n  public constructor(\n    container: IContainer,\n    def: CustomElementDefinition,\n  ) {\n    this.name = def.name;\n    this.container = container;\n    this.def = def;\n  }\n\n  public setCacheSize(size: number | '*', doNotOverrideIfAlreadySet: boolean): void {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (size) {\n      if (size === '*') {\n        size = ViewFactory.maxCacheSize;\n      } else if (isString(size)) {\n        size = parseInt(size, 10);\n      }\n\n      if (this._cacheSize === -1 || !doNotOverrideIfAlreadySet) {\n        this._cacheSize = size;\n      }\n    }\n\n    if (this._cacheSize > 0) {\n      this._cache = [];\n    } else {\n      this._cache = null!;\n    }\n\n    this.isCaching = this._cacheSize > 0;\n  }\n\n  public canReturnToCache(_controller: ISyntheticView): boolean {\n    return this._cache != null && this._cache.length < this._cacheSize;\n  }\n\n  public tryReturnToCache(controller: ISyntheticView): boolean {\n    if (this.canReturnToCache(controller)) {\n      this._cache.push(controller);\n      return true;\n    }\n\n    return false;\n  }\n\n  public create(\n    parentController?: ISyntheticView | ICustomElementController | ICustomAttributeController | undefined,\n  ): ISyntheticView {\n    const cache = this._cache;\n    let controller: ISyntheticView;\n\n    if (cache != null && cache.length > 0) {\n      controller = cache.pop()!;\n      return controller;\n    }\n\n    controller = Controller.$view(this, parentController);\n    return controller;\n  }\n}\n", "import { type IRenderLocation } from './dom';\nimport { type IPlatform } from './platform';\n\n/** @internal */\nexport const createLocation = /*@__PURE__*/ (() => {\n  const createComment = (p: IPlatform, text: string) => p.document.createComment(text);\n  return (p: IPlatform) => {\n    const locationEnd = createComment(p, 'au-end') as IRenderLocation;\n    locationEnd.$start = createComment(p, 'au-start') as IRenderLocation;\n\n    return locationEnd;\n  };\n})();\n\n/** @internal */\nexport const insertManyBefore = (parent: Node | null, target: Node | null, newChildNodes: ArrayLike<Node>) => {\n  if (parent === null) {\n    return;\n  }\n  const ii = newChildNodes.length;\n  let i = 0;\n  while (ii > i) {\n    parent.insertBefore(newChildNodes[i], target);\n    ++i;\n  }\n};\n\n/** @internal */\nexport const createMutationObserver = (node: Node, callback: MutationCallback) => new node.ownerDocument!.defaultView!.MutationObserver(callback);\n\n/** @internal */\nexport const isElement = (node: Node): node is Element => node.nodeType === 1;\n", "import { emptyArray, type IContainer, type IIndexable, type IServiceLocator, type Key } from '@aurelia/kernel';\nimport { subscriberCollection, type ISubscribable, type ISubscriberCollection } from '@aurelia/runtime';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { PartialCustomElementDefinition } from '../resources/custom-element';\nimport { def, objectAssign, safeString } from '../utilities';\nimport { createInterface, instanceRegistration } from '../utilities-di';\nimport { isElement } from '../utilities-dom';\nimport { type ICustomElementController, type ICustomElementViewModel } from './controller';\nimport { ILifecycleHooks, lifecycleHooks } from './lifecycle-hooks';\n\nimport { getAnnotationKeyFor } from '../utilities-metadata';\n\n/** @internal */\nexport const defaultSlotName = 'default';\n/** @internal */\nexport const auslotAttr = 'au-slot';\n\nexport type PartialSlottedDefinition = {\n  callback?: PropertyKey;\n  slotName?: string;\n  query?: string;\n  // options?: MutationObserverInit;\n  // query?: (controller: ICustomElementController) => ArrayLike<Node>;\n  // filter?: (node: Node, controller?: ICustomElementController | null, viewModel?: ICustomElementViewModel) => boolean;\n  // map?: (node: Node, controller?: ICustomElementController | null, viewModel?: ICustomElementViewModel) => unknown;\n};\n\nexport type IAuSlotProjections = Record<string, PartialCustomElementDefinition>;\n\nexport interface IAuSlotsInfo {\n  /**\n   * Name of the slots to which content are projected.\n   */\n  readonly projectedSlots: readonly string[];\n}\n/**\n * Describing the projection information statically available for a custom element\n */\nexport const IAuSlotsInfo = /*@__PURE__*/createInterface<IAuSlotsInfo>('IAuSlotsInfo');\nexport class AuSlotsInfo implements IAuSlotsInfo {\n  public constructor(\n    public readonly projectedSlots: string[],\n  ) { }\n}\n\n/**\n * Describe the interface of a slot\n */\nexport interface IAuSlot {\n  readonly name: string;\n  readonly nodes: readonly Node[];\n  /** Add subscriber to the change listener list of this slot */\n  subscribe(subscriber: IAuSlotSubscriber): void;\n  /** Remove subscriber from the change listener list of this slot */\n  unsubscribe(subscriber: IAuSlotSubscriber): void;\n}\n\nexport interface IAuSlotSubscriber {\n  handleSlotChange(slot: IAuSlot, nodes: Node[]): void;\n}\n\n/**\n * Describes the interface of a <au-slot> watcher\n */\nexport interface IAuSlotWatcher extends ISubscribable {\n  // this may be an issue in the future where there's a desire\n  // for a watcher to selectively watch multiple slot at once\n  // at the moment, it's all (*) or one (name)\n  readonly slotName: string;\n  watch(slot: IAuSlot): void;\n  unwatch(slot: IAuSlot): void;\n}\nexport const IAuSlotWatcher = /*@__PURE__*/createInterface<IAuSlotWatcher>('IAuSlotWatcher');\n\n// 1. on hydrating, create a slot watcher (binding) & register with hydration context\n// 2. on slot with projection created, optionally retrieve the slot watcher\n//  2.a if there's NOT a watcher, do nothing\n//  2.b else register the slot\n\n// 1. au-slot should start listening to mutation when attaching\n// 2. au-slot should stop listening to mutation when detaching\n// 3. au-slot should notify slot watcher on mutation\n\ninterface AuSlotWatcherBinding extends ISubscriberCollection {}\nclass AuSlotWatcherBinding implements IAuSlotWatcher, IAuSlotSubscriber, ISubscriberCollection {\n  /** @internal */\n  private readonly _obj: ICustomElementViewModel;\n  /** @internal */\n  private readonly _callback: (nodes: readonly Node[]) => void;\n\n  public readonly slotName: string;\n  /** @internal */\n  private readonly _query: string;\n  /** @internal */\n  private readonly _slots = new Set<IAuSlot>();\n\n  /** @internal */\n  private _nodes: Node[] = emptyArray;\n\n  public isBound: boolean = false;\n\n  public constructor(\n    obj: ICustomElementViewModel,\n    callback: PropertyKey,\n    slotName: string,\n    query: string,\n  ) {\n    this._callback = (this._obj = obj as IIndexable)[callback] as typeof AuSlotWatcherBinding.prototype._callback;\n    this.slotName = slotName;\n    this._query = query;\n  }\n\n  public bind() {\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    this.isBound = false;\n  }\n\n  public getValue() {\n    return this._nodes;\n  }\n\n  public watch(slot: IAuSlot): void {\n    if (!this._slots.has(slot)) {\n      this._slots.add(slot);\n      slot.subscribe(this);\n    }\n  }\n\n  public unwatch(slot: IAuSlot): void {\n    if (this._slots.delete(slot)) {\n      slot.unsubscribe(this);\n    }\n  }\n\n  public handleSlotChange(slot: IAuSlot, nodes: Node[]): void {\n    if (!this.isBound) {\n      return;\n    }\n    const oldNodes = this._nodes;\n    const $nodes: Node[] = [];\n    const query = this._query;\n    let $slot: IAuSlot;\n    let node: Node;\n    for ($slot of this._slots) {\n      for (node of $slot === slot ? nodes : $slot.nodes) {\n        if (query === '$all' || (isElement(node) && (query === '*' || node.matches(query)))) {\n          $nodes[$nodes.length] = node;\n        }\n      }\n    }\n    if ($nodes.length !== oldNodes.length || $nodes.some((n, i) => n !== oldNodes[i])) {\n      this._nodes = $nodes;\n      this._callback?.call(this._obj, $nodes);\n      this.subs.notify($nodes, oldNodes);\n    }\n  }\n\n  /* istanbul ignore next */\n  public get(): ReturnType<IServiceLocator['get']> {\n    throw createMappedError(ErrorNames.method_not_implemented, 'get');\n  }\n}\n\ntype SlottedPropDefinition = PartialSlottedDefinition & { name: PropertyKey };\nclass SlottedLifecycleHooks {\n  public constructor(\n    private readonly _def: SlottedPropDefinition,\n  ) {}\n\n  public register(c: IContainer) {\n    instanceRegistration(ILifecycleHooks, this).register(c);\n  }\n\n  public hydrating(vm: object, controller: ICustomElementController) {\n    const $def = this._def;\n    const watcher = new AuSlotWatcherBinding(\n      vm,\n      $def.callback ?? `${safeString($def.name)}Changed`,\n      $def.slotName ?? 'default',\n      $def.query ?? '*'\n    );\n    def(vm, $def.name, {\n      enumerable: true,\n      configurable: true,\n      get: objectAssign((/* SlotWatcherBinding */) => watcher.getValue(), { getObserver: () => watcher }),\n      set: (/* SlotWatcherBinding */) => {/* nothing */}\n    });\n\n    instanceRegistration(IAuSlotWatcher, watcher).register(controller.container);\n    controller.addBinding(watcher);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Tc39PropertyDecorator = (target: undefined, context: ClassFieldDecoratorContext) => (initialValue: any) => any;\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n */\nexport function slotted(): Tc39PropertyDecorator;\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n *\n * @param query - the query select used to match each slotted node of the corresponding <au-slot>\n * If * is provided, then it'll get all nodes (including text nodes)\n */\nexport function slotted(query: string): Tc39PropertyDecorator;\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n *\n * @param query - the query select used to match each slotted node of the corresponding <au-slot>\n * If * is provided, then it'll get all nodes (including text nodes)\n * @param slotName - the name of the <au-slot> this slotted decorator is targeting.\n * If * is provided, then it'll get all nodes from all <au-slot>\n */\nexport function slotted(query: string, slotName: string): Tc39PropertyDecorator;\n\n/**\n * Decorate a property of a class to get updates from the projection of the decorated custom element\n *\n * @param def - The configuration of the slotted decorator.\n */\nexport function slotted(def: PartialSlottedDefinition): Tc39PropertyDecorator;\nexport function slotted(queryOrDef?: string | PartialSlottedDefinition, slotName?: string): Tc39PropertyDecorator;\nexport function slotted(queryOrDef?: string | PartialSlottedDefinition, slotName?: string) {\n  if (!mixed) {\n    mixed = true;\n    subscriberCollection(AuSlotWatcherBinding, null!);\n    lifecycleHooks()(SlottedLifecycleHooks, null!);\n  }\n  const dependenciesKey = getAnnotationKeyFor('dependencies');\n\n  // function decorator($target: {}, $prop: symbol | string, desc?: PropertyDecorator): void {\n  function decorator(_: undefined, context: ClassFieldDecoratorContext): void {\n    if (context.kind !== 'field') throw createMappedError(ErrorNames.slotted_decorator_invalid_usage);\n\n    const config = (typeof queryOrDef === 'object'\n      ? queryOrDef\n      : {\n        query: queryOrDef,\n        slotName,\n        name: ''\n      }) as SlottedPropDefinition;\n    config.name = context.name;\n\n    const dependencies = (context.metadata[dependenciesKey] ??= []) as Key[];\n    dependencies.push(new SlottedLifecycleHooks(config));\n  }\n\n  return decorator;\n}\n\n/* eslint-disable */\nfunction testDecorator() {\n  class Abc {\n    @slotted() abc: any;\n    @slotted('div') a2: any;\n    @slotted('div', 'slot1') a3: any;\n    @slotted({\n      slotName: 'slot1'\n    })\n    a4: any;\n  }\n}\n\nlet mixed = false;\n", "import { AccessScopeExpression, IExpressionParser, type IsBindingBehavior } from '@aurelia/expression-parser';\nimport { isObject, type IServiceLocator, type Key, emptyArray } from '@aurelia/kernel';\nimport {\n  type IObserverLocator,\n  type IObserverLocatorBasedConnectable,\n  connectable,\n  Scope,\n  type IAstEvaluator,\n  astBind,\n  astEvaluate,\n  astUnbind,\n} from '@aurelia/runtime';\nimport { BindingMode, IInstruction, ITemplateCompiler, InstructionType, SpreadElementPropBindingInstruction } from '@aurelia/template-compiler';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { IPlatform } from '../platform';\nimport { IHasController, } from '../renderer';\nimport { CustomElementDefinition, findElementControllerFor } from '../resources/custom-element';\nimport { IController, ICustomElementController, IHydratableController, IHydrationContext, vmkCa } from '../templating/controller';\nimport { IRendering } from '../templating/rendering';\nimport { createPrototypeMixer, mixinAstEvaluator, mixinUseScope, mixingBindingLimited } from './binding-utils';\nimport { IBinding, IBindingController } from './interfaces-bindings';\nimport { PropertyBinding } from './property-binding';\n\n/**\n * The public methods of this binding emulates the necessary of an IHydratableController,\n * which mainly is the addBinding method since a spread binding\n * is a surrogate of other bindings created from the captured attrs\n */\nexport class SpreadBinding implements IBinding, IHasController {\n\n  /**\n   * Create a list of SpreadBinding by searching for captured attributes in HydrationContexts\n   * from a container\n   */\n  public static create(\n    hydrationContext: IHydrationContext,\n    target: HTMLElement,\n    /**\n     * To be supplied to the compilation of spread' attrs\n     * Sometimes in dynamic compilation scenario, this could be used to influence\n     * what attributes can be compiled into (i.e bindable vs normal)\n     */\n    targetDef: CustomElementDefinition | undefined,\n    rendering: IRendering,\n    compiler: ITemplateCompiler,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): SpreadBinding[] {\n    const bindings: SpreadBinding[] = [];\n    const renderers = rendering.renderers;\n    const getHydrationContext = (ancestor: number) => {\n      let currentLevel = ancestor;\n      let currentContext: IHydrationContext | undefined = hydrationContext;\n      while (currentContext != null && currentLevel > 0) {\n        currentContext = currentContext.parent;\n        --currentLevel;\n      }\n      if (currentContext == null) {\n        throw createMappedError(ErrorNames.no_spread_scope_context_found);\n      }\n      return currentContext as IHydrationContext<object>;\n    };\n    const renderSpreadInstruction = (ancestor: number) => {\n      const context = getHydrationContext(ancestor);\n      const spreadBinding = new SpreadBinding(context) as SpreadBinding & IHydratableController;\n      const instructions = compiler.compileSpread(\n        context.controller.definition,\n        context.instruction?.captures ?? emptyArray,\n        context.controller.container,\n        target,\n        targetDef\n      );\n      let inst: IInstruction;\n      for (inst of instructions) {\n        switch (inst.type) {\n          case InstructionType.spreadTransferedBinding:\n            renderSpreadInstruction(ancestor + 1);\n            break;\n          case InstructionType.spreadElementProp:\n            renderers[(inst as SpreadElementPropBindingInstruction).instruction.type].render(\n              spreadBinding,\n              findElementControllerFor(target),\n              (inst as SpreadElementPropBindingInstruction).instruction,\n              platform,\n              exprParser,\n              observerLocator,\n            );\n            break;\n          default:\n            renderers[inst.type].render(spreadBinding, target, inst, platform, exprParser, observerLocator);\n        }\n      }\n      bindings.push(spreadBinding);\n    };\n    renderSpreadInstruction(0);\n    return bindings;\n  }\n\n  public scope?: Scope | undefined;\n  public isBound: boolean = false;\n  public readonly locator: IServiceLocator;\n\n  public readonly $controller: ICustomElementController;\n\n  public get container() {\n    return this.locator;\n  }\n\n  public get definition(): CustomElementDefinition {\n    return this.$controller.definition;\n  }\n\n  public get state() {\n    return this.$controller.state;\n  }\n\n  /** @internal */ private readonly _innerBindings: IBinding[] = [];\n  /** @internal */ private readonly _hydrationContext: IHydrationContext<object>;\n\n  public constructor(\n    hydrationContext: IHydrationContext<object>,\n  ) {\n    this.locator = (this.$controller = (this._hydrationContext = hydrationContext).controller).container;\n  }\n\n  public get(key: Key) {\n    return this.locator.get(key);\n  }\n\n  public bind(_scope: Scope): void {\n    if (this.isBound) return;\n    this.isBound = true;\n    const innerScope = this.scope = this._hydrationContext.controller.scope.parent ?? void 0;\n    if (innerScope == null) {\n      throw createMappedError(ErrorNames.no_spread_scope_context_found);\n    }\n\n    this._innerBindings.forEach(b => b.bind(innerScope));\n  }\n\n  public unbind(): void {\n    this._innerBindings.forEach(b => b.unbind());\n    this.isBound = false;\n  }\n\n  public addBinding(binding: IBinding) {\n    this._innerBindings.push(binding);\n  }\n\n  public addChild(controller: IController) {\n    if (controller.vmKind !== vmkCa) {\n      throw createMappedError(ErrorNames.no_spread_template_controller);\n    }\n    this.$controller.addChild(controller);\n  }\n}\n\nexport interface SpreadValueBinding extends IAstEvaluator, IServiceLocator, IObserverLocatorBasedConnectable {}\nexport class SpreadValueBinding implements IBinding {\n  /** @internal */\n  public static mix = /*@__PURE__*/ createPrototypeMixer(() => {\n    mixinUseScope(SpreadValueBinding);\n    mixingBindingLimited(SpreadValueBinding, () => 'updateTarget');\n    connectable(SpreadValueBinding, null!);\n    mixinAstEvaluator(SpreadValueBinding);\n  });\n\n  /** @internal */\n  private static readonly _astCache: Record<string, AccessScopeExpression> = {};\n\n  public isBound = false;\n\n  /** @internal */\n  public _scope?: Scope = void 0;\n\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  public l: IServiceLocator;\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  /** @internal */\n  private readonly _controller: IBindingController;\n\n  /** @internal */\n  private readonly _bindingCache: Record<PropertyKey, PropertyBinding> = {};\n  // not a static weakmap because we want to clear the cache when the binding is disposed\n  // also different binding at different logic with the same object shouldn't be sharing the same override context\n  /** @internal */\n  private readonly _scopeCache = new WeakMap<object, Scope>();\n\n  public constructor(\n    controller: IBindingController,\n    public target: object,\n    public targetKeys: string[],\n    public ast: IsBindingBehavior,\n    ol: IObserverLocator,\n    l: IServiceLocator,\n    public strict: boolean,\n  ) {\n    this._controller = controller;\n    this.oL = ol;\n    this.l = l;\n  }\n\n  public updateTarget(): void {\n    this.obs.version++;\n    const newValue = astEvaluate(\n      this.ast,\n      this._scope!,\n      this,\n      this\n    );\n    this.obs.clear();\n\n    this._createBindings(newValue as Record<PropertyKey, unknown> | null, true);\n  }\n\n  public handleChange(): void {\n    if (!this.isBound) return;\n    this.updateTarget();\n  }\n\n  public handleCollectionChange(): void {\n    if (!this.isBound) return;\n    this.updateTarget();\n  }\n\n  public bind(scope: Scope) {\n    if (this.isBound) {\n      if (this._scope === scope) return;\n      this.unbind();\n    }\n    this.isBound = true;\n    this._scope = scope;\n\n    astBind(this.ast, scope, this);\n\n    const value = astEvaluate(this.ast, scope, this, this);\n\n    this._createBindings(value as Record<string, unknown> | null, false);\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n    astUnbind(this.ast, this._scope!, this);\n    this._scope = void 0;\n    let key: string;\n    // can also try to keep track of what the active bindings are\n    // but we know in our impl, all unbind are idempotent\n    // so just be simple and unbind all\n    for (key in this._bindingCache) {\n      this._bindingCache[key].unbind();\n    }\n  }\n\n  /**\n   * @internal\n   */\n  private _createBindings(value: Record<string, unknown> | null, unbind: boolean) {\n    let key: string;\n    if (!isObject(value)) {\n      /* istanbul ignore if */\n      if (__DEV__) {\n        // eslint-disable-next-line no-console\n        console.warn(`[DEV:aurelia] $bindable spread is given a non object for properties: \"${this.targetKeys.join(', ')}\" of ${this.target.constructor.name}`);\n      }\n      for (key in this._bindingCache) {\n        this._bindingCache[key]?.unbind();\n      }\n      return;\n    }\n\n    let binding: PropertyBinding;\n    // use a cache as we don't wanna cause bindings to \"move\" (bind/unbind)\n    // whenever there's a new evaluation\n    let scope = this._scopeCache.get(value);\n    if (scope == null) {\n      this._scopeCache.set(value, scope = Scope.fromParent(this._scope!, value));\n    }\n    for (key of this.targetKeys) {\n      binding = this._bindingCache[key];\n      if (key in value) {\n        if (binding == null) {\n          binding = this._bindingCache[key] = new PropertyBinding(\n            this._controller,\n            this.l,\n            this.oL,\n            SpreadValueBinding._astCache[key] ??= new AccessScopeExpression(key, 0),\n            this.target,\n            key,\n            BindingMode.toView,\n            this.strict,\n          );\n        }\n        binding.bind(scope);\n      } else if (unbind) {\n        binding?.unbind();\n      }\n    }\n  }\n}\n", "import { Constructable, noop } from '@aurelia/kernel';\nimport type { ISubscriber, ISubscriberCollection } from '@aurelia/runtime';\nimport type { INode } from '../dom.node';\nimport { defineHiddenProp } from '../utilities';\nimport type { INodeObserver, INodeObserverConfigBase } from './observer-locator';\n\nconst addListener = (target: EventTarget, name: string, handler: EventListenerOrEventListenerObject, options?: AddEventListenerOptions) => {\n  target.addEventListener(name, handler, options);\n};\n\nconst removeListener = (target: EventTarget, name: string, handler: EventListenerOrEventListenerObject, options?: AddEventListenerOptions) => {\n  target.removeEventListener(name, handler, options);\n};\n\n/** @internal */\nexport const mixinNodeObserverUseConfig =\n  <T extends INodeObserver & EventListenerObject & ISubscriberCollection & { _el: INode; _config: INodeObserverConfigBase; _listened: boolean; _start(): void; _stop?(): void }>(target: Constructable<T>) => {\n    let event: string;\n    const prototype = target.prototype;\n    defineHiddenProp(prototype, 'subscribe', function (this: T, subscriber: ISubscriber) {\n      if (this.subs.add(subscriber) && this.subs.count === 1) {\n        for (event of this._config.events) {\n          addListener(this._el, event, this);\n        }\n        this._listened = true;\n        this._start?.();\n      }\n    });\n    defineHiddenProp(prototype, 'unsubscribe', function (this: T, subscriber: ISubscriber) {\n        if (this.subs.remove(subscriber) && this.subs.count === 0) {\n          for (event of this._config.events) {\n            removeListener(this._el, event, this);\n          }\n          this._listened = false;\n          this._stop?.();\n        }\n    });\n    defineHiddenProp(prototype, 'useConfig', function (this: T, config: INodeObserverConfigBase): void {\n      this._config = config;\n      if (this._listened) {\n        for (event of this._config.events) {\n          removeListener(this._el, event, this);\n        }\n        for (event of this._config.events) {\n          addListener(this._el, event, this);\n        }\n      }\n    });\n};\n\n/** @internal */\nexport const mixinNoopSubscribable = (target: Constructable) => {\n  defineHiddenProp(target.prototype, 'subscribe', noop);\n  defineHiddenProp(target.prototype, 'unsubscribe', noop);\n};\n", "import { emptyArray, isArray, isString } from '@aurelia/kernel';\nimport { atLayout, atNode } from '../utilities';\n\nimport type { AccessorType, IAccessor, IObserver } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\n\nexport interface ClassAttributeAccessor extends IObserver {}\nexport class ClassAttributeAccessor implements IAccessor {\n  static {\n    mixinNoopSubscribable(ClassAttributeAccessor);\n  }\n\n  public get doNotCache(): true { return true; }\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = '';\n\n  /** @internal */\n  private readonly _nameIndex: Record<string, number> = {};\n  /** @internal */\n  private _version: number = 0;\n\n  public constructor(\n    public readonly obj: HTMLElement,\n    public readonly mapping: Record<string, string> = {}\n  ) {\n  }\n\n  public getValue(): unknown {\n    return this._value;\n  }\n\n  public setValue(newValue: unknown): void {\n    if (newValue !== this._value) {\n      this._value = newValue;\n      this._flushChanges();\n    }\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    const nameIndex = this._nameIndex;\n    const version = ++this._version;\n    const classList = this.obj.classList;\n    const classesToAdd = getClassesToAdd(this._value as string | Record<string, unknown> | []);\n    const ii = classesToAdd.length;\n    let i = 0;\n    let name: string;\n\n    // Get strings split on a space not including empties\n    if (ii > 0) {\n      for (; i < ii; i++) {\n        name = classesToAdd[i];\n        name = this.mapping[name] || name;\n\n        if (name.length === 0) {\n          continue;\n        }\n        nameIndex[name] = this._version;\n        classList.add(name);\n      }\n    }\n\n    // First call to setValue?  We're done.\n    if (version === 1) {\n      return;\n    }\n\n    for (name in nameIndex) {\n      name = this.mapping[name] || name;\n      if (nameIndex[name] === version) {\n        continue;\n      }\n      // TODO: this has the side-effect that classes already present which are added again,\n      // will be removed if they're not present in the next update.\n      // Better would be do have some configurability for this behavior, allowing the user to\n      // decide whether initial classes always need to be kept, always removed, or something in between\n      classList.remove(name);\n    }\n  }\n}\n\nfunction getClassesToAdd(object: Record<string, unknown> | [] | string): string[] {\n  if (isString(object)) {\n    return splitClassString(object);\n  }\n  if (typeof object !== 'object') {\n    return emptyArray;\n  }\n\n  if (isArray(object)) {\n    const len = object.length;\n    if (len > 0) {\n      const classes: string[] = [];\n      let i = 0;\n      for (; len > i; ++i) {\n        classes.push(...getClassesToAdd(object[i]));\n      }\n      return classes;\n    } else {\n      return emptyArray;\n    }\n  }\n\n  const classes: string[] = [];\n  let property: string;\n  for (property in object) {\n    // Let non typical values also evaluate true so disable bool check\n    // eslint-disable-next-line no-extra-boolean-cast\n    if (Boolean(object[property])) {\n      // We must do this in case object property has a space in the name which results in two classes\n      if (property.includes(' ')) {\n        classes.push(...splitClassString(property));\n      } else {\n        classes.push(property);\n      }\n    }\n  }\n  return classes;\n}\n\nfunction splitClassString(classString: string): string[] {\n  const matches = classString.match(/\\S+/g);\n  if (matches === null) {\n    return emptyArray;\n  }\n  return matches;\n}\n", "import { Key, IResolver, own } from '@aurelia/kernel';\nimport { IHydrationContext } from '../templating/controller';\n\n/**\n * Create a resolver for a given key that will only resolve from the nearest hydration context.\n *\n * @internal\n */\nexport const fromHydrationContext = <T extends Key>(key: T): IResolver<T | undefined> => ({\n  $isResolver: true,\n  resolve(_, requestor) {\n    return requestor.get(IHydrationContext).controller.container.get(own(key));\n  }\n});\n", "import {\n  emptyArray,\n  InstanceProvider,\n  type IContainer,\n  type Constructable,\n  type IResolver,\n  resolve,\n  isString,\n  registrableMetadataKey,\n} from '@aurelia/kernel';\nimport {\n  IExpressionParser,\n  type ExpressionType,\n  type AnyBindingExpression,\n} from '@aurelia/expression-parser';\nimport {\n  IObserverLocator,\n  type IObservable,\n} from '@aurelia/runtime';\nimport { toView } from './binding/interfaces-bindings';\nimport { AttributeBinding } from './binding/attribute-binding';\nimport { InterpolationBinding, InterpolationPartBinding } from './binding/interpolation-binding';\nimport { ContentBinding } from \"./binding/content-binding\";\nimport { LetBinding } from './binding/let-binding';\nimport { PropertyBinding } from './binding/property-binding';\nimport { RefBinding } from './binding/ref-binding';\nimport { IEventModifier, ListenerBinding, ListenerBindingOptions } from './binding/listener-binding';\nimport { CustomElement, CustomElementDefinition, findElementControllerFor } from './resources/custom-element';\nimport { CustomAttribute, CustomAttributeDefinition, findAttributeControllerFor } from './resources/custom-attribute';\nimport { convertToRenderLocation, IRenderLocation, ICssClassMapping, registerHostNode } from './dom';\nimport { INode, refs } from './dom.node';\nimport { Controller, ICustomElementController, ICustomElementViewModel, IController, ICustomAttributeViewModel, IHydrationContext } from './templating/controller';\nimport { IPlatform } from './platform';\nimport { IViewFactory } from './templating/view';\nimport { IRendering } from './templating/rendering';\nimport { objectKeys, etIsProperty, etInterpolation, etIsIterator, etIsFunction } from './utilities';\nimport { createInterface, registerResolver, singletonRegistration } from './utilities-di';\nimport { IAuSlotsInfo, AuSlotsInfo } from './templating/controller.projection';\n\nimport type { IHydratableController } from './templating/controller';\nimport { ErrorNames, createMappedError } from './errors';\nimport { SpreadBinding, SpreadValueBinding } from './binding/spread-binding';\nimport {\n  AttributeBindingInstruction,\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateLetElementInstruction,\n  HydrateTemplateController,\n  IInstruction,\n  ITemplateCompiler,\n  InstructionType,\n  InterpolationInstruction,\n  IteratorBindingInstruction,\n  LetBindingInstruction,\n  ListenerBindingInstruction,\n  PropertyBindingInstruction,\n  RefBindingInstruction,\n  SetAttributeInstruction,\n  SetClassAttributeInstruction,\n  SetPropertyInstruction,\n  SetStyleAttributeInstruction,\n  SpreadTransferedBindingInstruction,\n  SpreadValueBindingInstruction,\n  StylePropertyBindingInstruction,\n  TextBindingInstruction\n} from '@aurelia/template-compiler';\nimport { ClassAttributeAccessor } from './observation/class-attribute-accessor';\nimport { fromHydrationContext } from './resources/resolvers';\n\n/**\n * An interface describing an instruction renderer\n * its target property will be used to match instruction types dynamically at render time\n */\nexport interface IRenderer {\n  target: string;\n  render(\n    /**\n     * The controller that is current invoking this renderer\n     */\n    renderingCtrl: IHydratableController,\n    target: unknown,\n    instruction: IInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void;\n}\n\nexport const IRenderer = /*@__PURE__*/createInterface<IRenderer>('IRenderer');\n\nexport function renderer<T extends IRenderer, C extends Constructable<T>>(target: C, context: ClassDecoratorContext): C {\n  const metadata = context?.metadata ?? (target[Symbol.metadata] ??= Object.create(null));\n  metadata[registrableMetadataKey] = {\n    register(container: IContainer): void {\n      singletonRegistration(IRenderer, target).register(container);\n    }\n  };\n  return target;\n}\n\nfunction ensureExpression<TFrom>(parser: IExpressionParser, srcOrExpr: TFrom | string, expressionType: ExpressionType): TFrom {\n  if (isString(srcOrExpr)) {\n    return parser.parse(srcOrExpr, expressionType) as TFrom;\n  }\n  return srcOrExpr;\n}\n\nfunction getTarget(potentialTarget: object): object {\n  if ((potentialTarget as { viewModel?: object }).viewModel != null) {\n    return (potentialTarget as { viewModel: object }).viewModel;\n  }\n  return potentialTarget;\n}\n\nfunction getRefTarget(refHost: INode, refTargetName: string): object {\n  if (refTargetName === 'element') {\n    return refHost;\n  }\n  switch (refTargetName) {\n    case 'controller':\n      // this means it supports returning undefined\n      return findElementControllerFor(refHost)!;\n    case 'view':\n      throw createMappedError(ErrorNames.not_supported_view_ref_api);\n    case 'component':\n      // this means it supports returning undefined\n      return findElementControllerFor(refHost)!.viewModel;\n    default: {\n      const caController = findAttributeControllerFor(refHost, refTargetName);\n      if (caController !== void 0) {\n        return caController.viewModel;\n      }\n      const ceController = findElementControllerFor(refHost, { name: refTargetName });\n      if (ceController === void 0) {\n        throw createMappedError(ErrorNames.ref_not_found, refTargetName);\n      }\n      return ceController.viewModel;\n    }\n  }\n}\n\nexport const SetPropertyRenderer = /*@__PURE__*/ renderer(class SetPropertyRenderer implements IRenderer {\n  public readonly target = InstructionType.setProperty;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController,\n    instruction: SetPropertyInstruction,\n  ): void {\n    const obj = getTarget(target) as IObservable;\n    if (obj.$observers?.[instruction.to] !== void 0) {\n      obj.$observers[instruction.to].setValue(instruction.value);\n    } else {\n      obj[instruction.to] = instruction.value;\n    }\n  }\n}, null!);\n\nexport const CustomElementRenderer = /*@__PURE__*/ renderer(class CustomElementRenderer implements IRenderer {\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.hydrateElement;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: HydrateElementInstruction<Record<PropertyKey, unknown>, CustomElementDefinition>,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    /* eslint-disable prefer-const */\n    let def: CustomElementDefinition | null;\n    let component: ICustomElementViewModel;\n    let childCtrl: ICustomElementController;\n    const res = instruction.res;\n    const projections = instruction.projections;\n    const ctxContainer = renderingCtrl.container;\n    switch (typeof res) {\n      case 'string':\n        def = CustomElement.find(ctxContainer, res);\n        if (def == null) {\n          throw createMappedError(ErrorNames.element_res_not_found, instruction, renderingCtrl);\n        }\n        break;\n      // constructor based instruction\n      // will be enabled later if needed.\n      // As both AOT + runtime based can use definition for perf\n      // -----------------\n      // case 'function':\n      //   def = CustomElement.getDefinition(res);\n      //   break;\n      default:\n        def = res;\n    }\n    const containerless = instruction.containerless || def.containerless;\n    const location = containerless ? convertToRenderLocation(target) : null;\n    const container = createElementContainer(\n      /* platform         */platform,\n      /* parentController */renderingCtrl,\n      /* host             */target,\n      /* instruction      */instruction,\n      /* location         */location,\n      /* SlotsInfo      */projections == null ? void 0 : new AuSlotsInfo(objectKeys(projections)),\n    );\n    component = container.invoke(def.Type);\n    childCtrl = Controller.$el(\n      /* own container       */container,\n      /* viewModel           */component,\n      /* host                */target,\n      /* instruction         */instruction,\n      /* definition          */def,\n      /* location            */location\n    );\n\n    const renderers = this._rendering.renderers;\n    const props = instruction.props;\n    const ii = props.length;\n    let i = 0;\n    let propInst: IInstruction;\n    while (ii > i) {\n      propInst = props[i];\n      renderers[propInst.type].render(renderingCtrl, childCtrl, propInst, platform, exprParser, observerLocator);\n      ++i;\n    }\n\n    renderingCtrl.addChild(childCtrl);\n    /* eslint-enable prefer-const */\n  }\n}, null!);\n\nexport const CustomAttributeRenderer = /*@__PURE__*/ renderer(class CustomAttributeRenderer implements IRenderer {\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.hydrateAttribute;\n\n  public render(\n    /**\n     * The cotroller that is currently invoking this renderer\n     */\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    // <CustomAttributeDefinition> as we assume it's always used with the default resources resolver\n    instruction: HydrateAttributeInstruction<CustomAttributeDefinition>,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    /* eslint-disable prefer-const */\n    let ctxContainer = renderingCtrl.container;\n    let def: CustomAttributeDefinition | null;\n    switch (typeof instruction.res) {\n      case 'string':\n        def = CustomAttribute.find(ctxContainer, instruction.res);\n        if (def == null) {\n          throw createMappedError(ErrorNames.attribute_res_not_found, instruction, renderingCtrl);\n        }\n        break;\n      // constructor based instruction\n      // will be enabled later if needed.\n      // As both AOT + runtime based can use definition for perf\n      // -----------------\n      // case 'function':\n      //   def = CustomAttribute.getDefinition(instruction.res);\n      //   break;\n      default:\n        def = instruction.res;\n    }\n    const results = invokeAttribute(\n      /* platform         */platform,\n      /* attr definition  */def,\n      /* parentController */renderingCtrl,\n      /* host             */target,\n      /* instruction      */instruction,\n      /* viewFactory      */void 0,\n      /* location         */void 0,\n    );\n    const childController = Controller.$attr(\n      /* context ct */results.ctn,\n      /* viewModel  */results.vm,\n      /* host       */target,\n      /* definition */def,\n    );\n\n    refs.set(target, def.key, childController);\n\n    const renderers = this._rendering.renderers;\n    const props = instruction.props;\n    const ii = props.length;\n    let i = 0;\n    let propInst: IInstruction;\n    while (ii > i) {\n      propInst = props[i];\n      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);\n      ++i;\n    }\n\n    renderingCtrl.addChild(childController);\n    /* eslint-enable prefer-const */\n  }\n}, null!);\n\nexport const TemplateControllerRenderer = /*@__PURE__*/ renderer(class TemplateControllerRenderer implements IRenderer {\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.hydrateTemplateController;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    // <CustomAttributeDefinition> as we assume it's always used with the default resources resolver\n    instruction: HydrateTemplateController<CustomAttributeDefinition>,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    /* eslint-disable prefer-const */\n    let ctxContainer = renderingCtrl.container;\n    let def: CustomAttributeDefinition | null;\n    switch (typeof instruction.res) {\n      case 'string':\n        def = CustomAttribute.find(ctxContainer, instruction.res);\n        if (def == null) {\n          throw createMappedError(ErrorNames.attribute_tc_res_not_found, instruction, renderingCtrl);\n        }\n        break;\n      // constructor based instruction\n      // will be enabled later if needed.\n      // As both AOT + runtime based can use definition for perf\n      // -----------------\n      // case 'function':\n      //   def = CustomAttribute.getDefinition(instruction.res);\n      //   break;\n      default:\n        def = instruction.res;\n    }\n    // const viewFactory = this._rendering.getViewFactory(\n    //   instruction.def,\n    //   ctxContainer\n    // );\n    const viewFactory = this._rendering.getViewFactory(\n      instruction.def,\n      def.containerStrategy === 'new'\n        ? ctxContainer.createChild({ inheritParentResources: true })\n        : ctxContainer\n    );\n    const renderLocation = convertToRenderLocation(target);\n    const results = invokeAttribute(\n      /* platform         */platform,\n      /* attr definition  */def,\n      /* parentController */renderingCtrl,\n      /* host             */target,\n      /* instruction      */instruction,\n      /* viewFactory      */viewFactory,\n      /* location         */renderLocation,\n    );\n    const childController = Controller.$attr(\n      /* container ct */results.ctn,\n      /* viewModel    */results.vm,\n      /* host         */target,\n      /* definition   */def,\n    );\n\n    refs.set(renderLocation, def.key, childController);\n\n    results.vm.link?.(renderingCtrl, childController, target, instruction);\n\n    const renderers = this._rendering.renderers;\n    const props = instruction.props;\n    const ii = props.length;\n    let i = 0;\n    let propInst: IInstruction;\n    while (ii > i) {\n      propInst = props[i];\n      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);\n      ++i;\n    }\n\n    renderingCtrl.addChild(childController);\n    /* eslint-enable prefer-const */\n  }\n}, null!);\n\nexport const LetElementRenderer = /*@__PURE__*/ renderer(class LetElementRenderer implements IRenderer {\n  public readonly target = InstructionType.hydrateLetElement;\n  public constructor() {\n    LetBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: Node & ChildNode,\n    instruction: HydrateLetElementInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    target.remove();\n    const childInstructions = instruction.instructions;\n    const toBindingContext = instruction.toBindingContext;\n    const container = renderingCtrl.container;\n    const ii = childInstructions.length;\n\n    let childInstruction: LetBindingInstruction;\n    let expr: AnyBindingExpression;\n    let i = 0;\n    while (ii > i) {\n      childInstruction = childInstructions[i];\n      expr = ensureExpression(exprParser, childInstruction.from, etIsProperty);\n      renderingCtrl.addBinding(new LetBinding(\n        container,\n        observerLocator,\n        expr,\n        childInstruction.to,\n        toBindingContext,\n        renderingCtrl.strict ?? false,\n      ));\n      ++i;\n    }\n  }\n}, null!);\n\nexport const RefBindingRenderer = /*@__PURE__*/ renderer(class RefBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.refBinding;\n  public constructor() {\n    RefBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: INode,\n    instruction: RefBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator\n  ): void {\n    renderingCtrl.addBinding(new RefBinding(\n      renderingCtrl.container,\n      observerLocator,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      getRefTarget(target, instruction.to),\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const InterpolationBindingRenderer = /*@__PURE__*/ renderer(class InterpolationBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.interpolation;\n  public constructor() {\n    InterpolationPartBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController | HTMLElement,\n    instruction: InterpolationInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const container = renderingCtrl.container;\n    const binding = new InterpolationBinding(\n      renderingCtrl,\n      container,\n      observerLocator,\n      ensureExpression(exprParser, instruction.from, etInterpolation),\n      getTarget(target),\n      instruction.to,\n      toView,\n      renderingCtrl.strict ?? false,\n    );\n    if (instruction.to === 'class' && (binding.target as Node).nodeType > 0) {\n      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));\n      binding.useAccessor(new ClassAttributeAccessor(binding.target as HTMLElement, cssMapping));\n    }\n    renderingCtrl.addBinding(binding);\n  }\n}, null!);\n\nexport const PropertyBindingRenderer = /*@__PURE__*/ renderer(class PropertyBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.propertyBinding;\n  public constructor() {\n    PropertyBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController,\n    instruction: PropertyBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const container = renderingCtrl.container;\n    const binding = new PropertyBinding(\n      renderingCtrl,\n      container,\n      observerLocator,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      getTarget(target),\n      instruction.to,\n      instruction.mode,\n      renderingCtrl.strict ?? false,\n    );\n    if (instruction.to === 'class' && (binding.target as Node).nodeType > 0) {\n      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));\n      binding.useTargetObserver(new ClassAttributeAccessor(binding.target as HTMLElement, cssMapping));\n    }\n    renderingCtrl.addBinding(binding);\n  }\n}, null!);\n\nexport const IteratorBindingRenderer = /*@__PURE__*/ renderer(class IteratorBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.iteratorBinding;\n  public constructor() {\n    PropertyBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: IController,\n    instruction: IteratorBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    renderingCtrl.addBinding(new PropertyBinding(\n      renderingCtrl,\n      renderingCtrl.container,\n      observerLocator,\n      ensureExpression(exprParser, instruction.forOf, etIsIterator),\n      getTarget(target),\n      instruction.to,\n      toView,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const TextBindingRenderer = /*@__PURE__*/ renderer(class TextBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.textBinding;\n  public constructor() {\n    ContentBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: ChildNode,\n    instruction: TextBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    renderingCtrl.addBinding(new ContentBinding(\n      renderingCtrl,\n      renderingCtrl.container,\n      observerLocator,\n      platform,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      target as Text,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\n/**\n * An interface describing configuration for listener bindings\n */\nexport interface IListenerBindingOptions {\n  /**\n   * Indicate whether listener should by default call preventDefault on all the events\n   */\n  prevent: boolean;\n\n  /**\n   * The error handler for listener bindings, by default, it will dispatch an event `au-event-error` on the window object\n   * and if the event is not prevented, it will throw the errors caught by the listener bindings\n   */\n  onError: (event: Event, error: unknown) => void;\n\n}\nexport const IListenerBindingOptions = createInterface<IListenerBindingOptions>('IListenerBindingOptions', x => x.singleton(class {\n  /** @internal */\n  private readonly p = resolve(IPlatform);\n  public prevent = false;\n\n  public onError = (event: Event, error: unknown) => {\n    const errorEvent = new this.p.CustomEvent('au-event-error', { cancelable: true, detail: { event, error } });\n    this.p.window.dispatchEvent(errorEvent);\n    if (errorEvent.defaultPrevented) {\n      return;\n    }\n    throw error;\n  };\n}));\n\nexport const ListenerBindingRenderer = /*@__PURE__*/ renderer(class ListenerBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.listenerBinding;\n\n  /** @internal */\n  public readonly _modifierHandler = resolve(IEventModifier);\n  /** @internal */\n  public readonly _defaultOptions = resolve(IListenerBindingOptions);\n\n  public constructor() {\n    ListenerBinding.mix();\n  }\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: ListenerBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n  ): void {\n    renderingCtrl.addBinding(new ListenerBinding(\n      renderingCtrl.container,\n      ensureExpression(exprParser, instruction.from, etIsFunction),\n      target,\n      instruction.to,\n      new ListenerBindingOptions(this._defaultOptions.prevent, instruction.capture, this._defaultOptions.onError),\n      this._modifierHandler.getHandler(instruction.to, instruction.modifier),\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const SetAttributeRenderer = /*@__PURE__*/ renderer(class SetAttributeRenderer implements IRenderer {\n  public readonly target = InstructionType.setAttribute;\n  public render(\n    _: IHydratableController,\n    target: HTMLElement,\n    instruction: SetAttributeInstruction,\n  ): void {\n    target.setAttribute(instruction.to, instruction.value);\n  }\n}, null!);\n\nexport const SetClassAttributeRenderer = /*@__PURE__*/ renderer(class SetClassAttributeRenderer implements IRenderer {\n  public readonly target = InstructionType.setClassAttribute;\n  public render(\n    _: IHydratableController,\n    target: HTMLElement,\n    instruction: SetClassAttributeInstruction,\n  ): void {\n    addClasses(target.classList, instruction.value);\n  }\n}, null!);\n\nexport const SetStyleAttributeRenderer = /*@__PURE__*/ renderer(class SetStyleAttributeRenderer implements IRenderer {\n  public readonly target = InstructionType.setStyleAttribute;\n  public render(\n    _: IHydratableController,\n    target: HTMLElement,\n    instruction: SetStyleAttributeInstruction,\n  ): void {\n    target.style.cssText += instruction.value;\n  }\n}, null!);\n\n/* istanbul ignore next */\nconst ambiguousStyles = [\n  'height',\n  'width',\n  'border-width',\n  'padding',\n  'padding-left',\n  'padding-right',\n  'padding-top',\n  'padding-right',\n  'padding-inline',\n  'padding-block',\n  'margin',\n  'margin-left',\n  'margin-right',\n  'margin-top',\n  'margin-bottom',\n  'margin-inline',\n  'margin-block',\n  'top',\n  'right',\n  'bottom',\n  'left',\n];\n\nexport const StylePropertyBindingRenderer = /*@__PURE__*/ renderer(class StylePropertyBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.stylePropertyBinding;\n  public constructor() {\n    PropertyBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: StylePropertyBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    if (__DEV__) {\n      /* istanbul ignore next */\n      if (ambiguousStyles.includes(instruction.to)) {\n        renderingCtrl.addBinding(new DevStylePropertyBinding(\n          renderingCtrl,\n          renderingCtrl.container,\n          observerLocator,\n          ensureExpression(exprParser, instruction.from, etIsProperty),\n          target.style,\n          instruction.to,\n          toView,\n          renderingCtrl.strict ?? false,\n        ));\n        return;\n      }\n    }\n    renderingCtrl.addBinding(new PropertyBinding(\n      renderingCtrl,\n      renderingCtrl.container,\n      observerLocator,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      target.style,\n      instruction.to,\n      toView,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\n/* istanbul ignore next */\nclass DevStylePropertyBinding extends PropertyBinding {\n  public updateTarget(value: unknown): void {\n    if (typeof value === 'number' && value > 0) {\n      // eslint-disable-next-line no-console\n      console.warn(`[DEV]: Setting number ${value} as value for style.${this.targetProperty}. Did you meant \"${value}px\"?`);\n    }\n    return super.updateTarget(value);\n  }\n}\n\nexport const AttributeBindingRenderer = /*@__PURE__*/ renderer(class AttributeBindingRenderer implements IRenderer {\n  public readonly target = InstructionType.attributeBinding;\n  public constructor() {\n    AttributeBinding.mix();\n  }\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: AttributeBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const container = renderingCtrl.container;\n    const classMapping =\n      container.has(ICssClassMapping, false)\n        ? container.get(ICssClassMapping)\n        : null;\n    renderingCtrl.addBinding(new AttributeBinding(\n      renderingCtrl,\n      container,\n      observerLocator,\n      ensureExpression(exprParser, instruction.from, etIsProperty),\n      target,\n      instruction.attr/* targetAttribute */,\n      classMapping == null\n        ? instruction.to/* targetKey */\n        : instruction.to.split(/\\s/g).map(c => classMapping[c] ?? c).join(' '),\n      toView,\n      renderingCtrl.strict ?? false,\n    ));\n  }\n}, null!);\n\nexport const SpreadRenderer = /*@__PURE__*/ renderer(class SpreadRenderer implements IRenderer {\n  /** @internal */ public readonly _compiler = resolve(ITemplateCompiler);\n  /** @internal */ public readonly _rendering = resolve(IRendering);\n\n  public readonly target = InstructionType.spreadTransferedBinding;\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: HTMLElement,\n    instruction: SpreadTransferedBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    SpreadBinding.create(\n      renderingCtrl.container.get(IHydrationContext),\n      target,\n      void 0,\n      this._rendering,\n      this._compiler,\n      platform,\n      exprParser,\n      observerLocator\n    )\n    .forEach(b => renderingCtrl.addBinding(b));\n  }\n}, null!);\n\nexport const SpreadValueRenderer = /*@__PURE__*/ renderer(class SpreadValueRenderer implements IRenderer {\n  public readonly target = InstructionType.spreadValueBinding;\n  public constructor() {\n    SpreadValueBinding.mix();\n  }\n\n  public render(\n    renderingCtrl: IHydratableController,\n    target: ICustomElementController,\n    instruction: SpreadValueBindingInstruction,\n    platform: IPlatform,\n    exprParser: IExpressionParser,\n    observerLocator: IObserverLocator,\n  ): void {\n    const instructionTarget = instruction.target;\n    if (instructionTarget === '$bindables') {\n      renderingCtrl.addBinding(new SpreadValueBinding(\n        renderingCtrl,\n        target.viewModel,\n        objectKeys(target.definition.bindables),\n        exprParser.parse(instruction.from, etIsProperty),\n        observerLocator,\n        renderingCtrl.container,\n        renderingCtrl.strict ?? false,\n      ));\n    } else {\n      throw createMappedError(ErrorNames.spreading_invalid_target, instructionTarget);\n    }\n  }\n}, null!);\n\n// http://jsben.ch/7n5Kt\nfunction addClasses(classList: DOMTokenList, className: string): void {\n  const len = className.length;\n  let start = 0;\n  for (let i = 0; i < len; ++i) {\n    if (className.charCodeAt(i) === 0x20) {\n      if (i !== start) {\n        classList.add(className.slice(start, i));\n      }\n      start = i + 1;\n    } else if (i + 1 === len) {\n      classList.add(className.slice(start));\n    }\n  }\n}\n\n// const createSurrogateBinding = (context: IHydrationContext<object>) =>\n//   new SpreadBinding([], context) as SpreadBinding & IHydratableController;\nconst controllerProviderName = 'IController';\nconst instructionProviderName = 'IInstruction';\nconst locationProviderName = 'IRenderLocation';\nconst slotInfoProviderName = 'ISlotsInfo';\n\nfunction createElementContainer(\n  p: IPlatform,\n  renderingCtrl: IController,\n  host: HTMLElement,\n  instruction: HydrateElementInstruction,\n  location: IRenderLocation | null,\n  auSlotsInfo?: IAuSlotsInfo,\n): IContainer {\n  const ctn = renderingCtrl.container.createChild();\n\n  registerHostNode(ctn, host, p);\n  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));\n  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));\n  registerResolver(ctn, IRenderLocation, location == null\n    ? noLocationProvider\n    : new RenderLocationProvider(location));\n  registerResolver(ctn, IViewFactory, noViewFactoryProvider);\n  registerResolver(ctn, IAuSlotsInfo, auSlotsInfo == null\n    ? noAuSlotProvider\n    : new InstanceProvider(slotInfoProviderName, auSlotsInfo)\n  );\n\n  return ctn;\n}\n\nclass ViewFactoryProvider implements IResolver {\n  private readonly f: IViewFactory | null;\n  public get $isResolver(): true { return true; }\n\n  public constructor(\n    /**\n     * The factory instance that this provider will resolves to,\n     * until explicitly overridden by prepare call\n     */\n    factory: IViewFactory | null\n  ) {\n    this.f = factory;\n  }\n\n  public resolve(): IViewFactory {\n    const f = this.f;\n    if (f === null) {\n      throw createMappedError(ErrorNames.view_factory_provider_not_ready);\n    }\n    if (!isString(f.name) || f.name.length === 0) {\n      throw createMappedError(ErrorNames.view_factory_invalid_name);\n    }\n    return f;\n  }\n}\n\n/** @internal */\nexport interface IHasController {\n  $controller: IController;\n}\n\nfunction invokeAttribute(\n  p: IPlatform,\n  definition: CustomAttributeDefinition,\n  $renderingCtrl: IController | IHasController,\n  host: HTMLElement,\n  instruction: HydrateAttributeInstruction | HydrateTemplateController,\n  viewFactory?: IViewFactory,\n  location?: IRenderLocation,\n  auSlotsInfo?: IAuSlotsInfo,\n): { vm: ICustomAttributeViewModel; ctn: IContainer } {\n  const renderingCtrl = $renderingCtrl instanceof Controller\n    ? $renderingCtrl\n    : ($renderingCtrl as IHasController).$controller;\n  const ctn = renderingCtrl.container.createChild();\n  registerHostNode(ctn, host, p);\n  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));\n  registerResolver(ctn, IInstruction, new InstanceProvider<IInstruction>(instructionProviderName, instruction));\n  registerResolver(ctn, IRenderLocation, location == null\n    ? noLocationProvider\n    : new InstanceProvider(locationProviderName, location));\n  registerResolver(ctn, IViewFactory, viewFactory == null\n    ? noViewFactoryProvider\n    : new ViewFactoryProvider(viewFactory));\n  registerResolver(ctn, IAuSlotsInfo, auSlotsInfo == null\n    ? noAuSlotProvider\n    : new InstanceProvider(slotInfoProviderName, auSlotsInfo));\n\n  return { vm: ctn.invoke(definition.Type), ctn };\n}\n\nclass RenderLocationProvider implements IResolver {\n  public get name() { return 'IRenderLocation'; }\n  public get $isResolver(): true { return true; }\n\n  public constructor(\n    private readonly _location: IRenderLocation | null\n  ) {}\n\n  public resolve(): IRenderLocation | null {\n    return this._location;\n  }\n}\n\nconst noLocationProvider = new RenderLocationProvider(null);\nconst noViewFactoryProvider = new ViewFactoryProvider(null);\nconst noAuSlotProvider = new InstanceProvider<IAuSlotsInfo>(slotInfoProviderName, new AuSlotsInfo(emptyArray));\n", "import { createLookup, isString, IContainer, resolve } from '@aurelia/kernel';\nimport { IExpressionParser } from '@aurelia/expression-parser';\nimport { IObserverLocator } from '@aurelia/runtime';\n\nimport { FragmentNodeSequence, INodeSequence } from '../dom';\nimport { INode } from '../dom.node';\nimport { IPlatform } from '../platform';\nimport { IRenderer } from '../renderer';\nimport { CustomElementDefinition, PartialCustomElementDefinition } from '../resources/custom-element';\nimport { IViewFactory, ViewFactory } from './view';\nimport type { IHydratableController } from './controller';\nimport { createInterface } from '../utilities-di';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { IInstruction, ITemplateCompiler } from '@aurelia/template-compiler';\n\nexport const IRendering = /*@__PURE__*/createInterface<IRendering>('IRendering', x => x.singleton(Rendering));\nexport interface IRendering {\n  get renderers(): Record<string, IRenderer>;\n\n  compile(\n    definition: CustomElementDefinition,\n    container: IContainer,\n  ): CustomElementDefinition;\n\n  getViewFactory(definition: PartialCustomElementDefinition, container: IContainer): IViewFactory;\n\n  createNodes(definition: CustomElementDefinition): INodeSequence;\n\n  render(\n    controller: IHydratableController,\n    targets: ArrayLike<INode>,\n    definition: CustomElementDefinition,\n    host: INode | null | undefined,\n  ): void;\n}\n\nexport class Rendering implements IRendering {\n  /** @internal */\n  private readonly _ctn: IContainer;\n  /** @internal */\n  private readonly _exprParser: IExpressionParser;\n  /** @internal */\n  private readonly _observerLocator: IObserverLocator;\n  /** @internal */\n  private _renderers: Record<string, IRenderer> | undefined;\n  /** @internal */\n  private readonly _platform: IPlatform;\n  /** @internal */\n  private readonly _compilationCache: WeakMap<PartialCustomElementDefinition, CustomElementDefinition> = new WeakMap();\n  /** @internal */\n  private readonly _fragmentCache: WeakMap<CustomElementDefinition, DocumentFragment | null> = new WeakMap();\n  /** @internal */\n  private readonly _empty: INodeSequence;\n  /** @internal */\n  private readonly _marker: Node;\n\n  public get renderers(): Record<string, IRenderer> {\n    return this._renderers ??= this._ctn.getAll(IRenderer, false).reduce((all, r) => {\n      if (__DEV__) {\n        if (all[r.target] !== void 0) {\n          // eslint-disable-next-line no-console\n          console.warn(`[DEV:aurelia] Renderer for target ${r.target} already exists.`);\n        }\n      }\n      all[r.target] ??= r;\n      return all;\n    }, createLookup<IRenderer>());\n  }\n\n  public constructor() {\n    const ctn = this._ctn = resolve(IContainer).root;\n    const p = this._platform = ctn.get(IPlatform);\n    this._exprParser= ctn.get(IExpressionParser);\n    this._observerLocator = ctn.get(IObserverLocator);\n    this._marker = p.document.createElement('au-m');\n    this._empty = new FragmentNodeSequence(p, p.document.createDocumentFragment());\n  }\n\n  public compile(\n    definition: CustomElementDefinition,\n    container: IContainer,\n  ): CustomElementDefinition {\n    const compiler = container.get(ITemplateCompiler);\n    const compiledMap = this._compilationCache;\n    let compiled = compiledMap.get(definition);\n    if (compiled == null) {\n      compiledMap.set(definition, compiled = CustomElementDefinition.create(\n        definition.needsCompile\n          ? compiler.compile(\n            definition,\n            container,\n          )\n          : definition\n      ));\n    }\n    return compiled;\n  }\n\n  public getViewFactory(definition: PartialCustomElementDefinition, container: IContainer): IViewFactory {\n    return new ViewFactory(container, CustomElementDefinition.getOrCreate(definition));\n  }\n\n  public createNodes(definition: CustomElementDefinition): INodeSequence {\n    if (definition.enhance === true) {\n      return new FragmentNodeSequence(this._platform, this._transformMarker(definition.template as Node) as DocumentFragment);\n    }\n    let fragment: DocumentFragment | null | undefined;\n    let needsImportNode = false;\n    const cache = this._fragmentCache;\n    const p = this._platform;\n    const doc = p.document;\n    if (cache.has(definition)) {\n      fragment = cache.get(definition);\n    } else {\n      const template = definition.template;\n      let tpl: HTMLTemplateElement;\n      if (template == null) {\n        fragment = null;\n      } else if (template instanceof p.Node) {\n        if (template.nodeName === 'TEMPLATE') {\n          fragment = (template as HTMLTemplateElement).content;\n          needsImportNode = true;\n        } else {\n          (fragment = doc.createDocumentFragment()).appendChild(template.cloneNode(true));\n        }\n      } else {\n        tpl = doc.createElement('template');\n        if (isString(template)) {\n          tpl.innerHTML = template;\n        }\n        fragment = tpl.content;\n        needsImportNode = true;\n      }\n      this._transformMarker(fragment);\n\n      cache.set(definition, fragment);\n    }\n    return fragment == null\n      ? this._empty\n      : new FragmentNodeSequence(\n        this._platform,\n        needsImportNode\n          ? doc.importNode(fragment, true)\n          : doc.adoptNode(fragment.cloneNode(true) as DocumentFragment)\n        );\n  }\n\n  public render(\n    controller: IHydratableController,\n    targets: ArrayLike<INode>,\n    definition: CustomElementDefinition,\n    host: INode | null | undefined,\n  ): void {\n    const rows = definition.instructions;\n    const renderers = this.renderers;\n    const ii = targets.length;\n\n    let i = 0;\n    let j = 0;\n    let jj = rows.length;\n    let row: readonly IInstruction[];\n    let instruction: IInstruction;\n    let target: INode;\n\n    if (ii !== jj) {\n      throw createMappedError(ErrorNames.rendering_mismatch_length, ii, jj);\n    }\n\n    // host is only null when rendering a synthetic view\n    // but we have a check here so that we dont need to read surrogates unnecessarily\n    if (host != null) {\n      row = definition.surrogates;\n      if ((jj = row.length) > 0) {\n        j = 0;\n        while (jj > j) {\n          instruction = row[j];\n          renderers[instruction.type].render(controller, host, instruction, this._platform, this._exprParser, this._observerLocator);\n          ++j;\n        }\n      }\n    }\n\n    if (ii > 0) {\n      while (ii > i) {\n        row = rows[i];\n        target = targets[i];\n        j = 0;\n        jj = row.length;\n        while (jj > j) {\n          instruction = row[j];\n          renderers[instruction.type].render(controller, target, instruction, this._platform, this._exprParser, this._observerLocator);\n          ++j;\n        }\n        ++i;\n      }\n    }\n  }\n\n  /** @internal */\n  private _transformMarker(fragment: Node | null) {\n    if (fragment == null) {\n      return null;\n    }\n    const walker = this._platform.document.createTreeWalker(fragment, /* NodeFilter.SHOW_COMMENT */ 128);\n    let currentNode: Node | null;\n    while ((currentNode = walker.nextNode()) != null) {\n      if (currentNode.nodeValue === 'au*') {\n        currentNode.parentNode!.replaceChild(walker.currentNode = this._marker.cloneNode(), currentNode);\n      }\n    }\n    return fragment;\n    // below is a homemade \"comment query selector that seems to be as efficient as the TreeWalker\n    // also it works with very minimal set of APIs (.nextSibling, .parentNode, .insertBefore, .removeChild)\n    // while TreeWalker maynot be always available in platform that we may potentially support\n    //\n    // so leaving it here just in case we need it again, TreeWalker is slightly less code\n\n    // let parent: Node = fragment;\n    // let current: Node | null | undefined = parent.firstChild;\n    // let next: Node | null | undefined = null;\n\n    // while (current != null) {\n    //   if (current.nodeType === 8 && current.nodeValue === 'au*') {\n    //     next = current.nextSibling!;\n    //     parent.removeChild(current);\n    //     parent.insertBefore(this._marker(), next);\n    //     if (next.nodeType === 8) {\n    //       current = next.nextSibling;\n    //       // todo: maybe validate?\n    //     } else {\n    //       current = next;\n    //     }\n    //   }\n\n    //   next = current?.firstChild;\n    //   if (next == null) {\n    //     next = current?.nextSibling;\n    //     if (next == null) {\n    //       current = parent.nextSibling;\n    //       parent = parent.parentNode!;\n    //       // needs to keep walking up all the way til a valid next node\n    //       while (current == null && parent != null) {\n    //         current = parent.nextSibling;\n    //         parent = parent.parentNode!;\n    //       }\n    //     } else {\n    //       current = next;\n    //     }\n    //   } else {\n    //     parent = current!;\n    //     current = next;\n    //   }\n    // }\n    // return fragment;\n  }\n}\n", "import { IContainer, createLookup, noop, own, resolve, toArray } from '@aurelia/kernel';\nimport { AppTask } from '../app-task';\nimport { ICssClassMapping } from '../dom';\nimport { IPlatform } from '../platform';\nimport { createInterface, instanceRegistration } from '../utilities-di';\n\nimport type { IRegistry } from '@aurelia/kernel';\nimport { ITemplateCompilerHooks, TemplateCompilerHooks } from '@aurelia/template-compiler';\nimport { objectAssign } from '../utilities';\n\n/**\n * There are 2 implementations of CSS registry: css module registry and shadow dom registry.\n *\n * - CSS registry alters the way class bindings work via altering templates and register interfaces that will alter bindings to class attribute.\n *\n * - Shadow dom registry regisiters some interfaces with the custom element container to handle shadow dom styles.\n * Shadow DOM abtraction summary:\n * CSS registry ---(register)---> IShadowDOMStyleFactory ---(createStyles)---> IShadowDOMStyles ---(applyTo)---> ShadowRoot\n */\n\n/**\n * create a registry to register CSS module handling for a custom element.\n * The resulting registry can be registered as a dependency of a custom element.\n */\nexport function cssModules(...modules: (Record<string, string>)[]): CSSModulesProcessorRegistry {\n  return new CSSModulesProcessorRegistry(modules);\n}\n\nexport class CSSModulesProcessorRegistry implements IRegistry {\n  public constructor(\n    private readonly modules: Record<string, string>[],\n  ) {}\n\n  public register(container: IContainer): void {\n    let existingMapping = container.get(own(ICssClassMapping));\n    if (existingMapping == null) {\n      container.register(\n        instanceRegistration(ICssClassMapping, existingMapping = createLookup()),\n      );\n    }\n    /* istanbul ignore if */\n    if (__DEV__) {\n      for (const mapping of this.modules) {\n        for (const originalClass in mapping) {\n          if (originalClass in existingMapping) {\n            // eslint-disable-next-line no-console\n            console.warn(`[DEV:aurelia] CSS class mapping for class \"${originalClass}\": \"${mapping[originalClass]}\" is overridden by \"${existingMapping[originalClass]}\"`);\n          }\n          existingMapping[originalClass] = mapping[originalClass];\n        }\n      }\n    } else {\n      objectAssign(existingMapping, ...this.modules);\n    }\n\n    class CompilingHook implements ITemplateCompilerHooks {\n      public compiling(template: HTMLElement): void {\n        const isTemplate = template.tagName === 'TEMPLATE';\n        const container = isTemplate\n          ? (template as HTMLTemplateElement).content\n          : template;\n        const plainClasses = [template, ...toArray(container.querySelectorAll('[class]'))];\n        for (const element of plainClasses) {\n          const classes = element.getAttributeNode('class')!;\n          // we always include container, so there's a case where classes is null\n          if (classes == null) {\n            continue;\n          }\n          const newClasses = classes.value.split(/\\s+/g).map(x => existingMapping![x] || x).join(' ');\n          classes.value = newClasses;\n        }\n      }\n    }\n\n    container.register(TemplateCompilerHooks.define(CompilingHook));\n  }\n}\n\n/**\n * Creates a registry to register shadow dom styles handling for a custom element.\n * The resulting registry can be registered as a dependency of a custom element.\n */\nexport function shadowCSS(...css: (string | CSSStyleSheet)[]): ShadowDOMRegistry {\n  return new ShadowDOMRegistry(css);\n}\n\nexport interface IShadowDOMStyleFactory {\n  createStyles(localStyles: (string | CSSStyleSheet)[], sharedStyles: IShadowDOMStyles | null): IShadowDOMStyles;\n}\n\nexport const IShadowDOMStyleFactory = /*@__PURE__*/createInterface<IShadowDOMStyleFactory>('IShadowDOMStyleFactory', x => x.cachedCallback(handler => {\n  if (AdoptedStyleSheetsStyles.supported(handler.get(IPlatform))) {\n    return handler.get(AdoptedStyleSheetsStylesFactory);\n  }\n  return handler.get(StyleElementStylesFactory);\n}));\n\nexport class ShadowDOMRegistry implements IRegistry {\n  public constructor(\n    private readonly css: (string | CSSStyleSheet)[],\n  ) { }\n\n  public register(container: IContainer): void {\n    const sharedStyles = container.get(IShadowDOMGlobalStyles);\n    const factory = container.get(IShadowDOMStyleFactory);\n    container.register(instanceRegistration(IShadowDOMStyles, factory.createStyles(this.css, sharedStyles)));\n  }\n}\n\nclass AdoptedStyleSheetsStylesFactory implements IShadowDOMStyleFactory {\n  private readonly p = resolve(IPlatform);\n  private readonly cache = new Map<string, CSSStyleSheet>();\n\n  public createStyles(localStyles: (string | CSSStyleSheet)[], sharedStyles: IShadowDOMStyles | null): IShadowDOMStyles {\n    return new AdoptedStyleSheetsStyles(this.p, localStyles, this.cache, sharedStyles);\n  }\n}\n\n// not really needed nowadays since all browsers support adopted style sheet\n// though keep it here for a bit longer before removing\n/* istanbul ignore next */\nclass StyleElementStylesFactory implements IShadowDOMStyleFactory {\n  private readonly p = resolve(IPlatform);\n\n  public createStyles(localStyles: string[], sharedStyles: IShadowDOMStyles | null): IShadowDOMStyles {\n    return new StyleElementStyles(this.p, localStyles, sharedStyles);\n  }\n}\n\ntype HasAdoptedStyleSheets = ShadowRoot & {\n  adoptedStyleSheets: CSSStyleSheet[];\n};\n\nexport interface IShadowDOMStyles {\n  applyTo(shadowRoot: ShadowRoot): void;\n}\n\nexport const IShadowDOMStyles = /*@__PURE__*/createInterface<IShadowDOMStyles>('IShadowDOMStyles');\nexport const IShadowDOMGlobalStyles = /*@__PURE__*/createInterface<IShadowDOMStyles>('IShadowDOMGlobalStyles', x => x.instance({ applyTo: noop }));\n\nexport class AdoptedStyleSheetsStyles implements IShadowDOMStyles {\n  private readonly styleSheets: CSSStyleSheet[];\n\n  public constructor(\n    p: IPlatform,\n    localStyles: (string | CSSStyleSheet)[],\n    styleSheetCache: Map<string, CSSStyleSheet>,\n    private readonly sharedStyles: IShadowDOMStyles | null = null\n  ) {\n    this.styleSheets = localStyles.map(x => {\n      let sheet: CSSStyleSheet | undefined;\n\n      if (x instanceof p.CSSStyleSheet) {\n        sheet = x;\n      } else {\n        sheet = styleSheetCache.get(x);\n\n        if (sheet === void 0) {\n          sheet = new p.CSSStyleSheet();\n          sheet.replaceSync(x);\n          styleSheetCache.set(x, sheet);\n        }\n      }\n\n      return sheet;\n    });\n  }\n\n  public static supported(p: IPlatform): boolean {\n    return 'adoptedStyleSheets' in p.ShadowRoot.prototype;\n  }\n\n  public applyTo(shadowRoot: HasAdoptedStyleSheets): void {\n    if (this.sharedStyles !== null) {\n      this.sharedStyles.applyTo(shadowRoot);\n    }\n\n    // https://wicg.github.io/construct-stylesheets/\n    // https://developers.google.com/web/updates/2019/02/constructable-stylesheets\n    shadowRoot.adoptedStyleSheets = [\n      ...shadowRoot.adoptedStyleSheets,\n      ...this.styleSheets\n    ];\n  }\n}\n\nexport class StyleElementStyles implements IShadowDOMStyles {\n  public constructor(\n    private readonly p: IPlatform,\n    private readonly localStyles: string[],\n    private readonly sharedStyles: IShadowDOMStyles | null = null\n  ) { }\n\n  public applyTo(shadowRoot: ShadowRoot): void {\n    const styles = this.localStyles;\n    const p = this.p;\n\n    for (let i = styles.length - 1; i > -1; --i) {\n      const element = p.document.createElement('style');\n      element.innerHTML = styles[i];\n      shadowRoot.prepend(element);\n    }\n\n    if (this.sharedStyles !== null) {\n      this.sharedStyles.applyTo(shadowRoot);\n    }\n  }\n}\n\nexport interface IShadowDOMConfiguration {\n  sharedStyles?: (string | CSSStyleSheet)[];\n}\n\nexport const StyleConfiguration = {\n  shadowDOM(config: IShadowDOMConfiguration): IRegistry {\n    return AppTask.creating(IContainer, container => {\n      if (config.sharedStyles != null) {\n        const factory = container.get(IShadowDOMStyleFactory);\n        container.register(instanceRegistration(IShadowDOMGlobalStyles, factory.createStyles(config.sharedStyles, null)));\n      }\n    });\n  }\n};\n", "import { areEqual, type IServiceLocator } from '@aurelia/kernel';\nimport { IsBindingBehavior } from '@aurelia/expression-parser';\nimport {\n  connectable,\n  ConnectableSwitcher,\n  ProxyObservable,\n  astEvaluate,\n  queueTask,\n} from '@aurelia/runtime';\nimport { mixinAstEvaluator } from '../binding/binding-utils';\n\nimport type {\n  ICollectionSubscriber,\n  IConnectable,\n  IObservable,\n  IObserverLocator,\n  IObserverLocatorBasedConnectable,\n  ISubscriber,\n  Scope,\n} from '@aurelia/runtime';\nimport type { IWatcherCallback } from '../watch';\nimport { IBinding } from '../binding/interfaces-bindings';\n\nconst { enter, exit } = ConnectableSwitcher;\nconst { wrap, unwrap } = ProxyObservable;\n\n// watchers (Computed & Expression) are basically binding,\n// they are treated as special and setup before all other bindings\n\nexport interface ComputedWatcher extends IObserverLocatorBasedConnectable, IServiceLocator { }\n\nexport class ComputedWatcher implements IBinding, ISubscriber, ICollectionSubscriber {\n  static {\n    connectable(ComputedWatcher, null!);\n  }\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  private _isQueued: boolean = false;\n\n  /** @internal */\n  private _computeDepth: number = 0;\n\n  /** @internal */\n  private _value: unknown = void 0;\n  public get value(): unknown {\n    return this._value;\n  }\n\n  /** @internal */\n  public readonly _flush: 'async' | 'sync';\n  /**\n   * A semi-private property used by connectable mixin\n   *\n   * @internal\n   */\n  public readonly oL: IObserverLocator;\n\n  /** @internal */\n  private readonly _callback: IWatcherCallback<object>;\n\n  public constructor(\n    public readonly obj: IObservable,\n    observerLocator: IObserverLocator,\n    public readonly $get: (obj: object, watcher: IConnectable) => unknown,\n    cb: IWatcherCallback<object>,\n    flush: 'async' | 'sync' = 'async',\n  ) {\n    this._callback = cb;\n    this.oL = observerLocator;\n    this._flush = flush;\n  }\n\n  public handleChange(): void {\n    this.run();\n  }\n\n  public handleCollectionChange(): void {\n    this.run();\n  }\n\n  public bind(): void {\n    if (this.isBound) return;\n    this.compute();\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n    this.obs.clearAll();\n  }\n\n  private run(): void {\n    if (!this.isBound) return;\n    if (this._flush === 'sync') {\n      this._run();\n      return;\n    }\n\n    if (this._isQueued) return;\n    this._isQueued = true;\n    queueTask(() => {\n      this._isQueued = false;\n      this._run();\n    });\n  }\n\n  /** @internal */\n  private _run() {\n    if (!this.isBound) return;\n\n    const obj = this.obj;\n    const oldValue = this._value;\n    if (++this._computeDepth > 100) {\n      // todo: error code\n      throw new Error(`AURXXXX: Possible infinitely recursive side-effect detected in a watcher.`);\n    }\n\n    const newValue = this.compute();\n\n    if (!areEqual(newValue, oldValue)) {\n      this._callback.call(obj, newValue, oldValue, obj);\n    }\n    if (!this._isQueued) {\n      this._computeDepth = 0;\n    }\n  }\n\n  private compute(): unknown {\n    this.obs.version++;\n    try {\n      enter(this);\n      return this._value = unwrap(this.$get.call(void 0, wrap(this.obj), this));\n    } finally {\n      this.obs.clear();\n      exit(this);\n    }\n  }\n}\n\nexport interface ExpressionWatcher extends IObserverLocatorBasedConnectable, /* a hack, but it's only for internal */IServiceLocator { }\n\nexport class ExpressionWatcher implements IBinding, IObserverLocatorBasedConnectable {\n  static {\n    connectable(ExpressionWatcher, null!);\n    mixinAstEvaluator(ExpressionWatcher);\n  }\n\n  public isBound: boolean = false;\n\n  /** @internal */\n  private _isQueued: boolean = false;\n\n  /**\n   * @internal\n   */\n  private readonly obj: object;\n\n  /** @internal */\n  private _value: unknown;\n  public get value(): unknown {\n    return this._value;\n  }\n\n  // see Listener binding for explanation\n  /** @internal */\n  public readonly boundFn = false;\n\n  /** @internal */\n  private readonly _flush: 'async' | 'sync';\n\n  /** @internal */\n  private readonly _expression: IsBindingBehavior;\n\n  /** @internal */\n  private readonly _callback: IWatcherCallback<object>;\n\n  public constructor(\n    public scope: Scope,\n    public l: IServiceLocator,\n    public oL: IObserverLocator,\n    expression: IsBindingBehavior,\n    callback: IWatcherCallback<object>,\n    flush: 'async' | 'sync' = 'async',\n  ) {\n    this.obj = scope.bindingContext;\n    this._expression = expression;\n    this._callback = callback;\n    this._flush = flush;\n  }\n\n  public handleChange(): void {\n    this.run();\n  }\n\n  public handleCollectionChange(): void {\n    this.run();\n  }\n\n  private run() {\n    if (!this.isBound) return;\n\n    if (this._flush === 'sync') {\n      this._run();\n      return;\n    }\n\n    if (this._isQueued) return;\n    this._isQueued = true;\n    queueTask(() => {\n      this._isQueued = false;\n      this._run();\n    });\n  }\n\n  /** @internal */\n  private _run() {\n    if (!this.isBound) return;\n\n    const expr = this._expression;\n    const obj = this.obj;\n    const oldValue = this._value;\n    this.obs.version++;\n    const value = astEvaluate(expr, this.scope, this, this);\n    this.obs.clear();\n    if (!areEqual(value, oldValue)) {\n      this._value = value;\n      this._callback.call(obj, value, oldValue, obj);\n    }\n  }\n\n  public bind(): void {\n    if (this.isBound) return;\n    this.obs.version++;\n    this._value = astEvaluate(this._expression, this.scope, this, this);\n    this.obs.clear();\n    this.isBound = true;\n  }\n\n  public unbind(): void {\n    if (!this.isBound) return;\n    this.isBound = false;\n    this.obs.clearAll();\n    this._value = void 0;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\nimport {\n  AnyFunction,\n  IIndexable,\n  ILogger,\n  InstanceProvider,\n  LogLevel,\n  noop,\n  onResolve,\n  onResolveAll,\n  optional,\n  optionalResource,\n  isFunction,\n  isPromise,\n  isString,\n} from '@aurelia/kernel';\nimport { IExpressionParser, IsBindingBehavior, AccessScopeExpression } from '@aurelia/expression-parser';\nimport {\n  ICoercionConfiguration,\n  IObserverLocator,\n  queueTask,\n  Scope,\n} from '@aurelia/runtime';\nimport { convertToRenderLocation } from '../dom';\nimport { refs } from '../dom.node';\nimport { CustomAttributeDefinition, getAttributeDefinition } from '../resources/custom-attribute';\nimport { CustomElementDefinition, elementBaseName, getElementDefinition, isElementType } from '../resources/custom-element';\nimport { etIsProperty, getOwnPropertyNames, objectFreeze } from '../utilities';\nimport { createInterface, registerResolver } from '../utilities-di';\nimport { LifecycleHooks, LifecycleHooksEntry } from './lifecycle-hooks';\nimport { IRendering } from './rendering';\nimport { IShadowDOMGlobalStyles, IShadowDOMStyles } from './styles';\nimport { ComputedWatcher, ExpressionWatcher } from './watchers';\n\nimport type {\n  Constructable,\n  IContainer,\n  IDisposable,\n  IServiceLocator,\n  ResourceDefinition,\n  Writable,\n} from '@aurelia/kernel';\nimport type {\n  IObservable,\n} from '@aurelia/runtime';\nimport type { INodeSequence, IRenderLocation } from '../dom';\nimport type { INode } from '../dom.node';\nimport { ErrorNames, createMappedError } from '../errors';\nimport type { IInstruction, AttrSyntax } from '@aurelia/template-compiler';\nimport type { PartialCustomElementDefinition } from '../resources/custom-element';\nimport type { IWatchDefinition, IWatcherCallback } from '../watch';\nimport type { LifecycleHooksLookup } from './lifecycle-hooks';\nimport type { IViewFactory } from './view';\nimport { IBinding } from '../binding/interfaces-bindings';\n\nexport class Controller<C extends IViewModel = IViewModel> implements IController<C> {\n\n  public head: IHydratedController | null = null;\n  public tail: IHydratedController | null = null;\n  public next: IHydratedController | null = null;\n\n  public parent: IHydratedController | null = null;\n  public bindings: IBinding[] | null = null;\n  public children: Controller[] | null = null;\n\n  public hasLockedScope: boolean = false;\n\n  public scope: Scope | null = null;\n  public isBound: boolean = false;\n  /** @internal */\n  private _isBindingDone: boolean = false;\n\n  public mountTarget: MountTarget = targetNone;\n  public shadowRoot: ShadowRoot | null = null;\n  public nodes: INodeSequence | null = null;\n  public location: IRenderLocation | null = null;\n\n  /** @internal */\n  public _lifecycleHooks: LifecycleHooksLookup<ICompileHooks & IActivationHooks<IHydratedController>> | null = null;\n  public get lifecycleHooks(): LifecycleHooksLookup<ICompileHooks & IActivationHooks<IHydratedController>> | null {\n    return this._lifecycleHooks;\n  }\n\n  public state: State = none;\n\n  public get isActive(): boolean {\n    return (this.state & (activating | activated)) > 0 && (this.state & deactivating) === 0;\n  }\n\n  public get name(): string {\n    if (this.parent === null) {\n      switch (this.vmKind) {\n        case vmkCa:\n          return `[${this.definition!.name}]`;\n        case vmkCe:\n          return this.definition!.name;\n        case vmkSynth:\n          return this.viewFactory!.name;\n      }\n    }\n    switch (this.vmKind) {\n      case vmkCa:\n        return `${this.parent.name}>[${this.definition!.name}]`;\n      case vmkCe:\n        return `${this.parent.name}>${this.definition!.name}`;\n      case vmkSynth:\n        return this.viewFactory!.name === this.parent.definition?.name\n          ? `${this.parent.name}[view]`\n          : `${this.parent.name}[view:${this.viewFactory!.name}]`;\n    }\n  }\n\n  /** @internal */\n  private _compiledDef: CustomElementDefinition | undefined;\n  private logger!: ILogger;\n  private debug!: boolean;\n  /** @internal */\n  private _fullyNamed: boolean = false;\n  /** @internal */\n  private readonly _rendering: IRendering;\n\n  /** @internal */\n  public _vmHooks: HooksDefinition;\n\n  /** @internal */\n  public _vm: ControllerBindingContext<C> | null;\n  public get viewModel(): ControllerBindingContext<C> | null {\n    return this._vm;\n  }\n  public set viewModel(v: ControllerBindingContext<C> | null) {\n    this._vm = v;\n    this._vmHooks = v == null || this.vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(v);\n  }\n\n  public get strict() {\n    return (this.definition as CustomElementDefinition)?.strict;\n  }\n\n  public constructor(\n    public container: IContainer,\n    public readonly vmKind: ViewModelKind,\n    public readonly definition: CustomElementDefinition | CustomAttributeDefinition | null,\n    /**\n     * The viewFactory. Only present for synthetic views.\n     */\n    public viewFactory: IViewFactory | null,\n    /**\n     * The backing viewModel. Only present for custom attributes and elements.\n     */\n    viewModel: ControllerBindingContext<C> | null,\n    /**\n     * The physical host dom node.\n     *\n     * For containerless elements, this node will be removed from the DOM and replaced by a comment, which is assigned to the `location` property.\n     *\n     * For ShadowDOM elements, this will be the original declaring element, NOT the shadow root (the shadow root is stored on the `shadowRoot` property)\n     */\n    public host: HTMLElement | null,\n    /**\n     * The render location replacement for the host on containerless elements\n     */\n    location: IRenderLocation | null,\n  ) {\n    this._vm = viewModel;\n    this._vmHooks = vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(viewModel!);\n    if (__DEV__) {\n      this.logger = null!;\n      this.debug = false;\n    }\n    this.location = location;\n    this._rendering = container.root.get(IRendering);\n  }\n\n  public static getCached<C extends ICustomElementViewModel = ICustomElementViewModel>(viewModel: C): ICustomElementController<C> | undefined {\n    return controllerLookup.get(viewModel) as ICustomElementController<C> | undefined;\n  }\n\n  public static getCachedOrThrow<C extends ICustomElementViewModel = ICustomElementViewModel>(viewModel: C): ICustomElementController<C> {\n    const $el = Controller.getCached(viewModel);\n    if ($el === void 0) {\n      throw createMappedError(ErrorNames.controller_cached_not_found, viewModel);\n    }\n    return $el as ICustomElementController<C>;\n  }\n\n  /**\n   * Create a controller for a custom element based on a given set of parameters\n   *\n   * @param ctn - The own container of the custom element\n   * @param viewModel - The view model object (can be any object if a definition is specified)\n   *\n   * Semi private API\n   */\n  public static $el<C extends ICustomElementViewModel = ICustomElementViewModel>(\n    ctn: IContainer,\n    viewModel: C,\n    host: HTMLElement,\n    hydrationInst: IControllerElementHydrationInstruction | null,\n    // Use this when `instance.constructor` is not a custom element type\n    // to pass on the CustomElement definition\n    definition: CustomElementDefinition | undefined = void 0,\n    // the associated render location of the host\n    // if the element is containerless\n    location: IRenderLocation | null = null,\n  ): ICustomElementController<C> {\n    if (controllerLookup.has(viewModel)) {\n      return controllerLookup.get(viewModel) as unknown as ICustomElementController<C>;\n    }\n\n    if (__DEV__) {\n      if (definition == null) {\n        try {\n          definition = getElementDefinition(viewModel.constructor as Constructable);\n        } catch (ex) {\n          // eslint-disable-next-line\n          console.error(`[DEV:aurelia] Custom element definition not found for creating a controller with host: <${host.nodeName} /> and component ${viewModel.constructor.name || '(Anonymous) class'}`);\n          throw ex;\n        }\n      }\n    } else {\n      definition = definition ?? getElementDefinition(viewModel.constructor as Constructable);\n    }\n\n    registerResolver(ctn, definition.Type, new InstanceProvider<typeof definition.Type>(definition.key, viewModel, definition.Type));\n    const controller = new Controller<C>(\n      /* container      */ctn,\n      /* vmKind         */vmkCe,\n      /* definition     */definition,\n      /* viewFactory    */null,\n      /* viewModel      */viewModel as ControllerBindingContext<C>,\n      /* host           */host,\n      /* location       */location,\n    );\n    // the hydration context this controller is provided with\n    const hydrationContext = ctn.get(optional(IHydrationContext)) as IHydrationContext;\n\n    if (definition.dependencies.length > 0) {\n      ctn.register(...definition.dependencies);\n    }\n    // each CE controller provides its own hydration context for its internal template\n    registerResolver(ctn, IHydrationContext, new InstanceProvider(\n      'IHydrationContext',\n      new HydrationContext(\n        controller as ICustomElementController,\n        hydrationInst,\n        hydrationContext,\n      )\n    ));\n    controllerLookup.set(viewModel, controller as Controller);\n\n    if (hydrationInst == null || hydrationInst.hydrate !== false) {\n      controller._hydrateCustomElement(hydrationInst);\n    }\n\n    return controller as ICustomElementController<C>;\n  }\n\n  /**\n   * Create a controller for a custom attribute based on a given set of parameters\n   *\n   * @param ctn - own container associated with the custom attribute object\n   * @param viewModel - the view model object\n   * @param host - host element where this custom attribute is used\n   * @param flags - todo(comment)\n   * @param definition - the definition of the custom attribute,\n   * will be used to override the definition associated with the view model object contructor if given\n   */\n  public static $attr<C extends ICustomAttributeViewModel = ICustomAttributeViewModel>(\n    ctn: IContainer,\n    viewModel: C,\n    host: HTMLElement,\n    /**\n     * The definition that will be used to hydrate the custom attribute view model\n     *\n     * If not given, will be the one associated with the constructor of the attribute view model given.\n     */\n    definition?: CustomAttributeDefinition,\n  ): ICustomAttributeController<C> {\n    if (controllerLookup.has(viewModel)) {\n      return controllerLookup.get(viewModel) as unknown as ICustomAttributeController<C>;\n    }\n\n    definition = definition ?? getAttributeDefinition(viewModel.constructor as Constructable);\n    registerResolver(ctn, definition.Type, new InstanceProvider<typeof definition.Type>(definition.key, viewModel, definition.Type));\n\n    const controller = new Controller<C>(\n      /* own ct         */ctn,\n      /* vmKind         */vmkCa,\n      /* definition     */definition,\n      /* viewFactory    */null,\n      /* viewModel      */viewModel as ControllerBindingContext<C>,\n      /* host           */host,\n      /* location       */null\n    );\n\n    if (definition.dependencies.length > 0) {\n      ctn.register(...definition.dependencies);\n    }\n\n    controllerLookup.set(viewModel, controller as Controller);\n\n    controller._hydrateCustomAttribute();\n\n    return controller as unknown as ICustomAttributeController<C>;\n  }\n\n  /**\n   * Create a synthetic view (controller) for a given factory\n   *\n   * @param viewFactory - todo(comment)\n   * @param flags - todo(comment)\n   * @param parentController - the parent controller to connect the created view with. Used in activation\n   *\n   * Semi private API\n   */\n  public static $view(\n    viewFactory: IViewFactory,\n    parentController: ISyntheticView | ICustomElementController | ICustomAttributeController | undefined = void 0,\n  ): ISyntheticView {\n    const controller = new Controller(\n      /* container      */viewFactory.container,\n      /* vmKind         */vmkSynth,\n      /* definition     */null,\n      /* viewFactory    */viewFactory,\n      /* viewModel      */null,\n      /* host           */null,\n      /* location       */null\n    );\n    controller.parent = parentController ?? null;\n\n    controller._hydrateSynthetic();\n\n    return controller as unknown as ISyntheticView;\n  }\n\n  /** @internal */\n  public _hydrateCustomElement(\n    hydrationInst: IControllerElementHydrationInstruction | null,\n  ): void {\n    if (__DEV__) {\n      this.logger = this.container.get(ILogger).root;\n      this.debug = this.logger.config.level <= LogLevel.debug;\n      if (this.debug) {\n        this.logger = this.logger.scopeTo(this.name);\n      }\n    }\n\n    const container = this.container;\n    const instance = this._vm!;\n    const definition = this.definition as CustomElementDefinition;\n\n    this.scope = Scope.create(instance, null, true);\n\n    if (definition.watches.length > 0) {\n      createWatchers(this, container, definition, instance);\n    }\n    createObservers(this, definition, instance as IIndexable<ICustomElementViewModel>);\n\n    this._lifecycleHooks = LifecycleHooks.resolve(container);\n    // Support Recursive Components by adding self to own context\n    container.register(definition.Type);\n    // definition.register(container);\n\n    if (definition.injectable !== null) {\n      registerResolver(\n        container,\n        definition.injectable,\n        new InstanceProvider('definition.injectable', instance as ICustomElementViewModel),\n      );\n    }\n\n    // If this is the root controller, then the AppRoot will invoke things in the following order:\n    // - Controller.hydrateCustomElement\n    // - runAppTasks('hydrating') // may return a promise\n    // - Controller.compile\n    // - runAppTasks('hydrated') // may return a promise\n    // - Controller.compileChildren\n    // This keeps hydration synchronous while still allowing the composition root compile hooks to do async work.\n    if (hydrationInst == null || hydrationInst.hydrate !== false) {\n      this._hydrate();\n      this._hydrateChildren();\n    }\n  }\n\n  /** @internal */\n  public _hydrate(): void {\n    if (this._lifecycleHooks!.hydrating != null) {\n      this._lifecycleHooks!.hydrating.forEach(callHydratingHook, this);\n    }\n    if (this._vmHooks._hydrating) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking hydrating() hook`); }\n      this._vm!.hydrating(this as ICustomElementController);\n    }\n\n    const definition = this.definition!;\n    const compiledDef = this._compiledDef = this._rendering.compile(definition as CustomElementDefinition, this.container);\n    const shadowOptions = compiledDef.shadowOptions;\n    const hasSlots = compiledDef.hasSlots;\n    const containerless = compiledDef.containerless;\n    const host = this.host!;\n    let location: IRenderLocation | null = this.location;\n\n    if (containerless && location == null) {\n      location = this.location = convertToRenderLocation(host);\n    }\n\n    setRef(host, elementBaseName, this as IHydratedController);\n    setRef(host, definition.key, this as IHydratedController);\n    if (shadowOptions !== null || hasSlots) {\n      if (location != null) {\n        throw createMappedError(ErrorNames.controller_no_shadow_on_containerless);\n      }\n      setRef(this.shadowRoot = host.attachShadow(shadowOptions ?? defaultShadowOptions), elementBaseName, this as IHydratedController);\n      setRef(this.shadowRoot, definition.key, this as IHydratedController);\n      this.mountTarget = targetShadowRoot;\n    } else if (location != null) {\n      // when template compiler encounter a \"containerless\" attribute\n      // it replaces the element with a render location\n      // making the controller receive the same comment node as both host and location\n      // todo: consider making template compiler less eager to replace\n      //       this has performance implication when using ad-hoc containerless\n      if (host !== location) {\n        setRef(location, elementBaseName, this as IHydratedController);\n        setRef(location, definition.key, this as IHydratedController);\n      }\n      this.mountTarget = targetLocation;\n    } else {\n      this.mountTarget = targetHost;\n    }\n\n    (this._vm as Writable<C>).$controller = this;\n    this.nodes = this._rendering.createNodes(compiledDef);\n\n    if (this._lifecycleHooks!.hydrated !== void 0) {\n      this._lifecycleHooks!.hydrated.forEach(callHydratedHook, this);\n    }\n\n    if (this._vmHooks._hydrated) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking hydrated() hook`); }\n      this._vm!.hydrated(this as ICustomElementController);\n    }\n  }\n\n  /** @internal */\n  public _hydrateChildren(): void {\n    this._rendering.render(\n      /* controller */this as ICustomElementController,\n      /* targets    */this.nodes!.findTargets(),\n      /* definition */this._compiledDef!,\n      /* host       */this.host,\n    );\n\n    if (this._lifecycleHooks!.created !== void 0) {\n      this._lifecycleHooks!.created.forEach(callCreatedHook, this);\n    }\n    if (this._vmHooks._created) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking created() hook`); }\n      this._vm!.created(this as ICustomElementController);\n    }\n  }\n\n  /** @internal */\n  private _hydrateCustomAttribute(): void {\n    const definition = this.definition as CustomAttributeDefinition;\n    const instance = this._vm!;\n\n    if (definition.watches.length > 0) {\n      createWatchers(this, this.container, definition, instance);\n    }\n    createObservers(this, definition, instance as unknown as IIndexable<ICustomAttributeViewModel>);\n\n    (instance as Writable<C>).$controller = this;\n    this._lifecycleHooks = LifecycleHooks.resolve(this.container);\n\n    if (this._lifecycleHooks!.created !== void 0) {\n      this._lifecycleHooks!.created.forEach(callCreatedHook, this);\n    }\n    if (this._vmHooks._created) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`invoking created() hook`); }\n      this._vm!.created(this as ICustomAttributeController);\n    }\n  }\n\n  /** @internal */\n  private _hydrateSynthetic(): void {\n    this._compiledDef = this._rendering.compile(this.viewFactory!.def, this.container);\n    this._rendering.render(\n      /* controller */this as ISyntheticView,\n      /* targets    */(this.nodes = this._rendering.createNodes(this._compiledDef)).findTargets(),\n      /* definition */this._compiledDef,\n      /* host       */void 0,\n    );\n  }\n\n  private $initiator: IHydratedController = null!;\n  public activate(\n    initiator: IHydratedController,\n    parent: IHydratedController | null,\n    scope?: Scope | null,\n  ): void | Promise<void> {\n    switch (this.state) {\n      case none:\n      case deactivated:\n        if (!(parent === null || parent.isActive)) {\n          // If this is not the root, and the parent is either:\n          // 1. Not activated, or activating children OR\n          // 2. Deactivating itself\n          // abort.\n          return;\n        }\n        // Otherwise, proceed normally.\n        // 'deactivated' and 'none' are treated the same because, from an activation perspective, they mean the same thing.\n        this.state = activating;\n        break;\n      case activated:\n        // If we're already activated, no need to do anything.\n        return;\n      case disposed:\n        throw createMappedError(ErrorNames.controller_activating_disposed, this.name);\n      default:\n        throw createMappedError(ErrorNames.controller_activation_unexpected_state, this.name, stringifyState(this.state));\n    }\n\n    this.parent = parent;\n    if (__DEV__ && this.debug && !this._fullyNamed) {\n      this._fullyNamed = true;\n      (this.logger ??= this.container.get(ILogger).root.scopeTo(this.name)).trace(`activate()`);\n    }\n\n    switch (this.vmKind) {\n      case vmkCe:\n        // Custom element scope is created and assigned during hydration\n        (this.scope as Writable<Scope>).parent = scope ?? null;\n        break;\n      case vmkCa:\n        this.scope = scope ?? null;\n        break;\n      case vmkSynth:\n        // maybe only check when there's not already a scope\n        if (scope === void 0 || scope === null) {\n          throw createMappedError(ErrorNames.controller_activation_synthetic_no_scope, this.name);\n        }\n\n        if (!this.hasLockedScope) {\n          this.scope = scope;\n        }\n        break;\n    }\n\n    this.$initiator = initiator;\n\n    // opposing leave is called in attach() (which will trigger attached())\n    this._enterActivating();\n\n    let ret: void | Promise<void> = void 0;\n    if (this.vmKind !== vmkSynth && this._lifecycleHooks!.binding != null) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.binding()`); }\n\n      ret = onResolveAll(...this._lifecycleHooks!.binding!.map(callBindingHook, this));\n    }\n\n    if (this._vmHooks._binding) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`binding()`); }\n\n      ret = onResolveAll(ret, this._vm!.binding(this.$initiator, this.parent));\n    }\n\n    if (isPromise(ret)) {\n      this._ensurePromise();\n      ret.then(() => {\n        this._isBindingDone = true;\n        if (this.state !== activating) {\n          // because controller can be deactivated, during a long running promise in the binding phase\n          this._leaveActivating();\n        } else {\n          this.bind();\n        }\n      }).catch((err: Error) => {\n        this._reject(err);\n      });\n      return this.$promise;\n    }\n\n    this._isBindingDone = true;\n    this.bind();\n    return this.$promise;\n  }\n\n  private bind(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`bind()`); }\n\n    let i = 0;\n    let ii = 0;\n    let ret: void | Promise<void> = void 0;\n\n    if (this.bindings !== null) {\n      i = 0;\n      ii = this.bindings.length;\n      while (ii > i) {\n        this.bindings[i].bind(this.scope!);\n        ++i;\n      }\n    }\n\n    if (this.vmKind !== vmkSynth && this._lifecycleHooks!.bound != null) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.bound()`); }\n\n      ret = onResolveAll(...this._lifecycleHooks!.bound.map(callBoundHook, this));\n    }\n\n    if (this._vmHooks._bound) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`bound()`); }\n\n      ret = onResolveAll(ret, this._vm!.bound(this.$initiator, this.parent));\n    }\n\n    if (isPromise(ret)) {\n      this._ensurePromise();\n      ret.then(() => {\n        this.isBound = true;\n        // because controller can be deactivated, during a long running promise in the bound phase\n        if (this.state !== activating) {\n          this._leaveActivating();\n        } else {\n          this._attach();\n        }\n      }).catch((err: Error) => {\n        this._reject(err);\n      });\n      return;\n    }\n\n    this.isBound = true;\n    this._attach();\n  }\n\n  /** @internal */\n  private _append(...nodes: Node[]): void {\n    switch (this.mountTarget) {\n      case targetHost:\n        this.host!.append(...nodes);\n        break;\n      case targetShadowRoot:\n        this.shadowRoot!.append(...nodes);\n        break;\n      case targetLocation: {\n        let i = 0;\n        for (; i < nodes.length; ++i) {\n          this.location!.parentNode!.insertBefore(nodes[i], this.location);\n        }\n        break;\n      }\n    }\n  }\n\n  /** @internal */\n  private _attach(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`attach()`); }\n\n    switch (this.mountTarget) {\n      case targetHost:\n        this.nodes!.appendTo(this.host!, this.definition != null && (this.definition as CustomElementDefinition).enhance);\n        break;\n      case targetShadowRoot: {\n        const container = this.container;\n        const styles = container.has(IShadowDOMStyles, false)\n          ? container.get(IShadowDOMStyles)\n          : container.get(IShadowDOMGlobalStyles);\n        styles.applyTo(this.shadowRoot!);\n        this.nodes!.appendTo(this.shadowRoot!);\n        break;\n      }\n      case targetLocation:\n        this.nodes!.insertBefore(this.location!);\n        break;\n    }\n\n    let i = 0;\n    let ret: Promise<void> | void = void 0;\n\n    if (this.vmKind !== vmkSynth && this._lifecycleHooks!.attaching != null) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.attaching()`); }\n\n      ret = onResolveAll(...this._lifecycleHooks!.attaching!.map(callAttachingHook, this));\n    }\n\n    if (this._vmHooks._attaching) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`attaching()`); }\n\n      ret = onResolveAll(ret, this._vm!.attaching(this.$initiator, this.parent));\n    }\n\n    if (isPromise(ret)) {\n      this._ensurePromise();\n      this._enterActivating();\n      ret.then(() => {\n        this._leaveActivating();\n      }).catch((err: Error) => {\n        this._reject(err);\n      });\n    }\n\n    // attaching() and child activation run in parallel, and attached() is called when both are finished\n    if (this.children !== null) {\n      for (; i < this.children.length; ++i) {\n        // Any promises returned from child activation are cumulatively awaited before this.$promise resolves\n        void this.children[i].activate(this.$initiator, this as IHydratedController, this.scope);\n      }\n    }\n\n    // attached() is invoked by Controller#leaveActivating when `activatingStack` reaches 0\n    this._leaveActivating();\n  }\n\n  public deactivate(\n    initiator: IHydratedController,\n    _parent: IHydratedController | null,\n  ): void | Promise<void> {\n    let prevActivation: void | Promise<void> = void 0;\n    switch ((this.state & ~released)) {\n      case activated:\n        this.state = deactivating;\n        break;\n      case activating:\n        this.state = deactivating;\n        // we are about to deactivate, the error from activation can be ignored\n        prevActivation = this.$promise?.catch(__DEV__\n          /* istanbul-ignore-next */\n          ? err => {\n            this.logger.warn('The activation error will be ignored, as the controller is already scheduled for deactivation. The activation was rejected with: %s', err);\n          }\n          : noop);\n        break;\n      case none:\n      case deactivated:\n      case disposed:\n      case deactivated | disposed:\n        // If we're already deactivated (or even disposed), or never activated in the first place, no need to do anything.\n        return;\n      default:\n        throw createMappedError(ErrorNames.controller_deactivation_unexpected_state, this.name, this.state);\n    }\n\n    /* istanbul-ignore-next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`deactivate()`); }\n\n    this.$initiator = initiator;\n\n    if (initiator === this) {\n      this._enterDetaching();\n    }\n\n    let i = 0;\n    let ret: void | Promise<void>;\n\n    if (this.children !== null) {\n      for (i = 0; i < this.children.length; ++i) {\n        // Child promise results are tracked by enter/leave combo's\n        void this.children[i].deactivate(initiator, this as IHydratedController);\n      }\n    }\n\n    return onResolve(prevActivation, () => {\n      if (this.isBound) {\n        if (this.vmKind !== vmkSynth && this._lifecycleHooks!.detaching != null) {\n          if (__DEV__ && this.debug) { this.logger!.trace(`lifecycleHooks.detaching()`); }\n\n          ret = onResolveAll(...this._lifecycleHooks!.detaching.map(callDetachingHook, this));\n        }\n\n        if (this._vmHooks._detaching) {\n          if (__DEV__ && this.debug) { this.logger!.trace(`detaching()`); }\n\n          ret = onResolveAll(ret, this._vm!.detaching(this.$initiator, this.parent));\n        }\n      }\n\n      if (isPromise(ret)) {\n        this._ensurePromise();\n        (initiator as Controller)._enterDetaching();\n        ret.then(() => {\n          (initiator as Controller)._leaveDetaching();\n        }).catch((err: Error) => {\n          (initiator as Controller)._reject(err);\n        });\n      }\n\n      // Note: if a 3rd party plugin happens to do any async stuff in a template controller before calling deactivate on its view,\n      // then the linking will become out of order.\n      // For framework components, this shouldn't cause issues.\n      // We can only prevent that by linking up after awaiting the detaching promise, which would add an extra tick + a fair bit of\n      // overhead on this hot path, so it's (for now) a deliberate choice to not account for such situation.\n      // Just leaving the note here so that we know to look here if a weird detaching-related timing issue is ever reported.\n      if (initiator.head === null) {\n        initiator.head = this as IHydratedController;\n      } else {\n        initiator.tail!.next = this as IHydratedController;\n      }\n      initiator.tail = this as IHydratedController;\n\n      if (initiator !== this) {\n        // Only detaching is called + the linked list is built when any controller that is not the initiator, is deactivated.\n        // The rest is handled by the initiator.\n        // This means that descendant controllers have to make sure to await the initiator's promise before doing any subsequent\n        // controller api calls, or race conditions might occur.\n        return;\n      }\n\n      this._leaveDetaching();\n      return this.$promise;\n    });\n  }\n\n  private removeNodes(): void {\n    switch (this.vmKind) {\n      case vmkCe:\n      case vmkSynth:\n        this.nodes!.remove();\n        this.nodes!.unlink();\n    }\n  }\n\n  private unbind(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`unbind()`); }\n\n    let i = 0;\n\n    if (this.bindings !== null) {\n      for (; i < this.bindings.length; ++i) {\n        this.bindings[i].unbind();\n      }\n    }\n\n    this.parent = null;\n\n    switch (this.vmKind) {\n      case vmkCa:\n        this.scope = null;\n        break;\n      case vmkSynth:\n        if (!this.hasLockedScope) {\n          this.scope = null;\n        }\n\n        if (\n          (this.state & released) === released &&\n          !this.viewFactory!.tryReturnToCache(this as ISyntheticView) &&\n          this.$initiator === this\n        ) {\n          this.dispose();\n        }\n        break;\n      case vmkCe:\n        (this.scope as Writable<Scope>).parent = null;\n        break;\n    }\n\n    this.state = deactivated;\n    this.$initiator = null!;\n    this._resolve();\n  }\n\n  private $resolve: (() => void) | undefined = void 0;\n  private $reject: ((err: unknown) => void) | undefined = void 0;\n  private $promise: Promise<void> | undefined = void 0;\n\n  /** @internal */\n  private _ensurePromise(): void {\n    if (this.$promise === void 0) {\n      this.$promise = new Promise((resolve, reject) => {\n        this.$resolve = resolve;\n        this.$reject = reject;\n      });\n      if (this.$initiator !== this) {\n        (this.parent as Controller)._ensurePromise();\n      }\n    }\n  }\n\n  /** @internal */\n  private _resolve(): void {\n    if (this.$promise !== void 0) {\n      _resolve = this.$resolve!;\n      this.$resolve = this.$reject = this.$promise = void 0;\n      _resolve();\n      _resolve = void 0;\n    }\n  }\n\n  /** @internal */\n  private _reject(err: Error): void {\n    if (this.$promise !== void 0) {\n      _reject = this.$reject!;\n      this.$resolve = this.$reject = this.$promise = void 0;\n      _reject(err);\n      _reject = void 0;\n    }\n    if (this.$initiator !== this) {\n      (this.parent as Controller)._reject(err);\n    }\n  }\n\n  /** @internal */\n  private _activatingStack: number = 0;\n  /** @internal */\n  private _enterActivating(): void {\n    ++this._activatingStack;\n    if (this.$initiator !== this) {\n      (this.parent as Controller)._enterActivating();\n    }\n  }\n  /** @internal */\n  private _leaveActivating(): void {\n    if (this.state !== activating) {\n      --this._activatingStack;\n      // skip doing rest of the work if the controller is deactivated.\n      this._resolve();\n      if (this.$initiator !== this) {\n        (this.parent as Controller)._leaveActivating();\n      }\n      return;\n    }\n    if (--this._activatingStack === 0) {\n      if (this.vmKind !== vmkSynth && this._lifecycleHooks!.attached != null) {\n        _retPromise = onResolveAll(...this._lifecycleHooks!.attached.map(callAttachedHook, this));\n      }\n\n      if (this._vmHooks._attached) {\n        /* istanbul ignore next */\n        if (__DEV__ && this.debug) { this.logger!.trace(`attached()`); }\n\n        _retPromise = onResolveAll(_retPromise, this._vm!.attached!(this.$initiator));\n      }\n\n      if (isPromise(_retPromise)) {\n        this._ensurePromise();\n        _retPromise.then(() => {\n          this.state = activated;\n          // Resolve this.$promise, signaling that activation is done (path 1 of 2)\n          this._resolve();\n          if (this.$initiator !== this) {\n            (this.parent as Controller)._leaveActivating();\n          }\n        }).catch((err: Error) => {\n          this._reject(err);\n        });\n        _retPromise = void 0;\n        return;\n      }\n      _retPromise = void 0;\n\n      this.state = activated;\n      // Resolve this.$promise (if present), signaling that activation is done (path 2 of 2)\n      this._resolve();\n    }\n    if (this.$initiator !== this) {\n      (this.parent as Controller)._leaveActivating();\n    }\n  }\n\n  /** @internal */\n  private _detachingStack: number = 0;\n  /** @internal */\n  private _enterDetaching(): void {\n    ++this._detachingStack;\n  }\n  /** @internal */\n  private _leaveDetaching(): void {\n    if (--this._detachingStack === 0) {\n      // Note: this controller is the initiator (detach is only ever called on the initiator)\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`detach()`); }\n\n      this._enterUnbinding();\n      this.removeNodes();\n\n      let cur = this.$initiator.head as Controller | null;\n      let ret: void | Promise<void> = void 0;\n\n      while (cur !== null) {\n        if (cur !== this) {\n          /* istanbul ignore next */\n          if (cur.debug) { cur.logger!.trace(`detach()`); }\n\n          cur.removeNodes();\n        }\n\n        if (cur._isBindingDone) {\n          if (cur.vmKind !== vmkSynth && cur._lifecycleHooks!.unbinding != null) {\n            ret = onResolveAll(...cur._lifecycleHooks!.unbinding.map(callUnbindingHook, cur));\n          }\n\n          if (cur._vmHooks._unbinding) {\n            if (cur.debug) { cur.logger!.trace('unbinding()'); }\n\n            ret = onResolveAll(ret, cur.viewModel!.unbinding(cur.$initiator, cur.parent));\n          }\n        }\n\n        if (isPromise(ret)) {\n          this._ensurePromise();\n          this._enterUnbinding();\n          ret.then(() => {\n            this._leaveUnbinding();\n          }).catch((err: Error) => {\n            this._reject(err);\n          });\n        }\n\n        ret = void 0;\n\n        cur = cur.next as Controller;\n      }\n\n      this._leaveUnbinding();\n    }\n  }\n\n  /** @internal */\n  private _unbindingStack: number = 0;\n  /** @internal */\n  private _enterUnbinding(): void {\n    ++this._unbindingStack;\n  }\n  /** @internal */\n  private _leaveUnbinding(): void {\n    if (--this._unbindingStack === 0) {\n      /* istanbul ignore next */\n      if (__DEV__ && this.debug) { this.logger!.trace(`unbind()`); }\n\n      let cur = this.$initiator.head as Controller | null;\n      let next: Controller | null = null;\n      while (cur !== null) {\n        if (cur !== this) {\n          cur._isBindingDone = false;\n          cur.isBound = false;\n          cur.unbind();\n        }\n        next = cur.next as Controller;\n        cur.next = null;\n        cur = next;\n      }\n\n      this.head = this.tail = null;\n      this._isBindingDone = false;\n      this.isBound = false;\n      this.unbind();\n    }\n  }\n\n  public addBinding(binding: IBinding): void {\n    if (this.bindings === null) {\n      this.bindings = [binding];\n    } else {\n      this.bindings[this.bindings.length] = binding;\n    }\n  }\n\n  public addChild(controller: Controller): void {\n    if (this.children === null) {\n      this.children = [controller];\n    } else {\n      this.children[this.children.length] = controller;\n    }\n  }\n\n  public is(name: string): boolean {\n    switch (this.vmKind) {\n      case vmkCa:\n      case vmkCe: {\n        return (this.definition as ResourceDefinition).name === name;\n      }\n      case vmkSynth:\n        return this.viewFactory!.name === name;\n    }\n  }\n\n  public lockScope(scope: Writable<Scope>): void {\n    this.scope = scope;\n    this.hasLockedScope = true;\n  }\n\n  public setHost(host: HTMLElement): this {\n    if (this.vmKind === vmkCe) {\n      setRef(host, elementBaseName, this as IHydratedController);\n      setRef(host, this.definition!.key, this as IHydratedController);\n    }\n    this.host = host;\n    this.mountTarget = targetHost;\n    return this;\n  }\n\n  public setShadowRoot(shadowRoot: ShadowRoot): this {\n    if (this.vmKind === vmkCe) {\n      setRef(shadowRoot, elementBaseName, this as IHydratedController);\n      setRef(shadowRoot, this.definition!.key, this as IHydratedController);\n    }\n    this.shadowRoot = shadowRoot;\n    this.mountTarget = targetShadowRoot;\n    return this;\n  }\n\n  public setLocation(location: IRenderLocation): this {\n    if (this.vmKind === vmkCe) {\n      setRef(location, elementBaseName, this as IHydratedController);\n      setRef(location, this.definition!.key, this as IHydratedController);\n    }\n    this.location = location;\n    this.mountTarget = targetLocation;\n    return this;\n  }\n\n  public release(): void {\n    this.state |= released;\n  }\n\n  public dispose(): void {\n    /* istanbul ignore next */\n    if (__DEV__ && this.debug) { this.logger!.trace(`dispose()`); }\n\n    if ((this.state & disposed) === disposed) {\n      return;\n    }\n    this.state |= disposed;\n\n    if (this._vmHooks._dispose) {\n      this._vm!.dispose();\n    }\n\n    if (this.children !== null) {\n      this.children.forEach(callDispose);\n      this.children = null;\n    }\n\n    this.scope = null;\n\n    this.nodes = null;\n    this.location = null;\n\n    this.viewFactory = null;\n    if (this._vm !== null) {\n      controllerLookup.delete(this._vm);\n      this._vm = null;\n    }\n    this._vm = null;\n    this.host = null;\n    this.shadowRoot = null;\n    this.container.disposeResolvers();\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (visitor(this as IHydratedController) === true) {\n      return true;\n    }\n\n    if (this._vmHooks._accept && this._vm!.accept(visitor) === true) {\n      return true;\n    }\n\n    if (this.children !== null) {\n      const { children } = this;\n      for (let i = 0, ii = children.length; i < ii; ++i) {\n        if (children[i].accept(visitor) === true) {\n          return true;\n        }\n      }\n    }\n  }\n}\n\nconst controllerLookup: WeakMap<object, Controller> = new WeakMap();\n\nexport type ControllerBindingContext<C extends IViewModel> = Required<ICompileHooks> & Required<IActivationHooks<IHydratedController | null>> & C;\n\nconst targetNone = 0;\nconst targetHost = 1;\nconst targetShadowRoot = 2;\nconst targetLocation = 3;\n\n/**\n * Describes the type of the host node/location of a controller\n * - `none` / 1:       no host\n * - `host` / 2:       an HTML element is the host of a controller\n * - `shadowRoot` / 3: a shadow root is the host of a controller\n * - `location` / 4:   a render location is the location of a controller, this is often used for template controllers\n */\nexport const MountTarget = objectFreeze({\n  none: targetNone,\n  host: targetHost,\n  shadowRoot: targetShadowRoot,\n  location: targetLocation,\n});\nexport type MountTarget = typeof MountTarget[keyof typeof MountTarget];\n\n// const optionalCeFind = { optional: true } as const;\nconst optionalCoercionConfigResolver = optionalResource(ICoercionConfiguration);\n\nfunction createObservers(\n  controller: Controller,\n  definition: CustomElementDefinition | CustomAttributeDefinition,\n  instance: IIndexable<ICustomElementViewModel | ICustomAttributeViewModel>,\n): void {\n  const bindables = definition.bindables;\n  const observableNames = getOwnPropertyNames(bindables);\n  const length = observableNames.length;\n\n  if (length === 0) return;\n\n  const locator = controller.container.get(IObserverLocator);\n  const hasAggregatedCallbacks = 'propertiesChanged' in instance;\n  const coercion = controller.vmKind === vmkSynth\n    ? void 0\n    : controller.container.get(optionalCoercionConfigResolver);\n\n  const queueCallback = hasAggregatedCallbacks\n    ? (() => {\n        let changes: Record<string, { newValue: unknown; oldValue: unknown }> = {};\n        let isQueued = false;\n        let changeCount = 0;\n        const callPropertiesChanged = () => {\n          if (!isQueued) {\n            isQueued = true;\n            queueTask(() => {\n              isQueued = false;\n              const $changes = changes;\n              changes = {};\n              changeCount = 0;\n              if (controller.isBound) {\n                instance.propertiesChanged?.($changes);\n                if (changeCount > 0) {\n                  callPropertiesChanged();\n                }\n              }\n            });\n          }\n        };\n\n        return (key: string, newValue: unknown, oldValue: unknown) => {\n          changes[key] = { newValue, oldValue };\n          changeCount++;\n          callPropertiesChanged();\n        };\n    })()\n    : noop;\n\n  for (let i = 0; i < length; ++i) {\n    const name = observableNames[i];\n    const bindable = bindables[name];\n    const handler = bindable.callback;\n    const obs = locator.getObserver(instance, name);\n\n    if (bindable.set !== noop) {\n      if (obs.useCoercer?.(bindable.set, coercion) !== true) {\n        throw createMappedError(ErrorNames.controller_property_not_coercible, name);\n      }\n    }\n    if (instance[handler] != null\n      || instance.propertyChanged != null\n      || hasAggregatedCallbacks\n    ) {\n      const callback = (newValue: unknown, oldValue: unknown) => {\n        if (controller.isBound) {\n          (instance[handler] as AnyFunction)?.(newValue, oldValue);\n          instance.propertyChanged?.(name, newValue, oldValue);\n          queueCallback(name, newValue, oldValue);\n        }\n      };\n      if (obs.useCallback?.(callback) !== true) {\n        throw createMappedError(ErrorNames.controller_property_no_change_handler, name);\n      }\n    }\n  }\n}\n\nconst AccessScopeAstMap = new Map<PropertyKey, AccessScopeExpression>();\nconst getAccessScopeAst = (key: PropertyKey) => {\n  let ast = AccessScopeAstMap.get(key);\n  if (ast == null) {\n    ast = new AccessScopeExpression(key as string, 0);\n    AccessScopeAstMap.set(key, ast);\n  }\n  return ast;\n};\n\nfunction createWatchers(\n  controller: Controller,\n  context: IServiceLocator,\n  definition: CustomElementDefinition | CustomAttributeDefinition,\n  instance: object,\n) {\n  const observerLocator = context!.get(IObserverLocator);\n  const expressionParser = context.get(IExpressionParser);\n  const watches = definition.watches;\n  const scope: Scope = controller.vmKind === vmkCe\n    ? controller.scope!\n    // custom attribute does not have own scope\n    : Scope.create(instance, null, true);\n  const ii = watches.length;\n  let expression: IWatchDefinition['expression'];\n  let callback: IWatchDefinition['callback'];\n  let ast: IsBindingBehavior;\n  let flush: 'async' | 'sync' | undefined;\n  let i = 0;\n\n  for (; ii > i; ++i) {\n    ({ expression, callback, flush } = watches[i]);\n    callback = isFunction(callback)\n      ? callback\n      : Reflect.get(instance, callback) as IWatcherCallback<object>;\n    if (!isFunction(callback)) {\n      throw createMappedError(ErrorNames.controller_watch_invalid_callback, callback);\n    }\n    if (isFunction(expression)) {\n      controller.addBinding(new ComputedWatcher(\n        instance as IObservable,\n        observerLocator,\n        expression,\n        callback,\n        flush,\n      ));\n    } else {\n      ast = isString(expression)\n        ? expressionParser.parse(expression, etIsProperty)\n        : getAccessScopeAst(expression);\n\n      controller.addBinding(new ExpressionWatcher(\n        scope,\n        context,\n        observerLocator,\n        ast,\n        callback,\n        flush,\n      ) as unknown as IBinding);\n    }\n  }\n}\n\nexport function isCustomElementController<C extends ICustomElementViewModel = ICustomElementViewModel>(value: unknown): value is ICustomElementController<C> {\n  return value instanceof Controller && value.vmKind === vmkCe;\n}\n\nexport function isCustomElementViewModel(value: unknown): value is ICustomElementViewModel {\n  return isElementType(value?.constructor);\n}\n\nclass HooksDefinition {\n  public static readonly none: Readonly<HooksDefinition> = new HooksDefinition({});\n\n  public readonly _define: boolean;\n\n  public readonly _hydrating: boolean;\n  public readonly _hydrated: boolean;\n  public readonly _created: boolean;\n\n  public readonly _binding: boolean;\n  public readonly _bound: boolean;\n  public readonly _attaching: boolean;\n  public readonly _attached: boolean;\n\n  public readonly _detaching: boolean;\n  public readonly _unbinding: boolean;\n\n  public readonly _dispose: boolean;\n  public readonly _accept: boolean;\n\n  public constructor(target: object) {\n    this._define = 'define' in target;\n\n    this._hydrating = 'hydrating' in target;\n    this._hydrated = 'hydrated' in target;\n    this._created = 'created' in target;\n\n    this._binding = 'binding' in target;\n    this._bound = 'bound' in target;\n    this._attaching = 'attaching' in target;\n    this._attached = 'attached' in target;\n\n    this._detaching = 'detaching' in target;\n    this._unbinding = 'unbinding' in target;\n\n    this._dispose = 'dispose' in target;\n    this._accept = 'accept' in target;\n  }\n}\n\nconst defaultShadowOptions = {\n  mode: 'open' as 'open' | 'closed'\n};\n\n/** @internal */ export const vmkCe = 'customElement' as const;\n/** @internal */ export const vmkCa = 'customAttribute' as const;\nconst vmkSynth = 'synthetic' as const;\nexport type ViewModelKind = typeof vmkCe | typeof vmkCa | typeof vmkSynth;\n\n/**\n * A controller that is ready for activation. It can be `ISyntheticView`, `ICustomElementController` or `ICustomAttributeController`.\n *\n * In terms of specificity this is identical to `IController`. The only difference is that this\n * type is further initialized and thus has more properties and APIs available.\n */\nexport type IHydratedController = ISyntheticView | ICustomElementController | ICustomAttributeController;\n/**\n * A controller that is ready for activation. It can be `ICustomElementController` or `ICustomAttributeController`.\n *\n * This type of controller is backed by a real component (hence the name) and therefore has ViewModel and may have lifecycle hooks.\n *\n * In contrast, `ISyntheticView` has neither a view model nor lifecycle hooks (but its child controllers, if any, may).\n */\nexport type IHydratedComponentController = ICustomElementController | ICustomAttributeController;\n/**\n * A controller that is ready for activation. It can be `ISyntheticView` or `ICustomElementController`.\n *\n * This type of controller may have child controllers (hence the name) and bindings directly placed on it during hydration.\n *\n * In contrast, `ICustomAttributeController` has neither child controllers nor bindings directly placed on it (but the backing component may).\n *\n * Note: the parent of a `ISyntheticView` is always a `IHydratedComponentController` because views cannot directly own other views. Views may own components, and components may own views or components.\n */\nexport type IHydratedParentController = ISyntheticView | ICustomElementController;\n\n/**\n * A callback that is invoked on each controller in the component tree.\n *\n * Return `true` to stop traversal.\n */\nexport type ControllerVisitor = (controller: IHydratedController) => void | true;\n\n/**\n * The base type for all controller types.\n *\n * Every controller, regardless of their type and state, will have at least the properties/methods in this interface.\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface IController<C extends IViewModel = IViewModel> extends IDisposable {\n  /**\n   * The container associated with this controller.\n   * By default, CE should have their own container while custom attribute & synthetic view\n   * will use the parent container one, since they do not need to manage one\n   */\n  readonly name: string;\n  readonly container: IContainer;\n  readonly vmKind: ViewModelKind;\n  readonly definition: CustomElementDefinition | CustomAttributeDefinition | null;\n  readonly host: HTMLElement | null;\n  readonly state: State;\n  readonly isActive: boolean;\n  readonly parent: IHydratedController | null;\n  readonly isBound: boolean;\n  readonly bindings: readonly IBinding[] | null;\n\n  addBinding(binding: IBinding): void;\n\n  /** @internal */head: IHydratedController | null;\n  /** @internal */tail: IHydratedController | null;\n  /** @internal */next: IHydratedController | null;\n\n  /**\n   * Return `true` to stop traversal.\n   */\n  accept(visitor: ControllerVisitor): void | true;\n}\n\n/**\n * The base type for `ICustomAttributeController` and `ICustomElementController`.\n *\n * Both of those types have the `viewModel` property which represent the user instance containing the bound properties and hooks for this component.\n */\nexport interface IComponentController<C extends IViewModel = IViewModel> extends IController<C> {\n  readonly vmKind: 'customAttribute' | 'customElement';\n  readonly definition: CustomElementDefinition | CustomAttributeDefinition;\n\n  /**\n   * The user instance containing the bound properties. This is always an instance of a class, which may either be user-defined, or generated by a view locator.\n   */\n  readonly viewModel: C;\n}\n\n/**\n * The base type for `ISyntheticView` and `ICustomElementController`.\n *\n * Both of those types can:\n * - Have `children` which are populated during hydration (hence, 'Hydratable').\n * - Have physical DOM nodes that can be mounted.\n */\nexport interface IHydratableController<C extends IViewModel = IViewModel> extends IController<C> {\n  readonly vmKind: 'customElement' | 'synthetic';\n  readonly mountTarget: MountTarget;\n  readonly definition: CustomElementDefinition | null;\n  readonly strict: boolean | undefined | null;\n\n  readonly children: readonly IHydratedController[] | null;\n\n  addChild(controller: IController): void;\n}\n\n/** @internal */ export const none         = 0b00_00_00;\n/** @internal */ export const activating   = 0b00_00_01;\n/** @internal */ export const activated    = 0b00_00_10;\n/** @internal */ export const deactivating = 0b00_01_00;\n/** @internal */ export const deactivated  = 0b00_10_00;\n/** @internal */ export const released     = 0b01_00_00;\n/** @internal */ export const disposed     = 0b10_00_00;\n\nexport const State = /*@__PURE__*/ objectFreeze({\n  none,\n  activating,\n  activated,\n  deactivating,\n  deactivated,\n  released,\n  disposed,\n});\nexport type State = typeof State[keyof typeof State];\n\nexport function stringifyState(state: State): string {\n  const names: string[] = [];\n\n  if ((state & activating) === activating) { names.push('activating'); }\n  if ((state & activated) === activated) { names.push('activated'); }\n  if ((state & deactivating) === deactivating) { names.push('deactivating'); }\n  if ((state & deactivated) === deactivated) { names.push('deactivated'); }\n  if ((state & released) === released) { names.push('released'); }\n  if ((state & disposed) === disposed) { names.push('disposed'); }\n\n  return names.length === 0 ? 'none' : names.join('|');\n}\n\n/**\n * The controller for a synthetic view, that is, a controller created by an `IViewFactory`.\n *\n * A synthetic view, typically created when composing a template controller (`if`, `repeat`, etc), is a hydratable component with mountable DOM nodes that has no user view model.\n *\n * It has either its own synthetic binding context or is locked to some externally sourced scope (in the case of `au-compose`)\n */\nexport interface ISyntheticView extends IHydratableController {\n  readonly vmKind: 'synthetic';\n  readonly definition: null;\n  readonly viewModel: null;\n  /**\n   * The physical DOM nodes that will be appended during the attach operation.\n   */\n  readonly nodes: INodeSequence;\n\n  activate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n    scope: Scope,\n  ): void | Promise<void>;\n  deactivate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n  ): void | Promise<void>;\n  /**\n   * Lock this view's scope to the provided `Scope`. The scope, which is normally set during `activate()`, will then not change anymore.\n   *\n   * This is used by `au-render` to set the binding context of a view to a particular component instance.\n   *\n   * @param scope - The scope to lock this view to.\n   */\n  lockScope(scope: Scope): void;\n  /**\n   * The scope that belongs to this view. This property will always be defined when the `state` property of this view indicates that the view is currently bound.\n   *\n   * The `scope` may be set during `activate()` and unset during `deactivate()`, or it may be statically set during composing with `lockScope()`.\n   */\n  readonly scope: Scope;\n\n  /**\n   * Set the render location that this view will be inserted before.\n   */\n  setLocation(location: IRenderLocation): this;\n  /**\n   * The DOM node that this view will be inserted before (if set).\n   */\n  readonly location: IRenderLocation | null;\n\n  /**\n   * Set the host that this view will be appended to.\n   */\n  setHost(host: Node & ParentNode): this;\n  /**\n   * The DOM node that this view will be appended to (if set).\n   */\n  readonly host: HTMLElement | null;\n\n  /**\n   * Set the `ShadowRoot` that this view will be appended to.\n   */\n  setShadowRoot(shadowRoot: ShadowRoot): this;\n  /**\n   * The ShadowRoot that this view will be appended to (if set).\n   */\n  readonly shadowRoot: ShadowRoot | null;\n\n  /**\n   * Mark this view as not-in-use, so that it can either be disposed or returned to cache after finishing the deactivate lifecycle.\n   *\n   * If this view is cached and later retrieved from the cache, it will be marked as in-use again before starting the activate lifecycle, so this method must be called each time.\n   *\n   * If this method is *not* called before `deactivate()`, this view will neither be cached nor disposed.\n   */\n  release(): void;\n}\n\nexport interface ICustomAttributeController<C extends ICustomAttributeViewModel = ICustomAttributeViewModel> extends IComponentController<C> {\n  readonly vmKind: 'customAttribute';\n  readonly definition: CustomAttributeDefinition;\n  /**\n   * @inheritdoc\n   */\n  readonly viewModel: C;\n  readonly lifecycleHooks: LifecycleHooksLookup;\n  /**\n   * The scope that belongs to this custom attribute. This property will always be defined when the `state` property of this view indicates that the view is currently bound.\n   *\n   * The `scope` will be set during `activate()` and unset during `deactivate()`.\n   *\n   * The scope's `bindingContext` will be the same instance as this controller's `viewModel` property.\n   */\n  readonly scope: Scope;\n  readonly children: null;\n  readonly bindings: null;\n  activate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n    scope: Scope,\n  ): void | Promise<void>;\n  deactivate(\n    initiator: IHydratedController,\n    parent: IHydratedController,\n  ): void | Promise<void>;\n}\n\n/**\n * A representation of `IController` specific to a custom element whose `create` hook is about to be invoked (if present).\n *\n * It is not yet hydrated (hence 'dry') with any render-specific information.\n */\nexport interface IDryCustomElementController<C extends IViewModel = IViewModel> extends IComponentController<C>, IHydratableController<C> {\n  readonly vmKind: 'customElement';\n  readonly definition: CustomElementDefinition;\n  readonly strict: boolean | undefined | null;\n  /**\n   * The scope that belongs to this custom element. This property is set immediately after the controller is created and is always guaranteed to be available.\n   *\n   * It may be overwritten by end user during the `create()` hook.\n   *\n   * By default, the scope's `bindingContext` will be the same instance as this controller's `viewModel` property.\n   */\n  scope: Scope;\n  /**\n   * The original host dom node.\n   *\n   * For containerless elements, this node will be removed from the DOM and replaced by a comment, which is assigned to the `location` property.\n   *\n   * For ShadowDOM elements, this will be the original declaring element, NOT the shadow root (the shadow root is stored on the `shadowRoot` property)\n   */\n  readonly host: HTMLElement;\n}\n\n/**\n * A representation of `IController` specific to a custom element whose `hydrating` hook is about to be invoked (if present).\n *\n * It has the same properties as `IDryCustomElementController`, as well as a render context (hence 'contextual').\n */\nexport interface IContextualCustomElementController<C extends IViewModel = IViewModel> extends IDryCustomElementController<C> {\n\n}\n\n/**\n * A representation of `IController` specific to a custom element whose `hydrated` hook is about to be invoked (if present).\n *\n * It has the same properties as `IContextualCustomElementController`, except the context is now compiled (hence 'compiled'), as well as the nodes, and projector.\n */\nexport interface ICompiledCustomElementController<C extends IViewModel = IViewModel> extends IContextualCustomElementController<C> {\n  /**\n   * The ShadowRoot, if this custom element uses ShadowDOM.\n   */\n  readonly shadowRoot: ShadowRoot | null;\n  /**\n   * The renderLocation, if this is a `containerless` custom element.\n   */\n  readonly location: IRenderLocation | null;\n  /**\n   * The physical DOM nodes that will be appended during the `mount()` operation.\n   */\n  readonly nodes: INodeSequence;\n}\n\n/**\n * A fully hydrated custom element controller.\n */\nexport interface ICustomElementController<C extends ICustomElementViewModel = ICustomElementViewModel> extends ICompiledCustomElementController<C> {\n  /**\n   * @inheritdoc\n   */\n  readonly viewModel: C;\n  readonly lifecycleHooks: LifecycleHooksLookup;\n\n  activate(\n    initiator: IHydratedController,\n    parent: IHydratedController | null,\n    scope?: Scope,\n  ): void | Promise<void>;\n  deactivate(\n    initiator: IHydratedController,\n    parent: IHydratedController | null,\n  ): void | Promise<void>;\n}\n\nexport const IController = /*@__PURE__*/createInterface<IController>('IController');\n\nexport const IHydrationContext = /*@__PURE__*/createInterface<IHydrationContext>('IHydrationContext');\nexport interface IHydrationContext<T extends ICustomElementViewModel = ICustomElementViewModel> {\n  readonly controller: ICustomElementController<T>;\n  readonly instruction: IControllerElementHydrationInstruction | null;\n  readonly parent: IHydrationContext | undefined;\n}\n\n/** @internal */\nexport class HydrationContext<T extends ICustomElementViewModel> implements IHydrationContext<T> {\n  public readonly controller: ICustomElementController<T>;\n  public constructor(\n    controller: ICustomElementController,\n    public readonly instruction: IControllerElementHydrationInstruction | null,\n    public readonly parent: IHydrationContext | undefined,\n  ) {\n    this.controller = controller as ICustomElementController<T>;\n  }\n}\n\nexport interface IActivationHooks<TParent> {\n  binding?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  bound?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  attaching?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  attached?(\n    initiator: IHydratedController,\n  ): void | Promise<void>;\n\n  detaching?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n  unbinding?(\n    initiator: IHydratedController,\n    parent: TParent,\n  ): void | Promise<void>;\n\n  dispose?(): void;\n  /**\n   * If this component controls the instantiation and lifecycles of one or more controllers,\n   * implement this hook to enable component tree traversal for plugins that use it (such as the router).\n   *\n   * Return `true` to stop traversal.\n   */\n  accept?(visitor: ControllerVisitor): void | true;\n}\n\nexport interface ICompileHooks {\n  define?(\n    controller: IDryCustomElementController<this>,\n    /**\n     * The context where this element is hydrated.\n     *\n     * This is created by the controller associated with the CE creating this this controller\n     */\n    hydrationContext: IHydrationContext | null,\n    definition: CustomElementDefinition,\n  ): PartialCustomElementDefinition | void;\n  hydrating?(\n    controller: IContextualCustomElementController<this>,\n  ): void;\n  hydrated?(\n    controller: ICompiledCustomElementController<this>,\n  ): void;\n  created?(\n    controller: ICustomElementController<this> | ICustomAttributeController<this>,\n  ): void;\n}\n\n/**\n * Defines optional lifecycle hooks that will be called only when they are implemented.\n */\nexport interface IViewModel {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  constructor: Function;\n  readonly $controller?: IController<this>;\n}\n\nexport interface ICustomElementViewModel extends IViewModel, IActivationHooks<IHydratedController | null>, ICompileHooks {\n  readonly $controller?: ICustomElementController<this>;\n  created?(\n    controller: ICustomElementController<this>,\n  ): void;\n  propertyChanged?(key: PropertyKey, newValue: unknown, oldValue: unknown): void;\n  propertiesChanged?(changes: Record<string, { newValue: unknown; oldValue: unknown }>): void;\n}\n\nexport interface ICustomAttributeViewModel extends IViewModel, IActivationHooks<IHydratedController> {\n  readonly $controller?: ICustomAttributeController<this>;\n  link?(\n    controller: IHydratableController,\n    childController: ICustomAttributeController,\n    target: INode,\n    instruction: IInstruction,\n  ): void;\n  created?(\n    controller: ICustomAttributeController<this>,\n  ): void;\n  propertyChanged?(key: PropertyKey, newValue: unknown, oldValue: unknown): void;\n  propertiesChanged?(changes: Record<string, { newValue: unknown; oldValue: unknown }>): void;\n}\n\nexport interface IHydratedCustomElementViewModel extends ICustomElementViewModel {\n  readonly $controller: ICustomElementController<this>;\n}\n\nexport interface IHydratedCustomAttributeViewModel extends ICustomAttributeViewModel {\n  readonly $controller: ICustomAttributeController<this>;\n}\n\nexport interface IControllerElementHydrationInstruction {\n  /**\n   * An internal mechanism to manually halt + resume hydration process\n   *\n   * - 0: no hydration\n   * - 1: hydrate until define() lifecycle\n   *\n   * @internal\n   */\n  readonly hydrate?: boolean;\n  readonly projections: Record<string, PartialCustomElementDefinition> | null;\n  /**\n   * A list of captured attributes/binding in raw format\n   */\n  readonly captures?: AttrSyntax[];\n  /**\n   * Indicates whether the custom element was used with \"containerless\" attribute\n   */\n  readonly containerless?: boolean;\n}\n\nfunction callDispose(disposable: IDisposable): void {\n  disposable.dispose();\n}\n\nfunction callCreatedHook(this: Controller, l: LifecycleHooksEntry<ICompileHooks, 'created'>) {\n  l.instance.created(this._vm!, this as IHydratedComponentController);\n}\n\nfunction callHydratingHook(this: Controller, l: LifecycleHooksEntry<ICompileHooks, 'hydrating'>) {\n  l.instance.hydrating(this._vm!, this as IContextualCustomElementController<ICompileHooks>);\n}\n\nfunction callHydratedHook(this: Controller, l: LifecycleHooksEntry<ICompileHooks, 'hydrated'>) {\n  l.instance.hydrated(this._vm!, this as ICompiledCustomElementController<ICompileHooks>);\n}\n\nfunction callBindingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'binding'>) {\n  return l.instance.binding(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callBoundHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'bound'>) {\n  return l.instance.bound(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callAttachingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'attaching'>) {\n  return l.instance.attaching(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callAttachedHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'attached'>) {\n  return l.instance.attached(this._vm!, this['$initiator']);\n}\n\nfunction callDetachingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'detaching'>) {\n  return l.instance.detaching(this._vm!, this['$initiator'], this.parent!);\n}\n\nfunction callUnbindingHook(this: Controller, l: LifecycleHooksEntry<IActivationHooks<IHydratedController>, 'unbinding'>) {\n  return l.instance.unbinding(this._vm!, this['$initiator'], this.parent!);\n}\n\n// some reuseable variables to avoid creating nested blocks inside hot paths of controllers\nlet _resolve: undefined | (() => unknown);\nlet _reject: undefined | ((err: unknown) => unknown);\nlet _retPromise: void | Promise<void>;\n\nconst setRef = refs.set;\n", "import { IContainer, IResolver, InstanceProvider, emptyArray } from '@aurelia/kernel';\nimport { IAppRoot } from './app-root';\nimport { IPlatform } from './platform';\nimport { findElementControllerFor } from './resources/custom-element';\nimport { MountTarget } from './templating/controller';\nimport { createInterface, registerResolver } from './utilities-di';\nimport { INode } from './dom.node';\n\nexport type IEventTarget<T extends EventTarget = EventTarget> = T;\nexport const IEventTarget = /*@__PURE__*/createInterface<IEventTarget>('IEventTarget', x => x.cachedCallback(handler => {\n  if (handler.has(IAppRoot, true)) {\n    return handler.get(IAppRoot).host;\n  }\n  return handler.get(IPlatform).document;\n}));\n\n/**\n * An interface describing a marker.\n * Components can use this to anchor where their content should be rendered in place of a host element.\n */\nexport const IRenderLocation = /*@__PURE__*/createInterface<IRenderLocation>('IRenderLocation');\nexport type IRenderLocation<T extends ChildNode = ChildNode> = T & {\n  $start?: IRenderLocation<T>;\n};\n\n/** @internal */\nexport const ICssClassMapping = /*@__PURE__*/createInterface<Record<string, string>>('ICssClassMapping');\n/** @internal */\nexport const cssMappings: IResolver<Record<string, string>[]> = {\n  $isResolver: true,\n  resolve(_, requestor) {\n    if (requestor.has(ICssClassMapping, false)) {\n      return requestor.getAll(ICssClassMapping);\n    }\n    return emptyArray;\n  }\n};\n\n/**\n * Represents a DocumentFragment with a memory of what it has.\n * This is known as many names, a live fragment for example.\n *\n * Relevant discussion at https://github.com/whatwg/dom/issues/736\n */\nexport interface INodeSequence<T extends INode = INode> {\n  readonly platform: IPlatform;\n\n  readonly next?: INodeSequence<T>;\n\n  /**\n   * The nodes of this sequence.\n   */\n  readonly childNodes: ArrayLike<T>;\n\n  readonly firstChild: T | null;\n\n  readonly lastChild: T | null;\n\n  /**\n   * Find all instruction targets in this sequence.\n   */\n  findTargets(): ArrayLike<T>;\n\n  /**\n   * Insert this sequence as a sibling before refNode\n   */\n  insertBefore(refNode: T | IRenderLocation): void;\n\n  /**\n   * Append this sequence as a child to parent\n   */\n  appendTo(parent: T, enhance?: boolean): void;\n\n  /**\n   * Remove this sequence from the DOM.\n   */\n  remove(): void;\n\n  addToLinked(): void;\n\n  unlink(): void;\n\n  link(next: INodeSequence<T> | IRenderLocation | undefined): void;\n}\n\n_START_CONST_ENUM();\nconst enum NodeType {\n  Element = 1,\n  Attr = 2,\n  Text = 3,\n  CDATASection = 4,\n  EntityReference = 5,\n  Entity = 6,\n  ProcessingInstruction = 7,\n  Comment = 8,\n  Document = 9,\n  DocumentType = 10,\n  DocumentFragment = 11,\n  Notation = 12\n}\n_END_CONST_ENUM();\n\nconst effectiveParentNodeOverrides = new WeakMap<Node, Node>();\n\n/**\n * Returns the effective parentNode according to Aurelia's component hierarchy.\n *\n * Used by Aurelia to find the closest parent controller relative to a node.\n *\n * This method supports 3 additional scenarios that `node.parentNode` does not support:\n * - Containerless elements. The parentNode in this case is a comment precending the element under specific conditions, rather than a node wrapping the element.\n * - ShadowDOM. If a `ShadowRoot` is encountered, this method retrieves the associated controller via the metadata api to locate the original host.\n * - Portals. If the provided node was moved to a different location in the DOM by a `portal` attribute, then the original parent of the node will be returned.\n *\n * @param node - The node to get the parent for.\n * @returns Either the closest parent node, the closest `IRenderLocation` (comment node that is the containerless host), original portal host, or `null` if this is either the absolute document root or a disconnected node.\n */\nexport function getEffectiveParentNode(node: Node): Node | null {\n  // TODO: this method needs more tests!\n  // First look for any overrides\n  if (effectiveParentNodeOverrides.has(node)) {\n    return effectiveParentNodeOverrides.get(node)!;\n  }\n\n  // Then try to get the nearest au-start render location, which would be the containerless parent,\n  // again looking for any overrides along the way.\n  // otherwise return the normal parent node\n  let containerlessOffset = 0;\n  let next = node.nextSibling;\n  while (next !== null) {\n    if (next.nodeType === NodeType.Comment) {\n      switch (next.textContent) {\n        case 'au-start':\n          // If we see an au-start before we see au-end, it will precede the host of a sibling containerless element rather than a parent.\n          // So we use the offset to ignore the next au-end\n          ++containerlessOffset;\n          break;\n        case 'au-end':\n          if (containerlessOffset-- === 0) {\n            return next;\n          }\n      }\n    }\n    next = next.nextSibling;\n  }\n\n  if (node.parentNode === null && node.nodeType === NodeType.DocumentFragment) {\n    // Could be a shadow root; see if there's a controller and if so, get the original host via the projector\n    const controller = findElementControllerFor(node, { optional: true });\n    if (controller == null) {\n      // Not a shadow root (or at least, not one created by Aurelia)\n      // Nothing more we can try, just return null\n      return null;\n    }\n    if (controller.mountTarget === MountTarget.shadowRoot) {\n      return getEffectiveParentNode(controller.host);\n    }\n  }\n\n  return node.parentNode;\n}\n\n/**\n * Set the effective parentNode, overriding the DOM-based structure that `getEffectiveParentNode` otherwise defaults to.\n *\n * Used by Aurelia's `portal` template controller to retain the linkage between the portaled nodes (after they are moved to the portal target) and the original `portal` host.\n *\n * @param nodeSequence - The node sequence whose children that, when `getEffectiveParentNode` is called on, return the supplied `parentNode`.\n * @param parentNode - The node to return when `getEffectiveParentNode` is called on any child of the supplied `nodeSequence`.\n */\nexport function setEffectiveParentNode(nodeSequence: INodeSequence, parentNode: Node): void;\n/**\n * Set the effective parentNode, overriding the DOM-based structure that `getEffectiveParentNode` otherwise defaults to.\n *\n * Used by Aurelia's `portal` template controller to retain the linkage between the portaled nodes (after they are moved to the portal target) and the original `portal` host.\n *\n * @param childNode - The node that, when `getEffectiveParentNode` is called on, returns the supplied `parentNode`.\n * @param parentNode - The node to return when `getEffectiveParentNode` is called on the supplied `childNode`.\n */\nexport function setEffectiveParentNode(childNode: Node, parentNode: Node): void;\nexport function setEffectiveParentNode(childNodeOrNodeSequence: Node | INodeSequence, parentNode: Node): void {\n  if ((childNodeOrNodeSequence as INodeSequence).platform !== void 0 && !(childNodeOrNodeSequence instanceof (childNodeOrNodeSequence as INodeSequence).platform.Node)) {\n    const nodes = childNodeOrNodeSequence.childNodes;\n    for (let i = 0, ii = nodes.length; i < ii; ++i) {\n      effectiveParentNodeOverrides.set(nodes[i] as Node, parentNode);\n    }\n  } else {\n    effectiveParentNodeOverrides.set(childNodeOrNodeSequence as Node, parentNode);\n  }\n}\n\nexport function convertToRenderLocation(node: Node): IRenderLocation {\n  if (isRenderLocation(node)) {\n    return node; // it's already a IRenderLocation (converted by FragmentNodeSequence)\n  }\n\n  const locationEnd = node.ownerDocument!.createComment('au-end') as IRenderLocation;\n  const locationStart = locationEnd.$start = node.ownerDocument!.createComment('au-start') as IRenderLocation;\n  const parentNode = node.parentNode;\n\n  if (parentNode !== null) {\n    parentNode.replaceChild(locationEnd, node);\n    parentNode.insertBefore(locationStart, locationEnd);\n  }\n\n  return locationEnd;\n}\n\nexport function isRenderLocation(node: INode | INodeSequence): node is IRenderLocation {\n  return (node as Comment).textContent === 'au-end';\n}\n\nexport class FragmentNodeSequence implements INodeSequence {\n  /** @internal */\n  private readonly _firstChild: Node | null;\n  public get firstChild(): Node | null {\n    return this._firstChild;\n  }\n\n  /** @internal */\n  private readonly _lastChild: Node | null;\n  public get lastChild(): Node | null {\n    return this._lastChild;\n  }\n\n  public childNodes: Node[];\n\n  public next?: INodeSequence = void 0;\n\n  /** @internal */\n  private _isMounted: boolean = false;\n\n  /** @internal */\n  private _isLinked: boolean = false;\n\n  /** @internal */\n  private ref?: Node | null = null;\n\n  /** @internal */\n  private readonly t: ArrayLike<Node>;\n\n  /** @internal */\n  private readonly f: DocumentFragment;\n\n  public constructor(\n    public readonly platform: IPlatform,\n    fragment: DocumentFragment,\n  ) {\n    const targetNodeList = (this.f = fragment).querySelectorAll('au-m');\n    let i = 0;\n    let ii = targetNodeList.length;\n    // eslint-disable-next-line\n    let targets = this.t = Array(ii);\n    let target: Node | IRenderLocation;\n    let marker: Element;\n\n    while (ii > i) {\n      marker = targetNodeList[i];\n      target = marker.nextSibling!;\n      marker.remove();\n      if (target.nodeType === 8) {\n        marker = target as Element;\n        (target = target.nextSibling as IRenderLocation).$start = marker as unknown as Comment;\n      }\n      targets[i] = target;\n      ++i;\n    }\n\n    const childNodeList = fragment.childNodes;\n    const childNodes = this.childNodes = Array(ii = childNodeList.length) as Node[];\n    i = 0;\n    while (ii > i) {\n      childNodes[i] = childNodeList[i];\n      ++i;\n    }\n\n    this._firstChild = fragment.firstChild;\n    this._lastChild = fragment.lastChild;\n  }\n\n  public findTargets(): ArrayLike<Node> {\n    return this.t;\n  }\n\n  public insertBefore(refNode: IRenderLocation & Comment): void {\n    if (this._isLinked && !!this.ref) {\n      this.addToLinked();\n    } else {\n      const parent = refNode.parentNode!;\n      if (this._isMounted) {\n        let current = this._firstChild;\n        let next: Node;\n        const end = this._lastChild;\n\n        while (current != null) {\n          next = current.nextSibling!;\n          parent.insertBefore(current, refNode);\n\n          if (current === end) {\n            break;\n          }\n\n          current = next;\n        }\n      } else {\n        this._isMounted = true;\n        refNode.parentNode!.insertBefore(this.f, refNode);\n      }\n    }\n  }\n\n  public appendTo(parent: Node, enhance: boolean = false): void {\n    if (this._isMounted) {\n      let current = this._firstChild;\n      let next: Node;\n      const end = this._lastChild;\n\n      while (current != null) {\n        next = current.nextSibling!;\n        parent.appendChild(current);\n\n        if (current === end) {\n          break;\n        }\n\n        current = next;\n      }\n    } else {\n      this._isMounted = true;\n      if (!enhance) {\n        parent.appendChild(this.f);\n      }\n    }\n  }\n\n  public remove(): void {\n    if (this._isMounted) {\n      this._isMounted = false;\n\n      const fragment = this.f;\n      const end = this._lastChild;\n      let next: Node;\n\n      let current = this._firstChild;\n      while (current !== null) {\n        next = current.nextSibling!;\n        fragment.appendChild(current);\n\n        if (current === end) {\n          break;\n        }\n\n        current = next;\n      }\n    }\n  }\n\n  public addToLinked(): void {\n    const refNode = this.ref!;\n    const parent = refNode.parentNode!;\n    if (this._isMounted) {\n      let current = this._firstChild;\n      let next: Node;\n      const end = this._lastChild;\n\n      while (current != null) {\n        next = current.nextSibling!;\n        parent.insertBefore(current, refNode);\n\n        if (current === end) {\n          break;\n        }\n\n        current = next;\n      }\n    } else {\n      this._isMounted = true;\n      parent.insertBefore(this.f, refNode);\n    }\n  }\n\n  public unlink(): void {\n    this._isLinked = false;\n    this.next = void 0;\n    this.ref = void 0;\n  }\n\n  public link(next: INodeSequence | IRenderLocation & Comment | undefined): void {\n    this._isLinked = true;\n    if (isRenderLocation(next!)) {\n      this.ref = next;\n    } else {\n      this.next = next;\n      this._obtainRefNode();\n    }\n  }\n\n  /** @internal */\n  private _obtainRefNode(): void {\n    if (this.next !== void 0) {\n      this.ref = this.next.firstChild;\n    } else {\n      this.ref = void 0;\n    }\n  }\n}\n\nexport const IWindow = /*@__PURE__*/createInterface<IWindow>('IWindow', x => x.callback(handler => handler.get(IPlatform).window));\nexport interface IWindow extends Window { }\n\nexport const ILocation = /*@__PURE__*/createInterface<ILocation>('ILocation', x => x.callback(handler => handler.get(IWindow).location));\nexport interface ILocation extends Location { }\n\nexport const IHistory = /*@__PURE__*/createInterface<IHistory>('IHistory', x => x.callback(handler => handler.get(IWindow).history));\n// NOTE: `IHistory` is documented\n/**\n * https://developer.mozilla.org/en-US/docs/Web/API/History\n *\n * A convenience interface that (unless explicitly overridden in DI) resolves directly to the native browser `history` object.\n *\n * Allows manipulation of the browser session history, that is the pages visited in the tab or frame that the current page is loaded in.\n */\nexport interface IHistory extends History {\n  /**\n   * Returns an integer representing the number of elements in the session history, including the currently loaded page.\n   * For example, for a page loaded in a new tab this property returns 1.\n   */\n  readonly length: number;\n  /**\n   * Allows web applications to explicitly set default scroll restoration behavior on history navigation.\n   *\n   * - `auto` The location on the page to which the user has scrolled will be restored.\n   * - `manual` The location on the page is not restored. The user will have to scroll to the location manually.\n   */\n  scrollRestoration: ScrollRestoration;\n  /**\n   * Returns a value representing the state at the top of the history stack.\n   * This is a way to look at the state without having to wait for a popstate event\n   */\n  readonly state: unknown;\n  /**\n   * Causes the browser to move back one page in the session history.\n   * It has the same effect as calling history.go(-1).\n   * If there is no previous page, this method call does nothing.\n   *\n   * This method is asynchronous.\n   * Add a listener for the `popstate` event in order to determine when the navigation has completed.\n   */\n  back(): void;\n  /**\n   * Causes the browser to move forward one page in the session history.\n   * It has the same effect as calling `history.go(1)`.\n   *\n   * This method is asynchronous.\n   * Add a listener for the `popstate` event in order to determine when the navigation has completed.\n   */\n  forward(): void;\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/History/go\n   *\n   * Loads a specific page from the session history.\n   * You can use it to move forwards and backwards through the history depending on the value of a parameter.\n   *\n   * This method is asynchronous.\n   * Add a listener for the `popstate` event in order to determine when the navigation has completed.\n   *\n   * @param delta - The position in the history to which you want to move, relative to the current page.\n   * A negative value moves backwards, a positive value moves forwards.\n   * So, for example, `history.go(2)` moves forward two pages and `history.go(-2)` moves back two pages.\n   * If no value is passed or if `delta` equals 0, it has the same result as calling `location.reload()`.\n   */\n  go(delta?: number): void;\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/History/pushState\n   *\n   * Adds a state to the browser's session history stack.\n   *\n   * @param state - An object which is associated with the new history entry created by `pushState`.\n   * Whenever the user navigates to the new state, a `popstate` event is fired, and the state property of the event contains a copy of the history entry's state object.\n   * The state object can be anything that can be serialized.\n   * @param title - Most browsers currently ignores this parameter, although they may use it in the future.\n   * Passing the empty string here should be safe against future changes to the method.\n   * Alternatively, you could pass a short title for the state.\n   * @param url - The new history entry's URL is given by this parameter.\n   * Note that the browser won't attempt to load this URL after a call to pushState(), but it might attempt to load the URL later, for instance after the user restarts the browser.\n   * The new URL does not need to be absolute; if it's relative, it's resolved relative to the current URL.\n   * The new URL must be of the same origin as the current URL; otherwise, pushState() will throw an exception.\n   * If this parameter isn't specified, it's set to the document's current URL.\n   */\n  pushState(state: {} | null, title: string, url?: string | null): void;\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n   *\n   * Modifies the current history entry, replacing it with the stateObj, title, and URL passed in the method parameters.\n   *\n   * This method is particularly useful when you want to update the state object or URL of the current history entry in response to some user action.\n   *\n   * @param state - An object which is associated with the history entry passed to the `replaceState` method.\n   * @param title - Most browsers currently ignores this parameter, although they may use it in the future.\n   * Passing the empty string here should be safe against future changes to the method.\n   * Alternatively, you could pass a short title for the state.\n   * @param url - The URL of the history entry.\n   * The new URL must be of the same origin as the current URL; otherwise `replaceState` throws an exception.\n   */\n  replaceState(state: {} | null, title: string, url?: string | null): void;\n}\n\n/**\n * An utility to register a host node with the container with all the commonly used keys.\n */\nexport const registerHostNode = (container: IContainer, host: INode | null, platform = container.get(IPlatform)) => {\n  registerResolver(\n    container,\n    platform.HTMLElement,\n    registerResolver(\n      container,\n      platform.Element,\n      registerResolver(container, INode, new InstanceProvider('ElementResolver', host))\n    )\n  );\n  return container;\n};\n", "import {\n  mergeArrays,\n  fromDefinitionOrDefault,\n  pascalCase,\n  fromAnnotationOrTypeOrDefault,\n  fromAnnotationOrDefinitionOrTypeOrDefault,\n  emptyArray,\n  resourceBaseName,\n  getResourceKeyFor,\n  isFunction,\n  isString,\n  isSymbol,\n} from '@aurelia/kernel';\nimport { Bindable } from '../bindable';\nimport { getEffectiveParentNode } from '../dom';\nimport { refs } from '../dom.node';\nimport { Watch } from '../watch';\nimport { defineMetadata, getAnnotationKeyFor, getMetadata, hasMetadata } from '../utilities-metadata';\nimport { def, objectAssign, objectFreeze } from '../utilities';\nimport { aliasRegistration, singletonRegistration } from '../utilities-di';\n\nimport type {\n  Constructable,\n  IContainer,\n  ResourceType,\n  PartialResourceDefinition,\n  Key,\n  ResourceDefinition,\n  IResolver,\n  Writable,\n  StaticResourceType,\n  InterfaceSymbol,\n} from '@aurelia/kernel';\nimport type { BindableDefinition } from '../bindable';\nimport type { INode } from '../dom.node';\nimport type { Controller, ICustomElementViewModel, ICustomElementController } from '../templating/controller';\nimport { ProcessContentHook, type IElementComponentDefinition, IInstruction } from '@aurelia/template-compiler';\nimport type { IWatchDefinition } from '../watch';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { dtElement, getDefinitionFromStaticAu, type IResourceKind } from './resources-shared';\n\nexport type PartialCustomElementDefinition<TBindables extends string = string> = PartialResourceDefinition<Omit<IElementComponentDefinition<TBindables>, 'type'> & {\n  /**\n   * An semi internal property used to signal the rendering process not to try to compile the template again\n   */\n  readonly injectable?: InterfaceSymbol | null;\n  readonly enhance?: boolean;\n  readonly watches?: IWatchDefinition[];\n  readonly strict?: boolean;\n}>;\n\nexport type CustomElementStaticAuDefinition<TBindables extends string = string> = PartialCustomElementDefinition<TBindables> & {\n  type: 'custom-element';\n};\n\nexport type CustomElementType<C extends Constructable = Constructable> = ResourceType<C, ICustomElementViewModel & (C extends Constructable<infer P> ? P : object), PartialCustomElementDefinition>;\nexport type CustomElementKind = IResourceKind & {\n  /**\n   * Returns the closest controller that is associated with either this node (if it is a custom element) or the first\n   * parent node (including containerless) that is a custom element.\n   *\n   * As long as the provided node was directly or indirectly created by Aurelia, this method is guaranteed to return a controller.\n   *\n   * @param node - The node relative to which to get the closest controller.\n   * @param searchParents - Also search the parent nodes (including containerless).\n   * @returns The closest controller relative to the provided node.\n   * @throws - If neither the node or any of its effective parent nodes host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { searchParents: true }): ICustomElementController<C>;\n  /**\n   * Returns the controller that is associated with this node, if it is a custom element with the provided name.\n   *\n   * @param node - The node to retrieve the controller for, if it is a custom element with the provided name.\n   * @returns The controller associated with the provided node, if it is a custom element with the provided name, or otherwise `undefined`.\n   * @throws - If the node does not host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { name: string }): ICustomElementController<C> | undefined;\n  /**\n   * Returns the closest controller that is associated with either this node (if it is a custom element) or the first\n   * parent node (including containerless) that is a custom element with the provided name.\n   *\n   * @param node - The node relative to which to get the closest controller of a custom element with the provided name.\n   * @param searchParents - Also search the parent nodes (including containerless).\n   * @returns The closest controller of a custom element with the provided name, relative to the provided node, if one can be found, or otherwise `undefined`.\n   * @throws - If neither the node or any of its effective parent nodes host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { name: string; searchParents: true }): ICustomElementController<C> | undefined;\n  /**\n   * Returns the controller that is associated with this node, if it is a custom element.\n   *\n   * @param node - The node to retrieve the controller for, if it is a custom element.\n   * @param optional - If `true`, do not throw if the provided node is not a custom element.\n   * @returns The controller associated with the provided node, if it is a custom element\n   * @throws - If the node does not host a custom element, an error will be thrown.\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node): ICustomElementController<C>;\n  /**\n   * Returns the controller that is associated with this node, if it is a custom element.\n   *\n   * @param node - The node to retrieve the controller for, if it is a custom element.\n   * @param optional - If `true`, do not throw if the provided node is not a custom element.\n   * @returns The controller associated with the provided node, if it is a custom element, otherwise `null`\n   */\n  for<C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: { optional: true }): ICustomElementController<C> | null;\n  isType<C>(value: C, context?: DecoratorContext): value is (C extends Constructable ? CustomElementType<C> : never);\n  define<C extends Constructable>(name: string, Type: C): CustomElementType<C>;\n  define<C extends Constructable>(def: PartialCustomElementDefinition, Type: C): CustomElementType<C>;\n  define<C extends Constructable>(def: PartialCustomElementDefinition, Type?: null): CustomElementType<C>;\n  define<C extends Constructable>(nameOrDef: string | PartialCustomElementDefinition, Type: C): CustomElementType<C>;\n  getDefinition<C extends Constructable>(Type: C, context?: DecoratorContext | null): CustomElementDefinition<C>;\n  // eslint-disable-next-line\n  getDefinition<C extends Constructable>(Type: Function, context?: DecoratorContext | null): CustomElementDefinition<C>;\n  annotate<K extends keyof PartialCustomElementDefinition>(Type: Constructable, prop: K, value: PartialCustomElementDefinition[K], context: DecoratorContext): void;\n  getAnnotation<K extends keyof PartialCustomElementDefinition>(Type: Constructable, prop: K, context: DecoratorContext | null): PartialCustomElementDefinition[K] | undefined;\n  generateName(): string;\n  createInjectable<T extends Key = Key>(): InterfaceSymbol<T>;\n  generateType<P extends {} = {}>(\n    name: string,\n    proto?: P,\n  ): CustomElementType<Constructable<P>>;\n  find(container: IContainer, name: string): CustomElementDefinition | null;\n};\n\nexport type CustomElementDecorator = <T extends Constructable>(Type: T, context: ClassDecoratorContext) => CustomElementType<T>;\n\n/**\n * Decorator: Indicates that the decorated class is a custom element.\n */\nexport function customElement(definition: PartialCustomElementDefinition): CustomElementDecorator;\nexport function customElement(name: string): CustomElementDecorator;\nexport function customElement(nameOrDef: string | PartialCustomElementDefinition): CustomElementDecorator;\nexport function customElement(nameOrDef: string | PartialCustomElementDefinition): CustomElementDecorator {\n  return function <T extends Constructable>(target: T, context: ClassDecoratorContext) {\n    context.addInitializer(function (this) {\n      defineElement(nameOrDef, this as Constructable);\n    });\n    return target as CustomElementType<T>;\n  };\n}\n\ntype ShadowOptions = PartialCustomElementDefinition['shadowOptions'];\n\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM(options?: ShadowOptions): (target: Constructable, context: ClassDecoratorContext) => void;\n/**\n * Decorator: Indicates that the custom element should render its view in ShadowDOM.\n */\nexport function useShadowDOM(target: Constructable): void;\nexport function useShadowDOM(targetOrOptions?: Constructable | ShadowOptions, context?: ClassDecoratorContext): void | ((target: Constructable, context: ClassDecoratorContext) => void) {\n  if (targetOrOptions === void 0) {\n    return function ($target: Constructable, context: ClassDecoratorContext) {\n      context.addInitializer(function (this) {\n        annotateElementMetadata(this as Constructable, 'shadowOptions', { mode: 'open' });\n      });\n    };\n  }\n\n  if (!isFunction(targetOrOptions)) {\n    return function ($target: Constructable, context: ClassDecoratorContext) {\n      context.addInitializer(function (this) {\n        annotateElementMetadata(this as Constructable, 'shadowOptions', targetOrOptions);\n      });\n    };\n  }\n\n  context!.addInitializer(function (this) {\n    annotateElementMetadata(this as Constructable, 'shadowOptions', { mode: 'open' });\n  });\n}\n\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(target: Constructable, context: ClassDecoratorContext): void;\n/**\n * Decorator: Indicates that the custom element should be rendered without its element container.\n */\nexport function containerless(): (target: Constructable, context: ClassDecoratorContext) => void;\nexport function containerless(target?: Constructable, context?: ClassDecoratorContext): void | ((target: Constructable, context: ClassDecoratorContext) => void) {\n  if (target === void 0) {\n    return function ($target: Constructable, $context: ClassDecoratorContext) {\n      $context.addInitializer(function (this) {\n        markContainerless($target);\n      });\n    };\n  }\n\n  context!.addInitializer(function (this) {\n    markContainerless(target);\n  });\n}\n\n/** Manipulates the `containerless` property of the custom element definition for the type, when present else it annotates the type. */\nfunction markContainerless(target: Constructable) {\n  const def = getMetadata<CustomElementDefinition>(elementBaseName, target);\n  if(def === void 0) {\n    annotateElementMetadata(target, 'containerless', true);\n    return;\n  }\n  (def as Writable<CustomElementDefinition>).containerless = true;\n}\n\nconst definitionLookup = new WeakMap<PartialCustomElementDefinition, CustomElementDefinition>();\n\nexport class CustomElementDefinition<C extends Constructable = Constructable> implements ResourceDefinition<C, ICustomElementViewModel, PartialCustomElementDefinition> {\n  public get type(): 'custom-element' { return dtElement; }\n  private constructor(\n    public readonly Type: CustomElementType<C>,\n    public readonly name: string,\n    public readonly aliases: string[],\n    public readonly key: string,\n    public readonly capture: boolean | ((attr: string) => boolean),\n    public readonly template: null | string | Node,\n    public readonly instructions: readonly IInstruction[][],\n    public readonly dependencies: Key[],\n    public readonly injectable: InterfaceSymbol<C> | null,\n    public readonly needsCompile: boolean,\n    public readonly surrogates: readonly IInstruction[],\n    public readonly bindables: Record<string, BindableDefinition>,\n    public readonly containerless: boolean,\n    public readonly shadowOptions: { mode: 'open' | 'closed' } | null,\n    /**\n     * Indicates whether the custom element has <slot/> in its template\n     */\n    public readonly hasSlots: boolean,\n    public readonly enhance: boolean,\n    public readonly watches: IWatchDefinition[],\n    public readonly strict: boolean | undefined,\n    public readonly processContent: ProcessContentHook | null,\n  ) { }\n\n  public static create(\n    def: PartialCustomElementDefinition,\n    Type?: null,\n  ): CustomElementDefinition;\n  public static create(\n    name: string,\n    Type: CustomElementType,\n  ): CustomElementDefinition;\n  public static create<T extends Constructable = Constructable>(\n    nameOrDef: string | PartialCustomElementDefinition,\n    Type?: CustomElementType<T> | null,\n  ): CustomElementDefinition<T>;\n  public static create(\n    nameOrDef: string | PartialCustomElementDefinition,\n    Type: CustomElementType | null = null,\n  ): CustomElementDefinition {\n    if (Type === null) {\n      const def = nameOrDef;\n      if (isString(def)) {\n        throw createMappedError(ErrorNames.element_only_name, nameOrDef);\n      }\n\n      const name = fromDefinitionOrDefault('name', def, generateElementName);\n      if (isFunction((def as CustomElementDefinition).Type)) {\n        // This needs to be a clone (it will usually be the compiler calling this signature)\n\n        // TODO: we need to make sure it's documented that passing in the type via the definition (while passing in null\n        // as the \"Type\" parameter) effectively skips type analysis, so it should only be used this way for cloning purposes.\n        Type = (def as CustomElementDefinition).Type;\n      } else {\n        Type = generateElementType(pascalCase(name));\n      }\n\n      for(const bindable of Object.values(Bindable.from(def.bindables))) {\n        Bindable._add(bindable, Type);\n      }\n      return new CustomElementDefinition(\n        Type,\n        name,\n        mergeArrays(def.aliases),\n        fromDefinitionOrDefault('key', def as CustomElementDefinition, () => getElementKeyFrom(name)),\n        fromAnnotationOrDefinitionOrTypeOrDefault('capture', def, Type, returnFalse),\n        fromAnnotationOrDefinitionOrTypeOrDefault('template', def, Type, returnNull),\n        mergeArrays(def.instructions),\n        mergeArrays(getElementAnnotation(Type, 'dependencies'), def.dependencies),\n        fromDefinitionOrDefault('injectable', def, returnNull),\n        fromDefinitionOrDefault('needsCompile', def, returnTrue),\n        mergeArrays(def.surrogates),\n        Bindable.from(getElementAnnotation(Type, 'bindables'), def.bindables),\n        fromAnnotationOrDefinitionOrTypeOrDefault('containerless', def, Type, returnFalse),\n        fromDefinitionOrDefault('shadowOptions', def, returnNull),\n        fromDefinitionOrDefault('hasSlots', def, returnFalse),\n        fromDefinitionOrDefault('enhance', def, returnFalse),\n        fromDefinitionOrDefault('watches', def as CustomElementDefinition, returnEmptyArray),\n        // casting is incorrect, but it's good enough\n        fromDefinitionOrDefault('strict', def, returnUndefined as () => boolean),\n        fromAnnotationOrTypeOrDefault('processContent', Type, returnNull as () => ProcessContentHook | null),\n\n      );\n    }\n\n    // If a type is passed in, we ignore the Type property on the definition if it exists.\n    // TODO: document this behavior\n\n    if (isString(nameOrDef)) {\n      return new CustomElementDefinition(\n        Type,\n        nameOrDef,\n        mergeArrays(getElementAnnotation(Type, 'aliases'), Type.aliases),\n        getElementKeyFrom(nameOrDef),\n        fromAnnotationOrTypeOrDefault('capture', Type, returnFalse),\n        fromAnnotationOrTypeOrDefault('template', Type, returnNull as () => string | Node | null),\n        mergeArrays(getElementAnnotation(Type, 'instructions'), Type.instructions),\n        mergeArrays(getElementAnnotation(Type, 'dependencies'), Type.dependencies),\n        fromAnnotationOrTypeOrDefault('injectable', Type, returnNull as () => InterfaceSymbol | null),\n        fromAnnotationOrTypeOrDefault('needsCompile', Type, returnTrue),\n        mergeArrays(getElementAnnotation(Type, 'surrogates'), Type.surrogates),\n        Bindable.from(\n          ...Bindable.getAll(Type),\n          getElementAnnotation(Type, 'bindables'),\n          Type.bindables,\n        ),\n        fromAnnotationOrTypeOrDefault('containerless', Type, returnFalse),\n        fromAnnotationOrTypeOrDefault('shadowOptions', Type, returnNull as () => { mode: 'open' | 'closed' } | null),\n        fromAnnotationOrTypeOrDefault('hasSlots', Type, returnFalse),\n        fromAnnotationOrTypeOrDefault('enhance', Type, returnFalse),\n        mergeArrays(Watch.getDefinitions(Type), Type.watches),\n        fromAnnotationOrTypeOrDefault('strict', Type, returnUndefined as () => boolean),\n        fromAnnotationOrTypeOrDefault('processContent', Type, returnNull as () => ProcessContentHook | null),\n      );\n    }\n\n    // This is the typical default behavior, e.g. from regular CustomElement.define invocations or from @customElement deco\n    // The ViewValueConverter also uses this signature and passes in a definition where everything except for the 'hooks'\n    // property needs to be copied. So we have that exception for 'hooks', but we may need to revisit that default behavior\n    // if this turns out to be too opinionated.\n\n    const name = fromDefinitionOrDefault('name', nameOrDef, generateElementName);\n\n    for(const bindable of Object.values(Bindable.from(nameOrDef.bindables))) {\n      Bindable._add(bindable, Type);\n    }\n    return new CustomElementDefinition(\n      Type,\n      name,\n      mergeArrays(getElementAnnotation(Type, 'aliases'), nameOrDef.aliases, Type.aliases),\n      getElementKeyFrom(name),\n      fromAnnotationOrDefinitionOrTypeOrDefault('capture', nameOrDef, Type, returnFalse),\n      fromAnnotationOrDefinitionOrTypeOrDefault('template', nameOrDef, Type, returnNull),\n      mergeArrays(getElementAnnotation(Type, 'instructions'), nameOrDef.instructions, Type.instructions),\n      mergeArrays(getElementAnnotation(Type, 'dependencies'), nameOrDef.dependencies, Type.dependencies),\n      fromAnnotationOrDefinitionOrTypeOrDefault('injectable', nameOrDef, Type, returnNull),\n      fromAnnotationOrDefinitionOrTypeOrDefault('needsCompile', nameOrDef, Type, returnTrue),\n      mergeArrays(getElementAnnotation(Type, 'surrogates'), nameOrDef.surrogates, Type.surrogates),\n      Bindable.from(\n        ...Bindable.getAll(Type),\n        getElementAnnotation(Type, 'bindables'),\n        Type.bindables,\n        nameOrDef.bindables,\n      ),\n      fromAnnotationOrDefinitionOrTypeOrDefault('containerless', nameOrDef, Type, returnFalse),\n      fromAnnotationOrDefinitionOrTypeOrDefault('shadowOptions', nameOrDef, Type, returnNull),\n      fromAnnotationOrDefinitionOrTypeOrDefault('hasSlots', nameOrDef, Type, returnFalse),\n      fromAnnotationOrDefinitionOrTypeOrDefault('enhance', nameOrDef, Type, returnFalse),\n      mergeArrays(nameOrDef.watches, Watch.getDefinitions(Type), Type.watches),\n      fromAnnotationOrDefinitionOrTypeOrDefault('strict', nameOrDef, Type, returnUndefined as () => boolean),\n      fromAnnotationOrDefinitionOrTypeOrDefault('processContent', nameOrDef, Type, returnNull),\n    );\n  }\n\n  public static getOrCreate(partialDefinition: PartialCustomElementDefinition): CustomElementDefinition {\n    if (partialDefinition instanceof CustomElementDefinition) {\n      return partialDefinition;\n    }\n\n    if (definitionLookup.has(partialDefinition)) {\n      return definitionLookup.get(partialDefinition)!;\n    }\n\n    const definition = CustomElementDefinition.create(partialDefinition);\n    definitionLookup.set(partialDefinition, definition);\n    // Make sure the full definition can be retrieved from dynamically created classes as well\n    defineMetadata(definition, definition.Type, elementBaseName);\n    return definition;\n  }\n\n  public register(container: IContainer, aliasName?: string | undefined): void {\n    const $Type = this.Type;\n    const key = typeof aliasName === 'string' ? getElementKeyFrom(aliasName) : this.key;\n    const aliases = this.aliases;\n\n    /* istanbul ignore next */\n    if (container.has(key, false)) {\n      // eslint-disable-next-line no-console\n      console.warn(createMappedError(ErrorNames.element_existed, this.name));\n      return;\n    }\n    container.register(\n      container.has($Type, false) ? null : singletonRegistration($Type, $Type),\n      aliasRegistration($Type, key),\n      ...aliases.map(alias => aliasRegistration($Type, getElementKeyFrom(alias)))\n    );\n  }\n\n  public toString() {\n    return `au:ce:${this.name}`;\n  }\n}\n\ntype ForOpts = {\n  name?: string;\n  searchParents?: boolean;\n  optional?: boolean;\n};\nconst defaultForOpts: ForOpts = {\n  name: undefined,\n  searchParents: false,\n  optional: false,\n};\nconst returnNull = <T>(): T | null => null;\nconst returnUndefined = <T>(): T | undefined => void 0;\nconst returnFalse = () => false;\nconst returnTrue = () => true;\nconst returnEmptyArray = () => emptyArray;\n\n/** @internal */ export const elementTypeName = 'custom-element';\n/** @internal */ export const elementBaseName = /*@__PURE__*/getResourceKeyFor(elementTypeName);\n\n/** @internal */\nexport const getElementKeyFrom = (name: string): string => `${elementBaseName}:${name}`;\n\n/** @internal */\nexport const generateElementName = /*@__PURE__*/(id => () => `unnamed-${++id}`)(0);\n\nconst annotateElementMetadata = <K extends keyof PartialCustomElementDefinition>(Type: Constructable, prop: K, value: PartialCustomElementDefinition[K]): void => {\n  defineMetadata(value, Type, getAnnotationKeyFor(prop));\n};\n\n/** @internal */\nexport const defineElement = <C extends Constructable>(nameOrDef: string | PartialCustomElementDefinition, Type: C | null): CustomElementType<C> => {\n  const definition = CustomElementDefinition.create(nameOrDef, Type as CustomElementType<C>);\n  const $Type = definition.Type;\n\n  // this is the case, where the APi is invoked directly without a decorator\n  // registration of resource name is a requirement for the resource system in kernel (module-loader)\n  defineMetadata(definition, $Type, elementBaseName, resourceBaseName);\n\n  return $Type;\n};\n\n/** @internal */\nexport const isElementType = <C>(value: C): value is (C extends Constructable ? CustomElementType<C> : never) => {\n  return isFunction(value)\n    && (hasMetadata(elementBaseName, value)\n      || (value as StaticResourceType).$au?.type === elementTypeName\n    );\n};\n\n/** @internal */\nexport const findElementControllerFor = <C extends ICustomElementViewModel = ICustomElementViewModel>(node: Node, opts: ForOpts = defaultForOpts): ICustomElementController<C> => {\n  if (opts.name === void 0 && opts.searchParents !== true) {\n    const controller = refs.get(node, elementBaseName) as Controller<C> | null;\n    if (controller === null) {\n      if (opts.optional === true) {\n        return null!;\n      }\n      throw createMappedError(ErrorNames.node_is_not_a_host, node);\n    }\n    return controller as unknown as ICustomElementController<C>;\n  }\n  if (opts.name !== void 0) {\n    if (opts.searchParents !== true) {\n      const controller = refs.get(node, elementBaseName) as Controller<C> | null;\n      if (controller === null) {\n        throw createMappedError(ErrorNames.node_is_not_a_host2, node);\n      }\n\n      if (controller.is(opts.name)) {\n        return controller as unknown as ICustomElementController<C>;\n      }\n\n      return (void 0)!;\n    }\n\n    let cur = node as INode | null;\n    let foundAController = false;\n    while (cur !== null) {\n      const controller = refs.get(cur, elementBaseName) as Controller<C> | null;\n      if (controller !== null) {\n        foundAController = true;\n        if (controller.is(opts.name)) {\n          return controller as unknown as ICustomElementController<C>;\n        }\n      }\n\n      cur = getEffectiveParentNode(cur);\n    }\n\n    if (foundAController) {\n      return (void 0)!;\n    }\n\n    throw createMappedError(ErrorNames.node_is_not_part_of_aurelia_app, node);\n  }\n\n  let cur = node as INode | null;\n  while (cur !== null) {\n    const controller = refs.get(cur, elementBaseName) as Controller<C> | null;\n    if (controller !== null) {\n      return controller as unknown as ICustomElementController<C>;\n    }\n\n    cur = getEffectiveParentNode(cur);\n  }\n\n  throw createMappedError(ErrorNames.node_is_not_part_of_aurelia_app2, node);\n};\n\nconst getElementAnnotation = <K extends keyof PartialCustomElementDefinition>(\n  Type: Constructable,\n  prop: K,\n): PartialCustomElementDefinition[K] | undefined => getMetadata(getAnnotationKeyFor(prop), Type);\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport const getElementDefinition = <C extends Constructable>(Type: C | Function): CustomElementDefinition<C> => {\n  const def: CustomElementDefinition<C> = getMetadata<CustomElementDefinition<C>>(elementBaseName, Type)\n    ?? getDefinitionFromStaticAu<CustomElementDefinition<C>>(Type as CustomElementType, elementTypeName, CustomElementDefinition.create);\n  if (def == null) {\n    throw createMappedError(ErrorNames.element_def_not_found, Type);\n  }\n\n  return def;\n};\n\n/** @internal */\nexport const createElementInjectable = <K extends Key = Key>(): InterfaceSymbol<K> => {\n  const $injectable = {\n    // Old code is kept around. Needs to be refactored when TC39 supports argument decorator.\n    // function(target: Injectable | AbstractInjectable, property: string | symbol | undefined, index?: number): Injectable | AbstractInjectable {\n    //   const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target as Constructable);\n    //   annotationParamtypes[index!] = $injectable;\n    //   return target;\n    // },\n    $isInterface: false,\n    register(): IResolver {\n      return {\n        $isResolver: true,\n        resolve(container, requestor) {\n          if (requestor.has($injectable, true)) {\n            return requestor.get($injectable);\n          } else {\n            return null;\n          }\n        }\n      };\n    }\n  };\n\n  return $injectable;\n};\n\n/** @internal */\nexport const generateElementType = /*@__PURE__*/(function () {\n  const nameDescriptor: PropertyDescriptor = {\n    value: '',\n    writable: false,\n    enumerable: false,\n    configurable: true,\n  };\n\n  const defaultProto = {};\n\n  return function <P extends {} = {}>(\n    name: string,\n    proto: P = defaultProto as P,\n  ): CustomElementType<Constructable<P>> {\n    // Anonymous class ensures that minification cannot cause unintended side-effects, and keeps the class\n    // looking similarly from the outside (when inspected via debugger, etc).\n    const Type = class Anonymous { } as CustomElementType<Constructable<P>>;\n\n    // Define the name property so that Type.name can be used by end users / plugin authors if they really need to,\n    // even when minified.\n    nameDescriptor.value = name;\n    def(Type, 'name', nameDescriptor);\n\n    // Assign anything from the prototype that was passed in\n    if (proto !== defaultProto) {\n      objectAssign(Type.prototype, proto);\n    }\n\n    return Type;\n  };\n})();\n\nexport const CustomElement = /*@__PURE__*/ objectFreeze<CustomElementKind>({\n  name: elementBaseName,\n  keyFrom: getElementKeyFrom,\n  isType: isElementType,\n  for: findElementControllerFor,\n  define: defineElement,\n  getDefinition: getElementDefinition,\n  annotate: annotateElementMetadata,\n  getAnnotation: getElementAnnotation,\n  generateName: generateElementName,\n  createInjectable: createElementInjectable,\n  generateType: generateElementType,\n  find(c, name) {\n    const Type = c.find<CustomElementType>(elementTypeName, name);\n    return Type == null\n      ? null\n      : getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create) ?? null;\n  }\n});\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype DecoratorFactoryMethod = (target: Function, context: ClassMethodDecoratorContext) => void;\n\nconst pcHookMetadataProperty = /*@__PURE__*/getAnnotationKeyFor('processContent');\nexport function processContent(hook: ProcessContentHook | string | symbol): CustomElementDecorator;\nexport function processContent(): DecoratorFactoryMethod;\nexport function processContent<TClass extends Constructable>(hook?: ProcessContentHook | string | symbol): CustomElementDecorator | DecoratorFactoryMethod {\n  return hook === void 0\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    ? function (target: Function, context: ClassMethodDecoratorContext) {\n        if (!context.static || context.kind !== 'method') throw createMappedError(ErrorNames.invalid_process_content_hook, target);\n        // As the method is ensured to be static, the following initializer will be invoked in static fashion, before executing the initializers added via a class decorator.\n        // Refer: https://tinyurl.com/ts-static-method-deco\n        context.addInitializer(function (this) {\n          defineMetadata(target, this, pcHookMetadataProperty);\n        });\n    }\n    : function (target: TClass, context: ClassDecoratorContext<TClass>) {\n        context.addInitializer(function (this) {\n          if (isString(hook) || isSymbol(hook)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-explicit-any\n            hook = (this as any)[hook] as ProcessContentHook;\n          }\n          if (!isFunction(hook)) throw createMappedError(ErrorNames.invalid_process_content_hook, hook);\n\n          const def = getMetadata<CustomElementDefinition>(elementBaseName, this);\n          if (def !== void 0) {\n            (def as Writable<CustomElementDefinition>).processContent = hook;\n          } else {\n            defineMetadata(hook, this, pcHookMetadataProperty);\n          }\n        });\n        return target as CustomElementType<TClass>;\n    } as CustomElementDecorator;\n}\n\n/**\n * Decorator: Indicates that the custom element should capture all attributes and bindings that are not template controllers or bindables\n */\nexport function capture(filter: (attr: string) => boolean): (target: Constructable, context: ClassDecoratorContext) => void;\n/**\n * Decorator: Indicates that the custom element should be rendered with the strict binding option. undefined/null -> 0 or '' based on type\n */\nexport function capture(): (target: Constructable, context: ClassDecoratorContext) => void ;\nexport function capture(targetOrFilter?: (attr: string) => boolean): ((target: Constructable, context: ClassDecoratorContext) => void) {\n  return function ($target: Constructable, context: ClassDecoratorContext) {\n    const value = isFunction(targetOrFilter) ? targetOrFilter : true;\n    context.addInitializer(function (this) {\n      annotateElementMetadata(this as Constructable, 'capture', value);\n\n      // also do this to make order of the decorator irrelevant\n      if (isElementType(this)) {\n        (getElementDefinition(this) as Writable<CustomElementDefinition>).capture = value;\n      }\n    });\n  };\n}\n", "import { BrowserPlatform } from '@aurelia/platform-browser';\nimport { InstanceProvider, onResolve, onResolveAll, isFunction } from '@aurelia/kernel';\nimport { IAppTask } from './app-task';\nimport { CustomElementDefinition, generateElementName } from './resources/custom-element';\nimport { Controller, IControllerElementHydrationInstruction } from './templating/controller';\nimport { createInterface, instanceRegistration, registerResolver } from './utilities-di';\n\nimport type { Constructable, IContainer, IDisposable } from '@aurelia/kernel';\nimport type { TaskSlot } from './app-task';\nimport type { ICustomElementViewModel, ICustomElementController } from './templating/controller';\nimport { IPlatform } from './platform';\nimport { IEventTarget, registerHostNode } from './dom';\nimport { ErrorNames, createMappedError } from './errors';\n\nexport interface IAppRootConfig<T extends object = object> {\n  host: HTMLElement;\n  component: T | Constructable<T>;\n  /**\n   * When a HTML form is submitted, the default behavior is to \"redirect\" the page to the action of the form\n   * This is not desirable for SPA applications, so by default, this behavior is prevented.\n   *\n   * This option re-enables the default behavior of HTML forms.\n   */\n  allowActionlessForm?: boolean;\n  /**\n   * Indicates strictness of expression evaluation.\n   *\n   * When strictBinding is true, standard JS behavior applies, which means accessing a property of undefined will throw an error.\n   * Use optional syntaxes (?./?.()/?.[]) to prevent errors.\n   *\n   * When strictBinding is false (default), the behavior is more lenient, which means accessing a property of undefined will return undefined.\n   * In this mode, calling an undefined function will return undefined as well.\n   */\n  strictBinding?: boolean;\n}\n\nexport interface IAppRoot<C extends object = object> extends IDisposable {\n  readonly config: IAppRootConfig<C>;\n  /**\n   * The host element of an application\n   */\n  readonly host: HTMLElement;\n  /**\n   * The root container of an application\n   */\n  readonly container: IContainer;\n  /**\n   * The controller of the root custom element of an application\n   */\n  readonly controller: ICustomElementController<C>;\n  /**\n   * The platform of an application for providing globals & DOM APIs\n   */\n  readonly platform: IPlatform;\n\n  activate(): void | Promise<void>;\n  deactivate(): void | Promise<void>;\n}\nexport const IAppRoot = /*@__PURE__*/createInterface<IAppRoot>('IAppRoot');\n\nexport class AppRoot<\n  T extends object,\n  K extends ICustomElementViewModel = ICustomElementViewModel & (T extends Constructable<infer R> ? R : T),\n> implements IAppRoot<K> {\n\n  /** @internal */\n  private _hydratePromise: Promise<void> | void = void 0;\n\n  /** @internal */\n  private _controller!: ICustomElementController<K>;\n\n  /** @internal */\n  private readonly _useOwnAppTasks: boolean;\n\n  public readonly host: HTMLElement;\n  public readonly platform: IPlatform;\n  public get controller() {\n    return this._controller;\n  }\n\n  public constructor(\n    public readonly config: IAppRootConfig<K>,\n    public readonly container: IContainer,\n    rootProvider: InstanceProvider<IAppRoot>,\n    enhance: boolean = false,\n  ) {\n    this._useOwnAppTasks = enhance;\n    const host = this.host = config.host;\n    rootProvider.prepare(this);\n\n    registerResolver(container, IEventTarget, new InstanceProvider<IEventTarget>('IEventTarget', host));\n    registerHostNode(container, host, this.platform = this._createPlatform(container, host));\n\n    this._hydratePromise = onResolve(this._runAppTasks('creating'), () => {\n      if (!config.allowActionlessForm !== false) {\n        host.addEventListener('submit', (e: Event) => {\n          const target = e.target as HTMLFormElement;\n          const noAction = !target.getAttribute('action');\n\n          if (target.tagName === 'FORM' && noAction) {\n            e.preventDefault();\n          }\n        }, false);\n      }\n\n      const childCtn = enhance ? container : container.createChild();\n      const component = config.component as Constructable | ICustomElementViewModel;\n      let instance: object;\n      if (isFunction(component)) {\n        instance = childCtn.invoke(component);\n        instanceRegistration(component, instance);\n      } else {\n        instance = config.component as ICustomElementViewModel;\n      }\n\n      const hydrationInst: IControllerElementHydrationInstruction = { hydrate: false, projections: null };\n      const definition = enhance\n        ? CustomElementDefinition.create({ name: generateElementName(), template: this.host, enhance: true, strict: config.strictBinding })\n        // leave the work of figuring out the definition to the controller\n        // there's proper error messages in case of failure inside the $el() call\n        : void 0;\n      const controller = (this._controller = Controller.$el<K>(\n        childCtn,\n        instance as K,\n        host,\n        hydrationInst,\n        definition\n      )) as Controller<K>;\n\n      controller._hydrateCustomElement(hydrationInst);\n      return onResolve(this._runAppTasks('hydrating'), () => {\n        controller._hydrate();\n        return onResolve(this._runAppTasks('hydrated'), () => {\n          controller._hydrateChildren();\n          this._hydratePromise = void 0;\n        });\n      });\n    });\n  }\n\n  public activate(): void | Promise<void> {\n    return onResolve(this._hydratePromise, () => {\n      return onResolve(this._runAppTasks('activating'), () => {\n        return onResolve(this._controller.activate(this._controller, null, void 0), () => {\n          return this._runAppTasks('activated');\n        });\n      });\n    });\n  }\n\n  public deactivate(): void | Promise<void> {\n    return onResolve(this._runAppTasks('deactivating'), () => {\n      return onResolve(this._controller.deactivate(this._controller, null), () => {\n        return this._runAppTasks('deactivated');\n      });\n    });\n  }\n\n  /** @internal */\n  private _runAppTasks(slot: TaskSlot): void | Promise<void> {\n    const container = this.container;\n    const appTasks = this._useOwnAppTasks && !container.has(IAppTask, false)\n      ? []\n      : container.getAll(IAppTask);\n    return onResolveAll(...appTasks.reduce((results, task) => {\n      if (task.slot === slot) {\n        results.push(task.run());\n      }\n      return results;\n    }, [] as (void | Promise<void>)[]));\n  }\n\n  /** @internal */\n  private _createPlatform(container: IContainer, host: HTMLElement): IPlatform {\n    let p: IPlatform;\n    if (!container.has(IPlatform, false)) {\n      if (host.ownerDocument.defaultView === null) {\n        throw createMappedError(ErrorNames.invalid_platform_impl);\n      }\n      p = new BrowserPlatform(host.ownerDocument.defaultView);\n      container.register(instanceRegistration(IPlatform, p));\n    } else {\n      p = container.get(IPlatform);\n    }\n    return p;\n  }\n\n  public dispose(): void {\n    this._controller?.dispose();\n  }\n}\n", "import { isPromise, DI, InstanceProvider, onResolve } from '@aurelia/kernel';\nimport { AppRoot, IAppRoot, IAppRootConfig } from './app-root';\nimport { createInterface, registerResolver } from './utilities-di';\n\nimport type {\n  Constructable,\n  IContainer,\n  IDisposable,\n} from '@aurelia/kernel';\nimport { ErrorNames, createMappedError } from './errors';\nimport { refs } from './dom.node';\nimport { tasksSettled } from '@aurelia/runtime';\n\nexport interface IAurelia extends Aurelia {}\nexport const IAurelia = /*@__PURE__*/createInterface<IAurelia>('IAurelia');\n\nexport class Aurelia implements IDisposable {\n  /** @internal */\n  private _isRunning: boolean = false;\n  public get isRunning(): boolean { return this._isRunning; }\n  /** @internal */\n  private _isStarting: boolean = false;\n  public get isStarting(): boolean { return this._isStarting; }\n  /** @internal */\n  private _isStopping: boolean = false;\n  public get isStopping(): boolean { return this._isStopping; }\n\n  /** @internal */\n  private _root: IAppRoot | undefined = void 0;\n  public get root(): IAppRoot {\n    if (this._root == null) {\n      if (this.next == null) {\n        throw createMappedError(ErrorNames.root_not_found);\n      }\n      return this.next;\n    }\n    return this._root;\n  }\n\n  private next: IAppRoot | undefined = void 0;\n\n  /** @internal */\n  private readonly _rootProvider: InstanceProvider<IAppRoot>;\n\n  public constructor(\n    public readonly container: IContainer = DI.createContainer(),\n  ) {\n    if (container.has(IAurelia, true) || container.has(Aurelia, true)) {\n      throw createMappedError(ErrorNames.aurelia_instance_existed_in_container);\n    }\n\n    registerResolver(container, IAurelia, new InstanceProvider<IAurelia>('IAurelia', this));\n    registerResolver(container, Aurelia, new InstanceProvider<IAurelia>('Aurelia', this));\n    registerResolver(container, IAppRoot, this._rootProvider = new InstanceProvider('IAppRoot'));\n  }\n\n  public register(...params: unknown[]): this {\n    this.container.register(...params);\n    return this;\n  }\n\n  public app(config: ISinglePageAppConfig): Omit<this, 'register' | 'app' | 'enhance'> {\n    this.next = new AppRoot(config, this.container, this._rootProvider);\n    return this;\n  }\n\n  /**\n   * @param parentController - The owning controller of the view created by this enhance call\n   */\n  public enhance<T extends object>(config: IEnhancementConfig<T>): IAppRoot<T> | Promise<IAppRoot<T>> {\n    const container = (config.container ?? this.container.createChild());\n    const rootProvider = registerResolver(container, IAppRoot, new InstanceProvider<IAppRoot<T>>('IAppRoot'));\n    const appRoot: IAppRoot<T> = new AppRoot(\n      { host: config.host as HTMLElement, component: config.component },\n      container,\n      rootProvider,\n      true\n    );\n    return onResolve(appRoot.activate(), () => appRoot);\n  }\n\n  public async waitForIdle(): Promise<void> {\n    const platform = this.root.platform;\n    await platform.domQueue.yield();\n    await platform.taskQueue.yield();\n  }\n\n  /** @internal */\n  private _startPromise: Promise<void> | void = void 0;\n  public start(root: IAppRoot | undefined = this.next): void | Promise<void> {\n    if (root == null) {\n      throw createMappedError(ErrorNames.no_composition_root);\n    }\n\n    if (isPromise(this._startPromise)) {\n      return this._startPromise;\n    }\n\n    return this._startPromise = onResolve(this.stop(), () => {\n      if (!refs.hideProp) {\n        Reflect.set(root.host, '$aurelia', this);\n      }\n      this._rootProvider.prepare(this._root = root);\n      this._isStarting = true;\n\n      return onResolve(root.activate(), () => {\n        this._isRunning = true;\n        this._isStarting = false;\n        this._startPromise = void 0;\n        this._dispatchEvent(root, 'au-started', root.host);\n      });\n    });\n  }\n\n  /** @internal */\n  private _stopPromise: Promise<void> | void = void 0;\n  public stop(dispose: boolean = false): void | Promise<void> {\n    if (isPromise(this._stopPromise)) {\n      return this._stopPromise;\n    }\n\n    if (this._isRunning === true) {\n      const root = this._root!;\n      this._isRunning = false;\n      this._isStopping = true;\n\n      return this._stopPromise = onResolve(root.deactivate(), () => {\n        return onResolve(tasksSettled(), () => {\n          Reflect.deleteProperty(root.host, '$aurelia');\n          if (dispose) {\n            root.dispose();\n          }\n          this._root = void 0;\n          this._rootProvider.dispose();\n          this._isStopping = false;\n          this._stopPromise = void 0;\n          this._dispatchEvent(root, 'au-stopped', root.host);\n        });\n      });\n    }\n  }\n\n  public dispose(): void {\n    if (this._isRunning || this._isStopping) {\n      throw createMappedError(ErrorNames.invalid_dispose_call);\n    }\n    this.container.dispose();\n  }\n\n  /** @internal */\n  private _dispatchEvent(root: IAppRoot, name: string, target: HTMLElement): void {\n    const ev = new root.platform.window.CustomEvent(name, { detail: this, bubbles: true, cancelable: true });\n    target.dispatchEvent(ev);\n  }\n}\n\nexport type ISinglePageAppConfig<T extends object = object> = Omit<IAppRootConfig<T>, 'strictBinding'> & {\n  host: Element;\n};\n\nexport type IEnhancementConfig<T extends object = object> = IAppRootConfig<T> & {\n  host: Element;\n  /**\n   * The binding context of the enhancement. Will be instantiate by DI if a constructor is given\n   */\n  component: T | Constructable<T>;\n  /**\n   * A predefined container for the enhanced view.\n   */\n  container?: IContainer;\n};\n", "import { IPlatform } from '../platform';\nimport { objectAssign } from '../utilities';\nimport { aliasRegistration, createInterface, singletonRegistration } from '../utilities-di';\n\nimport { createLookup, isString, resolve, type IContainer } from '@aurelia/kernel';\nimport type { INode } from '../dom.node';\n\nexport interface ISVGAnalyzer extends NoopSVGAnalyzer {}\nexport const ISVGAnalyzer = /*@__PURE__*/createInterface<ISVGAnalyzer>('ISVGAnalyzer', x => x.singleton(NoopSVGAnalyzer));\n\nconst o = (keys: string | string[]): Record<string, true | undefined> => {\n  const lookup = createLookup<true | undefined>();\n  keys = isString(keys) ? keys.split(' ') : keys;\n  let key: string;\n  for (key of keys) {\n    lookup[key] = true;\n  }\n  return lookup;\n};\nexport class NoopSVGAnalyzer {\n  public isStandardSvgAttribute(_node: INode, _attributeName: string): boolean {\n    return false;\n  }\n}\n\nexport class SVGAnalyzer {\n  public static register(container: IContainer): void {\n    container.register(\n      singletonRegistration(this, this),\n      aliasRegistration(this, ISVGAnalyzer)\n    );\n  }\n\n  /** @internal */\n  private readonly _svgElements: Record<string, Record<string, true | undefined> | undefined> = objectAssign(createLookup<Record<string, true | undefined> | undefined>(), {\n    'a':                    o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage target transform xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'altGlyph':             o('class dx dy externalResourcesRequired format glyphRef id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'altglyph':             createLookup<true | undefined>(),\n    'altGlyphDef':          o('id xml:base xml:lang xml:space'),\n    'altglyphdef':          createLookup<true | undefined>(),\n    'altGlyphItem':         o('id xml:base xml:lang xml:space'),\n    'altglyphitem':         createLookup<true | undefined>(),\n    'animate':              o('accumulate additive attributeName attributeType begin by calcMode dur end externalResourcesRequired fill from id keySplines keyTimes max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'animateColor':         o('accumulate additive attributeName attributeType begin by calcMode dur end externalResourcesRequired fill from id keySplines keyTimes max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'animateMotion':        o('accumulate additive begin by calcMode dur end externalResourcesRequired fill from id keyPoints keySplines keyTimes max min onbegin onend onload onrepeat origin path repeatCount repeatDur requiredExtensions requiredFeatures restart rotate systemLanguage to values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'animateTransform':     o('accumulate additive attributeName attributeType begin by calcMode dur end externalResourcesRequired fill from id keySplines keyTimes max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to type values xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'circle':               o('class cx cy externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup r requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'clipPath':             o('class clipPathUnits externalResourcesRequired id requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'color-profile':        o('id local name rendering-intent xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'cursor':               o('externalResourcesRequired id requiredExtensions requiredFeatures systemLanguage x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'defs':                 o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'desc':                 o('class id style xml:base xml:lang xml:space'),\n    'ellipse':              o('class cx cy externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rx ry style systemLanguage transform xml:base xml:lang xml:space'),\n    'feBlend':              o('class height id in in2 mode result style width x xml:base xml:lang xml:space y'),\n    'feColorMatrix':        o('class height id in result style type values width x xml:base xml:lang xml:space y'),\n    'feComponentTransfer':  o('class height id in result style width x xml:base xml:lang xml:space y'),\n    'feComposite':          o('class height id in in2 k1 k2 k3 k4 operator result style width x xml:base xml:lang xml:space y'),\n    'feConvolveMatrix':     o('bias class divisor edgeMode height id in kernelMatrix kernelUnitLength order preserveAlpha result style targetX targetY width x xml:base xml:lang xml:space y'),\n    'feDiffuseLighting':    o('class diffuseConstant height id in kernelUnitLength result style surfaceScale width x xml:base xml:lang xml:space y'),\n    'feDisplacementMap':    o('class height id in in2 result scale style width x xChannelSelector xml:base xml:lang xml:space y yChannelSelector'),\n    'feDistantLight':       o('azimuth elevation id xml:base xml:lang xml:space'),\n    'feFlood':              o('class height id result style width x xml:base xml:lang xml:space y'),\n    'feFuncA':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feFuncB':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feFuncG':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feFuncR':              o('amplitude exponent id intercept offset slope tableValues type xml:base xml:lang xml:space'),\n    'feGaussianBlur':       o('class height id in result stdDeviation style width x xml:base xml:lang xml:space y'),\n    'feImage':              o('class externalResourcesRequired height id preserveAspectRatio result style width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'feMerge':              o('class height id result style width x xml:base xml:lang xml:space y'),\n    'feMergeNode':          o('id xml:base xml:lang xml:space'),\n    'feMorphology':         o('class height id in operator radius result style width x xml:base xml:lang xml:space y'),\n    'feOffset':             o('class dx dy height id in result style width x xml:base xml:lang xml:space y'),\n    'fePointLight':         o('id x xml:base xml:lang xml:space y z'),\n    'feSpecularLighting':   o('class height id in kernelUnitLength result specularConstant specularExponent style surfaceScale width x xml:base xml:lang xml:space y'),\n    'feSpotLight':          o('id limitingConeAngle pointsAtX pointsAtY pointsAtZ specularExponent x xml:base xml:lang xml:space y z'),\n    'feTile':               o('class height id in result style width x xml:base xml:lang xml:space y'),\n    'feTurbulence':         o('baseFrequency class height id numOctaves result seed stitchTiles style type width x xml:base xml:lang xml:space y'),\n    'filter':               o('class externalResourcesRequired filterRes filterUnits height id primitiveUnits style width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'font':                 o('class externalResourcesRequired horiz-adv-x horiz-origin-x horiz-origin-y id style vert-adv-y vert-origin-x vert-origin-y xml:base xml:lang xml:space'),\n    'font-face':            o('accent-height alphabetic ascent bbox cap-height descent font-family font-size font-stretch font-style font-variant font-weight hanging id ideographic mathematical overline-position overline-thickness panose-1 slope stemh stemv strikethrough-position strikethrough-thickness underline-position underline-thickness unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical widths x-height xml:base xml:lang xml:space'),\n    'font-face-format':     o('id string xml:base xml:lang xml:space'),\n    'font-face-name':       o('id name xml:base xml:lang xml:space'),\n    'font-face-src':        o('id xml:base xml:lang xml:space'),\n    'font-face-uri':        o('id xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'foreignObject':        o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform width x xml:base xml:lang xml:space y'),\n    'g':                    o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'glyph':                o('arabic-form class d glyph-name horiz-adv-x id lang orientation style unicode vert-adv-y vert-origin-x vert-origin-y xml:base xml:lang xml:space'),\n    'glyphRef':             o('class dx dy format glyphRef id style x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'glyphref':             createLookup<true | undefined>(),\n    'hkern':                o('g1 g2 id k u1 u2 xml:base xml:lang xml:space'),\n    'image':                o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup preserveAspectRatio requiredExtensions requiredFeatures style systemLanguage transform width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'line':                 o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform x1 x2 xml:base xml:lang xml:space y1 y2'),\n    'linearGradient':       o('class externalResourcesRequired gradientTransform gradientUnits id spreadMethod style x1 x2 xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space y1 y2'),\n    'marker':               o('class externalResourcesRequired id markerHeight markerUnits markerWidth orient preserveAspectRatio refX refY style viewBox xml:base xml:lang xml:space'),\n    'mask':                 o('class externalResourcesRequired height id maskContentUnits maskUnits requiredExtensions requiredFeatures style systemLanguage width x xml:base xml:lang xml:space y'),\n    'metadata':             o('id xml:base xml:lang xml:space'),\n    'missing-glyph':        o('class d horiz-adv-x id style vert-adv-y vert-origin-x vert-origin-y xml:base xml:lang xml:space'),\n    'mpath':                o('externalResourcesRequired id xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'path':                 o('class d externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup pathLength requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'pattern':              o('class externalResourcesRequired height id patternContentUnits patternTransform patternUnits preserveAspectRatio requiredExtensions requiredFeatures style systemLanguage viewBox width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'polygon':              o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup points requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'polyline':             o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup points requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'radialGradient':       o('class cx cy externalResourcesRequired fx fy gradientTransform gradientUnits id r spreadMethod style xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space'),\n    'rect':                 o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rx ry style systemLanguage transform width x xml:base xml:lang xml:space y'),\n    'script':               o('externalResourcesRequired id type xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'set':                  o('attributeName attributeType begin dur end externalResourcesRequired fill id max min onbegin onend onload onrepeat repeatCount repeatDur requiredExtensions requiredFeatures restart systemLanguage to xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space'),\n    'stop':                 o('class id offset style xml:base xml:lang xml:space'),\n    'style':                o('id media title type xml:base xml:lang xml:space'),\n    'svg':                  o('baseProfile class contentScriptType contentStyleType externalResourcesRequired height id onabort onactivate onclick onerror onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup onresize onscroll onunload onzoom preserveAspectRatio requiredExtensions requiredFeatures style systemLanguage version viewBox width x xml:base xml:lang xml:space y zoomAndPan'),\n    'switch':               o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform xml:base xml:lang xml:space'),\n    'symbol':               o('class externalResourcesRequired id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup preserveAspectRatio style viewBox xml:base xml:lang xml:space'),\n    'text':                 o('class dx dy externalResourcesRequired id lengthAdjust onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage textLength transform x xml:base xml:lang xml:space y'),\n    'textPath':             o('class externalResourcesRequired id lengthAdjust method onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures spacing startOffset style systemLanguage textLength xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space'),\n    'title':                o('class id style xml:base xml:lang xml:space'),\n    'tref':                 o('class dx dy externalResourcesRequired id lengthAdjust onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage textLength x xlink:arcrole xlink:href xlink:role xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'tspan':                o('class dx dy externalResourcesRequired id lengthAdjust onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures rotate style systemLanguage textLength x xml:base xml:lang xml:space y'),\n    'use':                  o('class externalResourcesRequired height id onactivate onclick onfocusin onfocusout onload onmousedown onmousemove onmouseout onmouseover onmouseup requiredExtensions requiredFeatures style systemLanguage transform width x xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xml:lang xml:space y'),\n    'view':                 o('externalResourcesRequired id preserveAspectRatio viewBox viewTarget xml:base xml:lang xml:space zoomAndPan'),\n    'vkern':                o('g1 g2 id k u1 u2 xml:base xml:lang xml:space'),\n  });\n\n  /** @internal */\n  private readonly _svgPresentationElements = o('a altGlyph animate animateColor circle clipPath defs ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset feSpecularLighting feTile feTurbulence filter font foreignObject g glyph glyphRef image line linearGradient marker mask missing-glyph path pattern polygon polyline radialGradient rect stop svg switch symbol text textPath tref tspan use');\n\n  /** @internal */\n  private readonly _svgPresentationAttributes = o('alignment-baseline baseline-shift clip-path clip-rule clip color-interpolation-filters color-interpolation color-profile color-rendering color cursor direction display dominant-baseline enable-background fill-opacity fill-rule fill filter flood-color flood-opacity font-family font-size-adjust font-size font-stretch font-style font-variant font-weight glyph-orientation-horizontal glyph-orientation-vertical image-rendering kerning letter-spacing lighting-color marker-end marker-mid marker-start mask opacity overflow pointer-events shape-rendering stop-color stop-opacity stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width stroke text-anchor text-decoration text-rendering unicode-bidi visibility word-spacing writing-mode');\n\n  /** @internal */\n  private readonly SVGElement: typeof SVGElement;\n  public constructor() {\n    const platform = resolve(IPlatform);\n    this.SVGElement = platform.globalThis.SVGElement;\n\n    const div = platform.document.createElement('div');\n    div.innerHTML = '<svg><altGlyph /></svg>';\n    if (div.firstElementChild!.nodeName === 'altglyph') {\n      // handle chrome casing inconsistencies.\n      const svg = this._svgElements;\n      let tmp = svg.altGlyph;\n      svg.altGlyph = svg.altglyph;\n      svg.altglyph = tmp;\n      tmp = svg.altGlyphDef;\n      svg.altGlyphDef = svg.altglyphdef;\n      svg.altglyphdef = tmp;\n      tmp = svg.altGlyphItem;\n      svg.altGlyphItem = svg.altglyphitem;\n      svg.altglyphitem = tmp;\n      tmp = svg.glyphRef;\n      svg.glyphRef = svg.glyphref;\n      svg.glyphref = tmp;\n    }\n  }\n\n  public isStandardSvgAttribute(node: INode, attributeName: string): boolean {\n    if (!(node instanceof this.SVGElement)) {\n      return false;\n    }\n\n    return (\n      this._svgPresentationElements[node.nodeName] === true && this._svgPresentationAttributes[attributeName] === true ||\n      this._svgElements[node.nodeName]?.[attributeName] === true\n    );\n  }\n}\n", "import { isDataAttribute } from '../utilities';\nimport { ISVGAnalyzer } from '../observation/svg-analyzer';\nimport { createLookup, createImplementationRegister, resolve } from '@aurelia/kernel';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { IAttrMapper, type IsTwoWayPredicate } from '@aurelia/template-compiler';\n\nexport class AttrMapper implements IAttrMapper {\n  public static register = /*@__PURE__*/ createImplementationRegister(IAttrMapper);\n\n  /** @internal */ private readonly fns: IsTwoWayPredicate[] = [];\n  /** @internal */ private readonly _tagAttrMap: Record<string, Record<string, PropertyKey>> = createLookup();\n  /** @internal */ private readonly _globalAttrMap: Record<string, PropertyKey> = createLookup();\n  private readonly svg = resolve(ISVGAnalyzer);\n\n  public constructor() {\n    this.useMapping({\n      LABEL: { for: 'htmlFor' },\n      IMG: { usemap: 'useMap' },\n      INPUT: {\n        maxlength: 'maxLength',\n        minlength: 'minLength',\n        formaction: 'formAction',\n        formenctype: 'formEncType',\n        formmethod: 'formMethod',\n        formnovalidate: 'formNoValidate',\n        formtarget: 'formTarget',\n        inputmode: 'inputMode',\n      },\n      TEXTAREA: { maxlength: 'maxLength' },\n      TD: { rowspan: 'rowSpan', colspan: 'colSpan' },\n      TH: { rowspan: 'rowSpan', colspan: 'colSpan' },\n    });\n    this.useGlobalMapping({\n      accesskey: 'accessKey',\n      contenteditable: 'contentEditable',\n      tabindex: 'tabIndex',\n      textcontent: 'textContent',\n      innerhtml: 'innerHTML',\n      scrolltop: 'scrollTop',\n      scrollleft: 'scrollLeft',\n      readonly: 'readOnly',\n    });\n  }\n\n  /**\n   * Allow application to teach Aurelia how to define how to map attributes to properties\n   * based on element tagName\n   */\n  public useMapping(config: Record<string, Record<string, PropertyKey>>): void {\n    let newAttrMapping: Record<string, PropertyKey>;\n    let targetAttrMapping: Record<string, PropertyKey>;\n    let tagName: string;\n    let attr: string;\n    for (tagName in config) {\n      newAttrMapping = config[tagName];\n      targetAttrMapping = this._tagAttrMap[tagName] ??= createLookup();\n      for (attr in newAttrMapping) {\n        if (targetAttrMapping[attr] !== void 0) {\n          throw createError(attr, tagName);\n        }\n        targetAttrMapping[attr] = newAttrMapping[attr];\n      }\n    }\n  }\n\n  /**\n   * Allow applications to teach Aurelia how to define how to map attributes to properties\n   * for all elements\n   */\n  public useGlobalMapping(config: Record<string, PropertyKey>): void {\n    const mapper = this._globalAttrMap;\n    for (const attr in config) {\n      if (mapper[attr] !== void 0) {\n        throw createError(attr, '*');\n      }\n      mapper[attr] = config[attr];\n    }\n  }\n\n  /**\n   * Add a given function to a list of fns that will be used\n   * to check if `'bind'` command can be understood as `'two-way'` command.\n   */\n  public useTwoWay(fn: IsTwoWayPredicate): void {\n    this.fns.push(fn);\n  }\n\n  /**\n   * Returns true if an attribute should be two way bound based on an element\n   */\n  public isTwoWay(node: Element, attrName: string): boolean {\n    return shouldDefaultToTwoWay(node, attrName)\n      || this.fns.length > 0 && this.fns.some(fn => fn(node, attrName));\n  }\n\n  /**\n   * Retrieves the mapping information this mapper have for an attribute on an element\n   */\n  public map(node: Element, attr: string): string | null {\n    return this._tagAttrMap[node.nodeName]?.[attr] as string\n      ?? this._globalAttrMap[attr]\n      ?? (isDataAttribute(node, attr, this.svg)\n        ? attr\n        : null);\n  }\n}\n\nfunction shouldDefaultToTwoWay(element: Element, attr: string): boolean {\n  switch (element.nodeName) {\n    case 'INPUT':\n      switch ((element as HTMLInputElement).type) {\n        case 'checkbox':\n        case 'radio':\n          return attr === 'checked';\n        // note:\n        // ideally, it should check for corresponding input type first\n        // as 'files' shouldn't be two way on a number input, for example\n        // but doing it this way is acceptable-ish, as the common user expectations,\n        // and the behavior of the control for these properties are the same,\n        // regardless the type of the <input>\n        default:\n          return attr === 'value' || attr === 'files' || attr === 'value-as-number' || attr === 'value-as-date';\n      }\n    case 'TEXTAREA':\n    case 'SELECT':\n      return attr === 'value';\n    default:\n      switch (attr) {\n        case 'textcontent':\n        case 'innerhtml':\n          return element.hasAttribute('contenteditable');\n        case 'scrolltop':\n        case 'scrollleft':\n          return true;\n        default:\n          return false;\n      }\n  }\n}\n\nfunction createError(attr: string, tagName: string) {\n  return createMappedError(ErrorNames.compiler_attr_mapper_duplicate_mapping, attr, tagName);\n}\n", "import {\n  createLookup,\n  createImplementationRegister,\n  type IContainer,\n  type IRegistry\n} from '@aurelia/kernel';\nimport {\n  type IAttributeBindablesInfo,\n  type IElementBindablesInfo,\n  IResourceResolver,\n  TemplateCompiler,\n} from '@aurelia/template-compiler';\nimport { BindableDefinition } from '../bindable';\nimport { defaultMode } from '../binding/interfaces-bindings';\nimport { CustomAttribute } from '../resources/custom-attribute';\nimport { CustomElement, CustomElementDefinition } from '../resources/custom-element';\n\nimport { ErrorNames, createMappedError } from '../errors';\nimport type { CustomAttributeDefinition } from '../resources/custom-attribute';\nimport { AttrMapper } from './attribute-mapper';\n\n/**\n * A group of registrations to connect the template compiler with the aurelia runtime implementation\n */\nexport const RuntimeTemplateCompilerImplementation: IRegistry = {\n  register(container) {\n    container.register(\n      TemplateCompiler,\n      AttrMapper,\n      ResourceResolver,\n    );\n  }\n};\n\nclass BindablesInfo {\n  public constructor(\n    public readonly attrs: Record<string, BindableDefinition>,\n    public readonly bindables: Record<string, BindableDefinition>,\n    public readonly primary: BindableDefinition | null,\n  ) {}\n}\n\nclass ResourceResolver implements IResourceResolver<CustomElementDefinition, CustomAttributeDefinition> {\n  public static register = /*@__PURE__*/ createImplementationRegister(IResourceResolver);\n\n  /** @internal */\n  private readonly _resourceCache = new WeakMap<IContainer, RecordCache>();\n\n  public el(c: IContainer, name: string): CustomElementDefinition | null {\n    let record = this._resourceCache.get(c);\n    if (record == null) {\n      this._resourceCache.set(c, record = new RecordCache());\n    }\n    return name in record._element ? record._element[name] : (record._element[name] = CustomElement.find(c, name));\n  }\n\n  public attr(c: IContainer, name: string): CustomAttributeDefinition | null {\n    let record = this._resourceCache.get(c);\n    if (record == null) {\n      this._resourceCache.set(c, record = new RecordCache());\n    }\n    return name in record._attr ? record._attr[name] : (record._attr[name] = CustomAttribute.find(c, name));\n  }\n\n  /** @internal */\n  private readonly _bindableCache = new WeakMap<CustomElementDefinition | CustomAttributeDefinition, BindablesInfo>();\n\n  public bindables(def: CustomAttributeDefinition): IAttributeBindablesInfo;\n  public bindables(def: CustomElementDefinition): IElementBindablesInfo;\n  public bindables(def: CustomAttributeDefinition | CustomElementDefinition): IAttributeBindablesInfo | IElementBindablesInfo {\n    let info = this._bindableCache.get(def);\n    if (info == null) {\n      const bindables = def.bindables;\n      const attrs = createLookup<BindableDefinition>();\n      let bindable: BindableDefinition | undefined;\n      let prop: string;\n      let hasPrimary: boolean = false;\n      let primary: BindableDefinition | undefined;\n      let attr: string;\n\n      // from all bindables, pick the first primary bindable\n      // if there is no primary, pick the first bindable\n      // if there's no bindables, create a new primary with property value\n      for (prop in bindables) {\n        bindable = bindables[prop];\n        attr = bindable.attribute;\n        if (bindable.primary === true) {\n          if (hasPrimary) {\n            throw createMappedError(ErrorNames.compiler_primary_already_existed, def);\n          }\n          hasPrimary = true;\n          primary = bindable;\n        } else if (!hasPrimary && primary == null) {\n          primary = bindable;\n        }\n\n        attrs[attr] = BindableDefinition.create(prop, bindable);\n      }\n      if (bindable == null && def.type === 'custom-attribute') {\n        // if no bindables are present, default to \"value\"\n        primary = attrs.value = BindableDefinition.create(\n          'value',\n          { mode: def.defaultBindingMode ?? defaultMode }\n        );\n      }\n\n      this._bindableCache.set(def, info = new BindablesInfo(attrs, bindables, primary ?? null));\n    }\n    return info;\n  }\n}\n\nclass RecordCache {\n  public _element = createLookup<CustomElementDefinition | null>();\n  public _attr = createLookup<CustomAttributeDefinition | null>();\n}\n", "import { createLookup } from '@aurelia/kernel';\nimport { atLayout, atNode } from '../utilities';\n\nimport type { AccessorType, IAccessor } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\n\nconst nsMap: Record<string, AttributeNSAccessor> = createLookup();\n\n/**\n * Attribute accessor in a XML document/element that can be accessed via a namespace.\n * Wraps [`getAttributeNS`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS).\n */\nexport class AttributeNSAccessor implements IAccessor<string | null> {\n  static {\n    mixinNoopSubscribable(AttributeNSAccessor);\n  }\n\n  public static forNs(ns: string): AttributeNSAccessor {\n    return nsMap[ns] ??= new AttributeNSAccessor(ns);\n  }\n\n  // ObserverType.Layout is not always true, it depends on the property\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  public constructor(\n    /**\n     * The namespace associated with this accessor\n     */\n    public readonly ns: string,\n  ) {\n  }\n\n  public getValue(obj: HTMLElement, propertyKey: string): string | null {\n    return obj.getAttributeNS(this.ns, propertyKey);\n  }\n\n  public setValue(newValue: string | null, obj: HTMLElement, key: string): void {\n    if (newValue == null) {\n      obj.removeAttributeNS(this.ns, key);\n    } else {\n      obj.setAttributeNS(this.ns, key, newValue);\n    }\n  }\n}\n", "// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { IObserver, type AccessorType, type IAccessor, type PropertyAccessor } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\nimport { atLayout, atNode } from '../utilities';\n\n/**\n * Attribute accessor for HTML elements.\n * Note that Aurelia works with properties, so in all case it will try to assign to property instead of attributes.\n * Unless the property falls into a special set, then it will use attribute for it.\n *\n * @see PropertyAccessor\n */\nexport class DataAttributeAccessor implements IAccessor<string | null>, IObserver {\n  static {\n    mixinNoopSubscribable(DataAttributeAccessor);\n  }\n\n  // ObserverType.Layout is not always true, it depends on the property\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  // the followings come from the noop mixing\n  public subscribe!: () => void;\n  public unsubscribe!: () => void;\n\n  public getValue(obj: HTMLElement, key: string): string | null {\n    return obj.getAttribute(key);\n  }\n\n  public setValue(newValue: string | null, obj: HTMLElement, key: string): void {\n    if (newValue == null) {\n      obj.removeAttribute(key);\n    } else {\n      obj.setAttribute(key, newValue);\n    }\n  }\n}\n\nexport const attrAccessor = /*@__PURE__*/new DataAttributeAccessor();\n", "import {\n  subscriberCollection,\n  type AccessorType,\n  type ICollectionObserver,\n  type IObserverLocator,\n  type ISubscriberCollection,\n} from '@aurelia/runtime';\n\nimport type { INode } from '../dom.node';\nimport { atLayout, atNode, atObserver, hasOwnProperty } from '../utilities';\nimport { INodeObserver, INodeObserverConfigBase } from './observer-locator';\nimport { mixinNodeObserverUseConfig } from './observation-utils';\nimport { createMutationObserver } from '../utilities-dom';\nimport { ErrorNames, createMappedError } from '../errors';\nimport { isArray } from '@aurelia/kernel';\n\nexport interface ISelectElement extends HTMLSelectElement {\n  options: HTMLCollectionOf<IOptionElement> & Pick<HTMLOptionsCollection, 'length' | 'selectedIndex' | 'add' | 'remove'>;\n  matcher?: (a: unknown, b: unknown) => boolean;\n}\nexport interface IOptionElement extends HTMLOptionElement {\n  model?: unknown;\n}\n\nexport interface SelectValueObserver extends ISubscriberCollection {}\n\nexport class SelectValueObserver implements INodeObserver {\n  static {\n    mixinNodeObserverUseConfig(SelectValueObserver);\n    subscriberCollection(SelectValueObserver, null!);\n  }\n\n  /** @internal */\n  private static _getSelectedOptions(options: ArrayLike<IOptionElement>): unknown[] {\n    const selection: unknown[] = [];\n    if (options.length === 0) {\n      return selection;\n    }\n    const ii = options.length;\n    let i = 0;\n    let option: IOptionElement;\n    while (ii > i) {\n      option = options[i];\n      if (option.selected) {\n        selection[selection.length] = hasOwnProperty.call(option, 'model') ? option.model : option.value;\n      }\n      ++i;\n    }\n    return selection;\n  }\n\n  /** @internal */\n  private static _defaultMatcher(a: unknown, b: unknown): boolean {\n    return a === b;\n  }\n\n  // ObserverType.Layout is not always true\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atObserver | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  /** @internal */\n  private _oldValue: unknown = void 0;\n\n  /** @internal */\n  public readonly _el: ISelectElement;\n\n  /** @internal */\n  private _hasChanges: boolean = false;\n  /** @internal */\n  private _arrayObserver?: ICollectionObserver<'array'> = void 0;\n  /** @internal */\n  private _nodeObserver?: MutationObserver = void 0;\n\n  /** @internal */\n  private _observing: boolean = false;\n\n  /** @internal */\n  private readonly _observerLocator: IObserverLocator;\n\n  /**\n   * Used by mixing defined methods subscribe/unsubscribe\n   *\n   * @internal\n   */\n  public _listened: boolean = false;\n\n  /** @internal */\n  public _config: INodeObserverConfigBase;\n\n  /**\n   * Comes from mixin\n   */\n  public useConfig!: (config: INodeObserverConfigBase) => void;\n\n  public constructor(\n    obj: INode,\n    // deepscan-disable-next-line\n    _key: PropertyKey,\n    config: INodeObserverConfigBase,\n    observerLocator: IObserverLocator,\n  ) {\n    this._el = obj as ISelectElement;\n    this._observerLocator = observerLocator;\n    this._config = config;\n  }\n\n  public getValue(): unknown {\n    // is it safe to assume the observer has the latest value?\n    // todo: ability to turn on/off cache based on type\n    return this._observing\n      ? this._value\n      : this._el.multiple\n        // todo: maybe avoid double iteration?\n        ? SelectValueObserver._getSelectedOptions(this._el.options)\n        : this._el.value;\n  }\n\n  public setValue(newValue: unknown): void {\n    this._oldValue = this._value;\n    this._value = newValue;\n    this._hasChanges = newValue !== this._oldValue;\n    this._observeArray(newValue instanceof Array ? newValue : null);\n    this._flushChanges();\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    if (this._hasChanges) {\n      this._hasChanges = false;\n      this.syncOptions();\n    }\n  }\n\n  public handleCollectionChange(): void {\n    // always sync \"selected\" property of <options/>\n    // immediately whenever the array notifies its mutation\n    this.syncOptions();\n  }\n\n  public syncOptions(): void {\n    const value = this._value;\n    const obj = this._el;\n    const $isArray = isArray(value);\n    const matcher = obj.matcher ?? SelectValueObserver._defaultMatcher;\n    const options = obj.options;\n    let i = options.length;\n\n    while (i-- > 0) {\n      const option = options[i];\n      const optionValue = hasOwnProperty.call(option, 'model') ? option.model : option.value;\n      if ($isArray) {\n        option.selected = value.findIndex(item => !!matcher(optionValue, item)) !== -1;\n        continue;\n      }\n      option.selected = !!matcher(optionValue, value);\n    }\n  }\n\n  public syncValue(): boolean {\n    // Spec for synchronizing value from `<select/>`  to `SelectObserver`\n    // When synchronizing value to observed <select/> element, do the following steps:\n    // A. If `<select/>` is multiple\n    //    1. Check if current value, called `currentValue` is an array\n    //      a. If not an array, return true to signal value has changed\n    //      b. If is an array:\n    //        i. gather all current selected <option/>, in to array called `values`\n    //        ii. loop through the `currentValue` array and remove items that are nolonger selected based on matcher\n    //        iii. loop through the `values` array and add items that are selected based on matcher\n    //        iv. Return false to signal value hasn't changed\n    // B. If the select is single\n    //    1. Let `value` equal the first selected option, if no option selected, then `value` is `null`\n    //    2. assign `this.currentValue` to `this.oldValue`\n    //    3. assign `value` to `this.currentValue`\n    //    4. return `true` to signal value has changed\n    const obj = this._el;\n    const options = obj.options;\n    const len = options.length;\n    const currentValue = this._value;\n    let i = 0;\n\n    if (obj.multiple) {\n      // A.\n      if (!(currentValue instanceof Array)) {\n        // A.1.a\n        return true;\n      }\n      // A.1.b\n      // multi select\n      let option: IOptionElement;\n      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n      const matcher = obj.matcher || SelectValueObserver._defaultMatcher;\n      // A.1.b.i\n      const values: unknown[] = [];\n      while (i < len) {\n        option = options[i];\n        if (option.selected) {\n          values.push(hasOwnProperty.call(option, 'model')\n            ? option.model\n            : option.value\n          );\n        }\n        ++i;\n      }\n      let a: unknown;\n      // A.1.b.ii\n      i = 0;\n      while (i < currentValue.length) {\n        a = currentValue[i];\n        // Todo: remove arrow fn\n        if (values.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.splice(i, 1);\n        } else {\n          ++i;\n        }\n      }\n      // A.1.b.iii\n      i = 0;\n      while (i < values.length) {\n        a = values[i];\n        // Todo: remove arrow fn\n        if (currentValue.findIndex(b => !!matcher(a, b)) === -1) {\n          currentValue.push(a);\n        }\n        ++i;\n      }\n      // A.1.b.iv\n      return false;\n    }\n    // B. single select\n    // B.1\n    let value: unknown = null;\n    let option: IOptionElement;\n    while (i < len) {\n      option = options[i];\n      if (option.selected) {\n        value = hasOwnProperty.call(option, 'model')\n          ? option.model\n          : option.value;\n        break;\n      }\n      ++i;\n    }\n    // B.2\n    this._oldValue = this._value;\n    // B.3\n    this._value = value;\n    // B.4\n    return true;\n  }\n\n  /**\n   * Used by mixing defined methods subscribe\n   *\n   * @internal\n   */\n  public _start(): void {\n    (this._nodeObserver = createMutationObserver(this._el, this._handleNodeChange.bind(this))).observe(this._el, {\n      childList: true,\n      subtree: true,\n      characterData: true\n    });\n    this._observeArray(this._value instanceof Array ? this._value : null);\n    this._observing = true;\n  }\n\n  /**\n   * Used by mixing defined method unsubscribe\n   *\n   * @internal\n   */\n  public _stop(): void {\n    this._nodeObserver!.disconnect();\n    this._arrayObserver?.unsubscribe(this);\n    this._nodeObserver\n      = this._arrayObserver\n      = void 0;\n    this._observing = false;\n  }\n\n  // todo: observe all kind of collection\n  /** @internal */\n  private _observeArray(array: unknown[] | null): void {\n    this._arrayObserver?.unsubscribe(this);\n    this._arrayObserver = void 0;\n    if (array != null) {\n      if (!this._el.multiple) {\n        throw createMappedError(ErrorNames.select_observer_array_on_non_multi_select);\n      }\n      (this._arrayObserver = this._observerLocator.getArrayObserver(array)).subscribe(this);\n    }\n  }\n\n  public handleEvent(): void {\n    const shouldNotify = this.syncValue();\n    if (shouldNotify) {\n      this._flush();\n    }\n  }\n\n  /** @internal */\n  private _handleNodeChange(_records: MutationRecord[]): void {\n    // syncing options first means forcing the UI to take the existing state from the model\n    // example: if existing state has only 3 selected option\n    //          and it's adding a 4th <option/> with selected state\n    //          [selected] state will be disregarded as it's not present in the model\n    //          this force uni-direction flow: where UI update is only via user event, or model changes\n    //          Cons:\n    //          Sometimes, an <option selected /> maybe added to the UI, and causes confusion, as it's not selected anymore after the sync\n    //          Consider this before entering release candidate\n    this.syncOptions();\n    const shouldNotify = this.syncValue();\n    if (shouldNotify) {\n      this._flush();\n    }\n  }\n\n  /** @internal */\n  private _flush(): void {\n    const oV = this._oldValue;\n    this._oldValue = this._value;\n    this.subs.notify(this._value, oV);\n  }\n}\n", "import { emptyArray, kebabCase, isFunction, isString } from '@aurelia/kernel';\nimport { atLayout, atNode, hasOwnProperty } from '../utilities';\nimport type { AccessorType, IAccessor } from '@aurelia/runtime';\nimport { mixinNoopSubscribable } from './observation-utils';\n\nconst customPropertyPrefix: string = '--';\n\nexport class StyleAttributeAccessor implements IAccessor {\n  static {\n    mixinNoopSubscribable(StyleAttributeAccessor);\n  }\n\n  public type: AccessorType = (atNode | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = '';\n\n  /** @internal */\n  private _oldValue: unknown = '';\n\n  public styles: Record<string, number> = {};\n  public version: number = 0;\n\n  /** @internal */\n  private _hasChanges: boolean = false;\n\n  public constructor(\n    public readonly obj: HTMLElement,\n  ) {\n  }\n\n  public getValue(): string {\n    return this.obj.style.cssText;\n  }\n\n  public setValue(newValue: unknown): void {\n    this._value = newValue;\n    this._hasChanges = newValue !== this._oldValue;\n    this._flushChanges();\n  }\n\n  /** @internal */\n  private _getStyleTuplesFromString(currentValue: string): [string, string][] {\n    const styleTuples: [string, string][] = [];\n    const urlRegexTester = /url\\([^)]+$/;\n    let offset = 0;\n    let currentChunk = '';\n    let nextSplit: number;\n    let indexOfColon: number;\n    let attribute: string;\n    let value: string;\n    while (offset < currentValue.length) {\n      nextSplit = currentValue.indexOf(';', offset);\n      if (nextSplit === -1) { nextSplit = currentValue.length; }\n      currentChunk += currentValue.substring(offset, nextSplit);\n      offset = nextSplit + 1;\n\n      // Make sure we never split a url so advance to next\n      if (urlRegexTester.test(currentChunk)) {\n        currentChunk += ';';\n        continue;\n      }\n\n      indexOfColon = currentChunk.indexOf(':');\n      attribute = currentChunk.substring(0, indexOfColon).trim();\n      value = currentChunk.substring(indexOfColon + 1).trim();\n      styleTuples.push([attribute, value]);\n      currentChunk = '';\n    }\n\n    return styleTuples;\n  }\n\n  /** @internal */\n  private _getStyleTuplesFromObject(currentValue: Record<string, unknown>): [string, string][] {\n    let value: unknown;\n    let property: string;\n    const styles: [string, string][] = [];\n    for (property in currentValue) {\n      value = currentValue[property];\n      if (value == null) {\n        continue;\n      }\n      if (isString(value)) {\n        // Custom properties should not be tampered with\n        if (property.startsWith(customPropertyPrefix)) {\n          styles.push([property, value]);\n          continue;\n        }\n        styles.push([kebabCase(property), value]);\n        continue;\n      }\n\n      styles.push(...this._getStyleTuples(value));\n    }\n\n    return styles;\n  }\n\n  /** @internal */\n  private _getStyleTuplesFromArray(currentValue: unknown[]): [string, string][] {\n    const len = currentValue.length;\n    if (len > 0) {\n      const styles: [string, string][] = [];\n      let i = 0;\n      for (; len > i; ++i) {\n        styles.push(...this._getStyleTuples(currentValue[i]));\n      }\n      return styles;\n    }\n    return emptyArray;\n  }\n\n  /** @internal */\n  private _getStyleTuples(currentValue: unknown): [string, string][] {\n    if (isString(currentValue)) {\n      return this._getStyleTuplesFromString(currentValue);\n    }\n\n    if (currentValue instanceof Array) {\n      return this._getStyleTuplesFromArray(currentValue);\n    }\n\n    if (currentValue instanceof Object) {\n      return this._getStyleTuplesFromObject(currentValue as Record<string, unknown>);\n    }\n\n    return emptyArray;\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    if (this._hasChanges) {\n      this._hasChanges = false;\n      const currentValue = this._value;\n      const styles = this.styles;\n      const styleTuples = this._getStyleTuples(currentValue);\n\n      let style: string;\n      let version = this.version;\n\n      this._oldValue = currentValue;\n\n      let tuple: [string, string];\n      let name: string;\n      let value: string;\n      let i = 0;\n      const len = styleTuples.length;\n      for (; i < len; ++i) {\n        tuple = styleTuples[i];\n        name = tuple[0];\n        value = tuple[1];\n        this.setProperty(name, value);\n        styles[name] = version;\n      }\n\n      this.styles = styles;\n      this.version += 1;\n      if (version === 0) {\n        return;\n      }\n\n      version -= 1;\n      for (style in styles) {\n        if (!hasOwnProperty.call(styles, style) || styles[style] !== version) {\n          continue;\n        }\n        this.obj.style.removeProperty(style);\n      }\n    }\n  }\n\n  public setProperty(style: string, value: string): void {\n    let priority = '';\n\n    if (value != null && isFunction(value.indexOf) && value.includes('!important')) {\n      priority = 'important';\n      value = value.replace('!important', '');\n    }\n\n    this.obj.style.setProperty(style, value, priority);\n  }\n\n  public bind(): void {\n    this._value = this._oldValue = this.obj.style.cssText;\n  }\n\n  // the followings come from the noop mixing\n  /** @internal */ public subscribe!: () => void;\n  /** @internal */ public unsubscribe!: () => void;\n}\n", "import { type IIndexable, areEqual } from '@aurelia/kernel';\nimport { subscriberCollection } from '@aurelia/runtime';\nimport { mixinNodeObserverUseConfig } from './observation-utils';\nimport { atLayout, atNode, atObserver } from '../utilities';\n\nimport type { AccessorType, ISubscriberCollection } from '@aurelia/runtime';\nimport type { INode } from '../dom.node';\nimport type { INodeObserver, INodeObserverConfigBase } from './observer-locator';\n\nexport interface ValueAttributeObserver extends ISubscriberCollection {}\n/**\n * Observer for non-radio, non-checkbox input.\n */\nexport class ValueAttributeObserver implements INodeObserver {\n  static {\n    mixinNodeObserverUseConfig(ValueAttributeObserver);\n    subscriberCollection(ValueAttributeObserver, null!);\n  }\n\n  // ObserverType.Layout is not always true, it depends on the element & property combo\n  // but for simplicity, always treat as such\n  public type: AccessorType = (atNode | atObserver | atLayout) as AccessorType;\n\n  /** @internal */\n  public readonly _el: INode & IIndexable;\n\n  /** @internal */\n  private readonly _key: PropertyKey;\n\n  /** @internal */\n  private _value: unknown = '';\n\n  /** @internal */\n  private _oldValue: unknown = '';\n\n  /** @internal */\n  private _hasChanges: boolean = false;\n\n  /**\n   * Used by mixing defined methods subscribe/unsubscribe\n   *\n   * @internal\n   */\n  public _listened: boolean = false;\n\n  /** @internal */\n  public _config: INodeObserverConfigBase;\n\n  /**\n   * Comes from mixin\n   */\n  public useConfig!: (config: INodeObserverConfigBase) => void;\n\n  public constructor(\n    obj: INode,\n    key: PropertyKey,\n    config:  INodeObserverConfigBase,\n  ) {\n    this._el = obj as INode & IIndexable;\n    this._key = key;\n    this._config = config;\n  }\n\n  public getValue(): unknown {\n    // is it safe to assume the observer has the latest value?\n    // todo: ability to turn on/off cache based on type\n    return this._value;\n  }\n\n  public setValue(newValue: string | null): void {\n    if (areEqual(newValue, this._value)) {\n      return;\n    }\n    this._oldValue = this._value;\n    this._value = newValue;\n    this._hasChanges = true;\n    if (!this._config.readonly) {\n      this._flushChanges();\n    }\n  }\n\n  /** @internal */\n  private _flushChanges(): void {\n    if (this._hasChanges) {\n      this._hasChanges = false;\n      this._el[this._key as string] = this._value ?? this._config.default;\n      this._flush();\n    }\n  }\n\n  public handleEvent(): void {\n    this._oldValue = this._value;\n    this._value = this._el[this._key as string];\n    if (this._oldValue !== this._value) {\n      this._hasChanges = false;\n      this._flush();\n    }\n  }\n\n  /**\n   * Used by mixing defined methods subscribe\n   *\n   * @internal\n   */\n  public _start(): void {\n    this._value = this._oldValue = this._el[this._key as string];\n  }\n\n  /** @internal */\n  private _flush() {\n    const oV = this._oldValue;\n    this._oldValue = this._value;\n    this.subs.notify(this._value, oV);\n  }\n}\n", "import { createImplementationRegister, createLookup, emptyObject, IServiceLocator, isString, resolve } from '@aurelia/kernel';\nimport {\n  getObserverLookup,\n  IDirtyChecker,\n  INodeObserverLocator,\n  IObserverLocator,\n  PropertyAccessor,\n  SetterObserver,\n} from '@aurelia/runtime';\nimport { IPlatform } from '../platform';\nimport { AttributeNSAccessor } from './attribute-ns-accessor';\nimport { CheckedObserver } from './checked-observer';\nimport { ClassAttributeAccessor } from './class-attribute-accessor';\nimport { attrAccessor } from './data-attribute-accessor';\nimport { SelectValueObserver } from './select-value-observer';\nimport { StyleAttributeAccessor } from './style-attribute-accessor';\nimport { ISVGAnalyzer } from './svg-analyzer';\nimport { ValueAttributeObserver } from './value-attribute-observer';\nimport { atLayout, atNode, isDataAttribute, objectAssign } from '../utilities';\n\nimport type { IIndexable } from '@aurelia/kernel';\nimport type { AccessorType, IAccessor, IObserver, ICollectionObserver, CollectionKind } from '@aurelia/runtime';\nimport type { INode } from '../dom.node';\nimport { createMappedError, ErrorNames } from '../errors';\n\nconst nsAttributes = (() => {\n  // https://infra.spec.whatwg.org/#namespaces\n  // const htmlNS = 'http://www.w3.org/1999/xhtml';\n  // const mathmlNS = 'http://www.w3.org/1998/Math/MathML';\n  // const svgNS = 'http://www.w3.org/2000/svg';\n  const xlinkNS = 'http://www.w3.org/1999/xlink';\n  const xmlNS = 'http://www.w3.org/XML/1998/namespace';\n  const xmlnsNS = 'http://www.w3.org/2000/xmlns/';\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n  return objectAssign(\n    createLookup<[string, string]>(),\n    {\n      'xlink:actuate': ['actuate', xlinkNS],\n      'xlink:arcrole': ['arcrole', xlinkNS],\n      'xlink:href': ['href', xlinkNS],\n      'xlink:role': ['role', xlinkNS],\n      'xlink:show': ['show', xlinkNS],\n      'xlink:title': ['title', xlinkNS],\n      'xlink:type': ['type', xlinkNS],\n      'xml:lang': ['lang', xmlNS],\n      'xml:space': ['space', xmlNS],\n      'xmlns': ['xmlns', xmlnsNS],\n      'xmlns:xlink': ['xlink', xmlnsNS],\n    },\n  );\n})();\n\nconst elementPropertyAccessor = new PropertyAccessor();\nelementPropertyAccessor.type = (atNode | atLayout) as AccessorType;\n\nexport interface INodeObserverConfigBase {\n  /**\n   * Indicates the list of events can be used to observe a particular property\n   */\n  readonly events: string[];\n  /**\n   * Indicates whether this property is readonly, so observer wont attempt to assign value\n   * example: input.files\n   */\n  readonly readonly?: boolean;\n  /**\n   * A default value to assign to the corresponding property if the incoming value is null/undefined\n   */\n  readonly default?: unknown;\n}\n\nexport interface INodeObserver extends IObserver {\n  /**\n   * Instruct this node observer event observation behavior\n   */\n  useConfig(config: INodeObserverConfigBase): void;\n}\n\nexport type INodeObserverConstructor =\n  new (\n    el: INode,\n    key: PropertyKey,\n    config: INodeObserverConfig,\n    observerLocator: IObserverLocator,\n    locator: IServiceLocator,\n  ) => INodeObserver;\n\nexport interface INodeObserverConfig {\n  /**\n   * The observer constructor to use\n   */\n  readonly type?: INodeObserverConstructor;\n  /**\n   * Indicates the list of events can be used to observe a particular property\n   */\n  readonly events: string[];\n  /**\n   * Indicates whether this property is readonly, so observer wont attempt to assign value\n   * example: input.files\n   */\n  readonly readonly?: boolean;\n  /**\n   * A default value to assign to the corresponding property if the incoming value is null/undefined\n   */\n  readonly default?: unknown;\n}\n\nexport class NodeObserverLocator implements INodeObserverLocator {\n  public static register = /*@__PURE__*/ createImplementationRegister(INodeObserverLocator);\n\n  /**\n   * Indicates whether the node observer will be allowed to use dirty checking for a property it doesn't know how to observe\n   */\n  public allowDirtyCheck: boolean = true;\n\n  /** @internal */\n  private readonly _events: Record<string, Record<string, INodeObserverConfig>> = createLookup();\n  /** @internal */\n  private readonly _globalEvents: Record<string, INodeObserverConfig> = createLookup();\n  /** @internal */\n  private readonly _overrides: Record<string, Record<string, true>> = createLookup();\n  /** @internal */\n  private readonly _globalOverrides: Record<string, true> = createLookup();\n\n  /** @internal */\n  private readonly _locator = resolve(IServiceLocator);\n  /** @internal */\n  private readonly _platform = resolve(IPlatform);\n  /** @internal */\n  private readonly _dirtyChecker = resolve(IDirtyChecker);\n  /** @internal */\n  private readonly svg = resolve(ISVGAnalyzer);\n\n  public constructor() {\n    // todo: atm, platform is required to be resolved too eagerly for the `.handles()` check\n    // also a lot of tests assume default availability of observation\n    // those 2 assumptions make it not the right time to extract the following line into a\n    // default configuration for NodeObserverLocator yet\n    // but in the future, they should be, so apps that don't use check box/select, or implement a different\n    // observer don't have to pay the of the default implementation\n    const inputEvents = ['change', 'input'];\n    const inputEventsConfig: INodeObserverConfig = { events: inputEvents, default: '' };\n    this.useConfig({\n      INPUT: {\n        value: inputEventsConfig,\n        valueAsNumber: { events: inputEvents, default: 0 },\n        checked: { type: CheckedObserver, events: inputEvents } ,\n        files: { events: inputEvents, readonly: true },\n      },\n      SELECT: {\n        value: { type: SelectValueObserver, events: ['change'], default: '' },\n      },\n      TEXTAREA: {\n        value: inputEventsConfig,\n      },\n    });\n\n    const contentEventsConfig: INodeObserverConfig = { events: ['change', 'input', 'blur', 'keyup', 'paste'], default: '' };\n    const scrollEventsConfig: INodeObserverConfig = { events: ['scroll'], default: 0 };\n    this.useConfigGlobal({\n      scrollTop: scrollEventsConfig,\n      scrollLeft: scrollEventsConfig,\n      textContent: contentEventsConfig,\n      innerHTML: contentEventsConfig,\n    });\n\n    this.overrideAccessorGlobal('css', 'style', 'class');\n    this.overrideAccessor({\n      INPUT: ['value', 'checked', 'model'],\n      SELECT: ['value'],\n      TEXTAREA: ['value'],\n    });\n  }\n\n  // deepscan-disable-next-line\n  public handles(obj: unknown, _key: PropertyKey): boolean {\n    return obj instanceof this._platform.Node;\n  }\n\n  public useConfig(config: Record<string, Record<string, INodeObserverConfig>>): void;\n  public useConfig(nodeName: string, key: PropertyKey, events: INodeObserverConfig): void;\n  public useConfig(nodeNameOrConfig: string | Record<string, Record<string, INodeObserverConfig>>, key?: PropertyKey, eventsConfig?: INodeObserverConfig): void {\n    const lookup = this._events;\n    let existingMapping: Record<string, INodeObserverConfig>;\n    if (isString(nodeNameOrConfig)) {\n      existingMapping = lookup[nodeNameOrConfig] ??= createLookup();\n      if (existingMapping[key as string] == null) {\n        existingMapping[key as string] = eventsConfig!;\n      } else {\n        throwMappingExisted(nodeNameOrConfig, key!);\n      }\n    } else {\n      for (const nodeName in nodeNameOrConfig) {\n        existingMapping = lookup[nodeName] ??= createLookup();\n        const newMapping = nodeNameOrConfig[nodeName];\n        for (key in newMapping) {\n          if (existingMapping[key] == null) {\n            existingMapping[key] = newMapping[key];\n          } else {\n            throwMappingExisted(nodeName, key);\n          }\n        }\n      }\n    }\n  }\n\n  public useConfigGlobal(config: Record<string, INodeObserverConfig>): void;\n  public useConfigGlobal(key: PropertyKey, events: INodeObserverConfig): void;\n  public useConfigGlobal(configOrKey: PropertyKey | Record<string, INodeObserverConfig>, eventsConfig?: INodeObserverConfig): void {\n    const lookup = this._globalEvents;\n    if (typeof configOrKey === 'object') {\n      for (const key in configOrKey) {\n        if (lookup[key] == null) {\n          lookup[key] = configOrKey[key];\n        } else {\n          throwMappingExisted('*', key);\n        }\n      }\n    } else {\n      if (lookup[configOrKey as string] == null) {\n        lookup[configOrKey as string] = eventsConfig!;\n      } else {\n        throwMappingExisted('*', configOrKey);\n      }\n    }\n  }\n\n  // deepscan-disable-nextline\n  public getAccessor(obj: HTMLElement, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver {\n    if (key in this._globalOverrides || (key in (this._overrides[obj.tagName] ?? emptyObject))) {\n      return this.getObserver(obj, key, requestor);\n    }\n    switch (key) {\n      // class / style / css attribute will be observed using .getObserver() per overrides\n      //\n      // TODO: there are (many) more situation where we want to default to DataAttributeAccessor\n      case 'src':\n      case 'href':\n      case 'role':\n      case 'minLength':\n      case 'maxLength':\n      case 'placeholder':\n      case 'size':\n      case 'pattern':\n      case 'title':\n      case 'popovertarget':\n      case 'popovertargetaction':\n        /* istanbul-ignore-next */\n        if (__DEV__) {\n          if ((key === 'popovertarget' || key === 'popovertargetaction') && obj.nodeName !== 'INPUT' && obj.nodeName !== 'BUTTON') {\n            // eslint-disable-next-line no-console\n            console.warn(`[aurelia] Popover API are only valid on <input> or <button>. Detected ${key} on <${obj.nodeName.toLowerCase()}>`);\n          }\n        }\n        // assigning null/undefined to size on input is an error\n        // though it may be fine on other elements.\n        // todo: make an effort to distinguish properties based on element name\n        // https://html.spec.whatwg.org/multipage/dom.html#wai-aria\n        return attrAccessor;\n      default: {\n        const nsProps = nsAttributes[key as string];\n        if (nsProps !== undefined) {\n          return AttributeNSAccessor.forNs(nsProps[1]);\n        }\n        if (isDataAttribute(obj, key, this.svg)) {\n          return attrAccessor;\n        }\n        return elementPropertyAccessor;\n      }\n    }\n  }\n\n  /**\n   * For a list of specific elements\n   * compose a list of properties, based on different tag name,\n   * indicating that an overser should be returned instead of an accessor in `.getAccessor()`\n   */\n  public overrideAccessor(overrides: Record<string, string[]>): void;\n  public overrideAccessor(tagName: string, key: PropertyKey): void;\n  public overrideAccessor(tagNameOrOverrides: string | Record<string, string[]>, key?: PropertyKey): void {\n    let existingTagOverride: Record<string, true> | undefined;\n    if (isString(tagNameOrOverrides)) {\n      existingTagOverride = this._overrides[tagNameOrOverrides] ??= createLookup();\n      existingTagOverride[key as string] = true;\n    } else {\n      for (const tagName in tagNameOrOverrides) {\n        for (const key of tagNameOrOverrides[tagName]) {\n          existingTagOverride =this._overrides[tagName] ??= createLookup();\n          existingTagOverride[key] = true;\n        }\n      }\n    }\n  }\n\n  /**\n   * For all elements:\n   * compose a list of properties,\n   * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`\n   */\n  public overrideAccessorGlobal(...keys: string[]): void {\n    for (const key of keys) {\n      this._globalOverrides[key] = true;\n    }\n  }\n\n  public getNodeObserverConfig(el: HTMLElement, key: PropertyKey): INodeObserverConfig | undefined {\n    return this._events[el.tagName]?.[key as string] ?? this._globalEvents[key as string];\n  }\n\n  public getNodeObserver(el: HTMLElement, key: PropertyKey, requestor: IObserverLocator): INodeObserver | null {\n    const eventsConfig = this._events[el.tagName]?.[key as string] ?? this._globalEvents[key as string];\n    let observer: INodeObserver;\n    if (eventsConfig != null) {\n      observer = new (eventsConfig.type ?? ValueAttributeObserver)(el, key, eventsConfig, requestor, this._locator);\n      if (!observer.doNotCache) {\n        getObserverLookup(el)[key] = observer;\n      }\n      return observer;\n    }\n    return null;\n  }\n\n  public getObserver(el: HTMLElement, key: PropertyKey, requestor: IObserverLocator): IAccessor | IObserver {\n    switch (key) {\n      case 'class':\n        // todo: invalid accessor returned for a get observer call\n        //       for now it's a noop observer\n        return new ClassAttributeAccessor(el);\n      case 'css':\n      case 'style':\n        // todo: invalid accessor returned for a get observer call\n        //       for now it's a noop observer\n        return new StyleAttributeAccessor(el);\n    }\n    const nodeObserver = this.getNodeObserver(el, key, requestor);\n    if (nodeObserver != null) {\n      return nodeObserver;\n    }\n\n    const nsProps = nsAttributes[key as string];\n    if (nsProps !== undefined) {\n      // todo: invalid accessor returned for a get observer call\n      //       for now it's a noop observer\n      return AttributeNSAccessor.forNs(nsProps[1]);\n    }\n    if (isDataAttribute(el, key, this.svg)) {\n      // todo: invalid accessor returned for a get observer call\n      //       for now it's a noop observer\n      return attrAccessor;\n    }\n    if (key in el.constructor.prototype) {\n      if (this.allowDirtyCheck) {\n        return this._dirtyChecker.createProperty(el, key as string);\n      }\n      // consider:\n      // - maybe add a adapter API to handle unknown obj/key combo\n      throw createMappedError(ErrorNames.node_observer_strategy_not_found, key);\n    } else {\n      // todo: probably still needs to get the property descriptor via getOwnPropertyDescriptor\n      // but let's start with simplest scenario\n      return new SetterObserver(el as HTMLElement & IIndexable, key as string);\n    }\n  }\n}\n\nexport function getCollectionObserver(collection: unknown, observerLocator: IObserverLocator): ICollectionObserver<CollectionKind> | undefined {\n  if (collection instanceof Array) {\n    return observerLocator.getArrayObserver(collection);\n  }\n  if (collection instanceof Map) {\n    return observerLocator.getMapObserver(collection);\n  }\n  if (collection instanceof Set) {\n    return observerLocator.getSetObserver(collection);\n  }\n}\n\nfunction throwMappingExisted(nodeName: string, key: PropertyKey): never {\n  throw createMappedError(ErrorNames.node_observer_mapping_existed, nodeName, key);\n}\n", "import {\n  type CollectionKind,\n  SetterObserver,\n  subscriberCollection,\n  type AccessorType,\n  type ICollectionObserver,\n  type ISubscriberCollection,\n  type IObserverLocator,\n} from '@aurelia/runtime';\nimport { getCollectionObserver, INodeObserver, INodeObserverConfigBase } from './observer-locator';\nimport { atLayout, atNode, atObserver, hasOwnProperty } from '../utilities';\n\nimport type { INode } from '../dom.node';\nimport type { ValueAttributeObserver } from './value-attribute-observer';\nimport { mixinNodeObserverUseConfig } from './observation-utils';\nimport { isArray } from '@aurelia/kernel';\n\nexport interface IInputElement extends HTMLInputElement {\n  model?: unknown;\n  $observers?: {\n    model?: SetterObserver;\n    value?: ValueAttributeObserver;\n  };\n  matcher?: typeof defaultMatcher;\n}\n\nfunction defaultMatcher(a: unknown, b: unknown): boolean {\n  return a === b;\n}\n\nexport interface CheckedObserver extends\n  ISubscriberCollection { }\n\nexport class CheckedObserver implements INodeObserver {\n  static {\n    mixinNodeObserverUseConfig(CheckedObserver);\n    subscriberCollection(CheckedObserver, null!);\n  }\n\n  public type: AccessorType = (atNode | atObserver | atLayout) as AccessorType;\n\n  /** @internal */\n  private _value: unknown = void 0;\n\n  /** @internal */\n  private _oldValue: unknown = void 0;\n\n  /** @internal */\n  public readonly _el: IInputElement;\n\n  /** @internal */\n  private _collectionObserver?: ICollectionObserver<CollectionKind> = void 0;\n\n  /**\n   * There' situation when a checked observers is used together with `model.bind` on the checkbox\n   *\n   * Then this checked box also needs to observe the changes of tht model so that it will be able to referesh the value accordingly\n   *\n   * @internal\n   */\n  private _valueObserver?: ValueAttributeObserver | SetterObserver = void 0;\n\n  /** @internal */\n  private readonly oL: IObserverLocator;\n\n  /**\n   * Used by mixing defined methods subscribe/unsubscribe\n   *\n   * @internal\n   */\n  public _listened: boolean = false;\n\n  /** @internal */\n  public _config: INodeObserverConfigBase;\n\n  /**\n   * Comes from mixin\n   */\n  public useConfig!: (config: INodeObserverConfigBase) => void;\n\n  public constructor(\n    obj: INode,\n    // deepscan-disable-next-line\n    _key: PropertyKey,\n    config: INodeObserverConfigBase,\n    observerLocator: IObserverLocator,\n  ) {\n    this._el = obj as IInputElement;\n    this.oL = observerLocator;\n    this._config = config;\n  }\n\n  public getValue(): unknown {\n    return this._value;\n  }\n\n  public setValue(newValue: unknown): void {\n    const currentValue = this._value;\n    if (newValue === currentValue) {\n      return;\n    }\n    this._value = newValue;\n    this._oldValue = currentValue;\n    this._observe();\n    this._synchronizeElement();\n    this._flush();\n  }\n\n  public handleCollectionChange(): void {\n    this._synchronizeElement();\n  }\n\n  public handleChange(_newValue: unknown, _previousValue: unknown): void {\n    this._synchronizeElement();\n  }\n\n  /** @internal */\n  private _synchronizeElement(): void {\n    const currentValue = this._value;\n    const obj = this._el;\n    const elementValue = hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;\n    const isRadio = obj.type === 'radio';\n    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;\n\n    if (isRadio) {\n      obj.checked = !!matcher(currentValue, elementValue);\n    } else if (currentValue === true) {\n      obj.checked = true;\n    } else {\n      let hasMatch = false;\n      if (isArray(currentValue)) {\n        hasMatch = currentValue.findIndex(item => !!matcher(item, elementValue)) !== -1;\n      } else if (currentValue instanceof Set) {\n        for (const v of currentValue) {\n          if (matcher(v, elementValue)) {\n            hasMatch = true;\n            break;\n          }\n        }\n      } else if (currentValue instanceof Map) {\n        for (const pair of currentValue) {\n          const existingItem = pair[0];\n          const $isChecked = pair[1];\n          // a potential complain, when only `true` is supported\n          // but it's consistent with array\n          if (matcher(existingItem, elementValue) && $isChecked === true) {\n            hasMatch = true;\n            break;\n          }\n        }\n      }\n      obj.checked = hasMatch;\n    }\n  }\n\n  public handleEvent(): void {\n    let currentValue = this._oldValue = this._value;\n    const obj = this._el;\n    const elementValue = hasOwnProperty.call(obj, 'model') ? obj.model : obj.value;\n    const isChecked = obj.checked;\n    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;\n\n    if (obj.type === 'checkbox') {\n      if (isArray(currentValue)) {\n        // Array binding steps on a change event:\n        // 1. find corresponding item INDEX in the Set based on current model/value and matcher\n        // 2. is the checkbox checked?\n        //    2.1. Yes: is the corresponding item in the Array (index === -1)?\n        //        2.1.1 No: push the current model/value to the Array\n        //    2.2. No: is the corresponding item in the Array (index !== -1)?\n        //        2.2.1: Yes: remove the corresponding item\n        // =================================================\n        const index = currentValue.findIndex(item => !!matcher(item, elementValue));\n\n        // if the checkbox is checkde, and there's no matching value in the existing array\n        // add the checkbox model/value to the array\n        if (isChecked && index === -1) {\n          currentValue.push(elementValue);\n        } else if (!isChecked && index !== -1) {\n          // if the checkbox is not checked, and found a matching item in the array\n          // based on the checkbox model/value\n          // remove the existing item\n          currentValue.splice(index, 1);\n        }\n        // when existing currentValue is an array,\n        // do not invoke callback as only the array obj has changed\n        return;\n      } else if (currentValue instanceof Set) {\n        // Set binding steps on a change event:\n        // 1. find corresponding item in the Set based on current model/value and matcher\n        // 2. is the checkbox checked?\n        //    2.1. Yes: is the corresponding item in the Set?\n        //        2.1.1 No: add the current model/value to the Set\n        //    2.2. No: is the corresponding item in the Set?\n        //        2.2.1: Yes: remove the corresponding item\n        // =================================================\n\n        // 1. find corresponding item\n        const unset = {};\n        let existingItem: unknown = unset;\n        for (const value of currentValue) {\n          if (matcher(value, elementValue) === true) {\n            existingItem = value;\n            break;\n          }\n        }\n        // 2.1. Checkbox is checked, is the corresponding item in the Set?\n        //\n        // if checkbox is checked and there's no value in the existing Set\n        // add the checkbox model/value to the Set\n        if (isChecked && existingItem === unset) {\n          // 2.1.1. add the current model/value to the Set\n          currentValue.add(elementValue);\n        } else if (!isChecked && existingItem !== unset) {\n          // 2.2.1 Checkbox is unchecked, corresponding is in the Set\n          //\n          // if checkbox is not checked, and found a matching item in the Set\n          // based on the checkbox model/value\n          // remove the existing item\n          currentValue.delete(existingItem);\n        }\n        // when existing value is a Set,\n        // do not invoke callback as only the Set has been mutated\n        return;\n      } else if (currentValue instanceof Map) {\n        // Map binding steps on a change event\n        // 1. find corresponding item in the Map based on current model/value and matcher\n        // 2. Set the value of the corresponding item in the Map based on checked state of the checkbox\n        // =================================================\n\n        // 1. find the corresponding item\n        let existingItem: unknown;\n        for (const pair of currentValue) {\n          const currItem = pair[0];\n          if (matcher(currItem, elementValue) === true) {\n            existingItem = currItem;\n            break;\n          }\n        }\n\n        // 2. set the value of the corresponding item in the map\n        // if checkbox is checked and there's no value in the existing Map\n        // add the checkbox model/value to the Map as key,\n        // and value will be checked state of the checkbox\n        currentValue.set(existingItem, isChecked);\n        // when existing value is a Map,\n        // do not invoke callback as only the Map has been mutated\n        return;\n      }\n      currentValue = isChecked;\n    } else if (isChecked) {\n      currentValue = elementValue;\n    } else {\n      // if it's a radio and it has been unchecked\n      // do nothing, as the radio that was checked will fire change event and it will be handle there\n      // a radio cannot be unchecked by user\n      return;\n    }\n    this._value = currentValue;\n    this._flush();\n  }\n\n  /**\n   * Used by mixing defined methods subscribe\n   *\n   * @internal\n   */\n  public _start() {\n    this._observe();\n  }\n\n  /**\n   * Used by mixing defined methods unsubscribe\n   *\n   * @internal\n   */\n  public _stop(): void {\n    this._value = this._oldValue = void 0;\n    this._collectionObserver?.unsubscribe(this);\n    this._valueObserver?.unsubscribe(this);\n    this._collectionObserver = this._valueObserver = void 0;\n  }\n\n  /** @internal */\n  private _flush(): void {\n    oV = this._oldValue;\n    this._oldValue = this._value;\n    this.subs.notify(this._value, oV);\n    oV = void 0;\n  }\n\n  /** @internal */\n  private _observe() {\n    const obj = this._el;\n\n    (this._valueObserver ??= obj.$observers?.model ?? obj.$observers?.value)?.subscribe(this);\n\n    this._collectionObserver?.unsubscribe(this);\n    this._collectionObserver = void 0;\n\n    if (obj.type === 'checkbox') {\n      (this._collectionObserver = getCollectionObserver(this._value, this.oL))?.subscribe(this);\n    }\n  }\n}\n\n// a reusable variable for `.flush()` methods of observers\n// so that there doesn't need to create an env record for every call\nlet oV: unknown = void 0;\n", "import { type Scope } from '@aurelia/runtime';\n\nimport { IBinding } from '../../binding/interfaces-bindings';\nimport { attrAccessor } from '../../observation/data-attribute-accessor';\n\nimport { PropertyBinding } from '../../binding/property-binding';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { type BindingBehaviorInstance, type BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\n\nexport class AttrBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'attr',\n  };\n\n  public bind(_scope: Scope, binding: IBinding): void {\n    if (!(binding instanceof PropertyBinding)) {\n      throw createMappedError(ErrorNames.attr_behavior_invalid_binding, binding);\n    }\n    binding.useTargetObserver(attrAccessor);\n  }\n}\n", "import { type Scope } from '@aurelia/runtime';\nimport { ListenerBinding } from '../../binding/listener-binding';\nimport { type BindingBehaviorInstance, BindingBehaviorStaticAuDefinition, behaviorTypeName } from '../binding-behavior';\n\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport class SelfBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'self',\n  };\n\n  public bind(_scope: Scope, binding: ListenerBinding): void {\n    if (!('handleEvent' in binding)) {\n      throw createMappedError(ErrorNames.self_behavior_invalid_usage);\n    }\n\n    binding.self = true;\n  }\n\n  public unbind(_scope: Scope, binding: ListenerBinding): void {\n    binding.self = false;\n  }\n}\n", "import { resolve } from '@aurelia/kernel';\nimport { type Scope, INodeObserverLocator, IObserverLocator } from '@aurelia/runtime';\nimport { type IBinding, fromView } from '../../binding/interfaces-bindings';\nimport { NodeObserverLocator } from '../../observation/observer-locator';\nimport { behaviorTypeName, type BindingBehaviorInstance, type BindingBehaviorStaticAuDefinition } from '../binding-behavior';\n\nimport { PropertyBinding } from '../../binding/property-binding';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport class UpdateTriggerBindingBehavior implements BindingBehaviorInstance {\n  public static readonly $au: BindingBehaviorStaticAuDefinition = {\n    type: behaviorTypeName,\n    name: 'updateTrigger',\n  };\n\n  /** @internal */ private readonly _observerLocator = resolve(IObserverLocator);\n  /** @internal */ private readonly _nodeObserverLocator = resolve(INodeObserverLocator) as NodeObserverLocator;\n\n  public bind(_scope: Scope, binding: IBinding, ...events: string[]): void {\n    if (!(this._nodeObserverLocator instanceof NodeObserverLocator)) {\n      throw createMappedError(ErrorNames.update_trigger_behavior_not_supported);\n    }\n    if (events.length === 0) {\n      throw createMappedError(ErrorNames.update_trigger_behavior_no_triggers);\n    }\n\n    if (!(binding instanceof PropertyBinding) || !(binding.mode & fromView)) {\n      throw createMappedError(ErrorNames.update_trigger_invalid_usage);\n    }\n\n    // ensure the binding's target observer has been set.\n    const targetConfig = this._nodeObserverLocator.getNodeObserverConfig(\n      binding.target as HTMLElement,\n      binding.targetProperty,\n    );\n    // todo(bigopon): potentially updateTrigger can be used to teach Aurelia adhoc listening capability\n    //                since event names are the only thing needed\n    if (targetConfig == null) {\n      throw createMappedError(ErrorNames.update_trigger_behavior_node_property_not_observable, binding);\n    }\n    const targetObserver = this._nodeObserverLocator.getNodeObserver(\n      binding.target as HTMLElement,\n      binding.targetProperty,\n      this._observerLocator,\n    )!; // the check on targetConfig ensures it's not null, save execessive check her\n\n    targetObserver.useConfig({ readonly: targetConfig.readonly, default: targetConfig.default, events });\n\n    binding.useTargetObserver(targetObserver);\n  }\n}\n", "/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nimport { onResolve, resolve } from '@aurelia/kernel';\nimport { IRenderLocation } from '../../dom';\nimport { IViewFactory } from '../../templating/view';\n\nimport type { ISyntheticView, ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, ControllerVisitor, IHydratableController } from '../../templating/controller';\nimport type { IInstruction } from '@aurelia/template-compiler';\nimport type { INode } from '../../dom.node';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\n\nexport class If implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'if',\n    isTemplateController: true,\n    bindables: {\n      value: true,\n      cache: {\n        set: (v: unknown) => v === '' || !!v && v !== 'false',\n      }\n    }\n  };\n\n  public elseFactory?: IViewFactory = void 0;\n  public elseView?: ISyntheticView = void 0;\n  public ifView?: ISyntheticView = void 0;\n  public view?: ISyntheticView = void 0;\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value: unknown = false;\n  /**\n   * `false` to always dispose the existing `view` whenever the value of if changes to false\n   */\n  public cache: boolean = true;\n  private pending: void | Promise<void> = void 0;\n  /** @internal */ private _wantsDeactivate: boolean = false;\n  /** @internal */ private _swapId: number = 0;\n  /** @internal */ private readonly _ifFactory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public attaching(_initiator: IHydratedController, _parent: IHydratedController): void | Promise<void> {\n    return this._swap(this.value);\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    this._wantsDeactivate = true;\n    return onResolve(this.pending, () => {\n      this._wantsDeactivate = false;\n      this.pending = void 0;\n      // Promise return values from user VM hooks are awaited by the initiator\n      void this.view?.deactivate(initiator, this.$controller);\n    });\n  }\n\n  public valueChanged(newValue: unknown, oldValue: unknown): void | Promise<void> {\n    if (!this.$controller.isActive) return;\n\n    newValue = !!newValue;\n    oldValue = !!oldValue;\n    if (newValue !== oldValue) return this._swap(newValue);\n  }\n\n  /** @internal */\n  private _swap(value: unknown): void | Promise<void> {\n    const currView = this.view;\n    const ctrl = this.$controller;\n    const swapId = this._swapId++;\n    /**\n     * returns true when\n     * 1. entering deactivation of the [if] itself\n     * 2. new swap has started since this change\n     */\n    const isCurrent = () => !this._wantsDeactivate && this._swapId === swapId + 1;\n    let view: ISyntheticView | undefined;\n    return onResolve(this.pending,\n      () => this.pending = onResolve(\n        currView?.deactivate(currView, ctrl),\n        () => {\n          if (!isCurrent()) {\n            return;\n          }\n          // falsy -> truthy\n          if (value) {\n            view = (this.view = this.ifView = this.cache && this.ifView != null\n              ? this.ifView\n              : this._ifFactory.create()\n            );\n          } else {\n            // truthy -> falsy\n            view = (this.view = this.elseView = this.cache && this.elseView != null\n              ? this.elseView\n              : this.elseFactory?.create()\n            );\n          }\n          // if the value is falsy\n          // and there's no [else], `view` will be null\n          if (view == null) {\n            return;\n          }\n          // todo: location should be based on either the [if]/[else] attribute\n          //       instead of always of the [if]\n          view.setLocation(this._location);\n          return onResolve(\n            view.activate(view, ctrl, ctrl.scope),\n            () => {\n              if (isCurrent()) {\n                this.pending = void 0;\n              }\n            }\n          );\n        }\n      )\n    );\n  }\n\n  public dispose(): void {\n    this.ifView?.dispose();\n    this.elseView?.dispose();\n    this.ifView\n      = this.elseView\n      = this.view\n      = void 0;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n}\n\nexport class Else implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: 'custom-attribute',\n    name: 'else',\n    isTemplateController: true,\n  };\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    const children = controller.children!;\n    const ifBehavior: If | ICustomAttributeController = children[children.length - 1] as If | ICustomAttributeController;\n    if (ifBehavior instanceof If) {\n      ifBehavior.elseFactory = this._factory;\n    } else if (ifBehavior.viewModel instanceof If) {\n      ifBehavior.viewModel.elseFactory = this._factory;\n    } else {\n      throw createMappedError(ErrorNames.else_without_if);\n    }\n  }\n}\n", "import {\n  areEqual,\n  isArray,\n  isPromise,\n  isMap,\n  isSet,\n  isNumber,\n  type IDisposable,\n  onResolve,\n  type IIndexable,\n  resolve,\n  all,\n  emptyArray,\n  IContainer,\n} from '@aurelia/kernel';\nimport {\n  BindingBehaviorExpression,\n  ForOfStatement,\n  type IsBindingBehavior,\n  ValueConverterExpression,\n} from '@aurelia/expression-parser';\nimport {\n  type Collection,\n  CollectionObserver,\n  getCollectionObserver,\n  type IndexMap,\n  createIndexMap,\n  astEvaluate,\n  astAssign,\n  Scope,\n  BindingContext,\n  type IOverrideContext,\n} from '@aurelia/runtime';\nimport { IExpressionParser } from '@aurelia/expression-parser';\nimport { IRenderLocation } from '../../dom';\nimport { IViewFactory } from '../../templating/view';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport { IController } from '../../templating/controller';\nimport { rethrow, etIsProperty } from '../../utilities';\nimport { HydrateTemplateController, IInstruction, IteratorBindingInstruction } from '@aurelia/template-compiler';\n\nimport type { PropertyBinding } from '../../binding/property-binding';\nimport type { ISyntheticView, ICustomAttributeController, IHydratableController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, ControllerVisitor } from '../../templating/controller';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { createInterface, singletonRegistration } from '../../utilities-di';\n\ntype Items<C extends Collection = unknown[]> = C | undefined;\n\nfunction dispose(disposable: IDisposable): void {\n  disposable.dispose();\n}\n\nconst wrappedExprs = [\n  'BindingBehavior',\n  'ValueConverter',\n];\n\nexport class Repeat<C extends Collection = unknown[]> implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'repeat',\n    isTemplateController: true,\n    bindables: ['items'],\n  };\n\n  public views: ISyntheticView[] = [];\n  public forOf!: ForOfStatement;\n  public local!: string;\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public items: Items<C>;\n  public key: null | string | IsBindingBehavior = null;\n\n  /** @internal */ private _oldViews: ISyntheticView[] = [];\n  /** @internal */ private _scopes: Scope[] = [];\n  /** @internal */ private _oldScopes: Scope[] = [];\n  /** @internal */ private _scopeMap: Map<unknown, Scope | Scope[]> = new Map();\n  /** @internal */ private _observer?: CollectionObserver = void 0;\n  /** @internal */ private _innerItems: Items<C> | null;\n  /** @internal */ private _forOfBinding!: PropertyBinding;\n  /** @internal */ private _observingInnerItems: boolean = false;\n  /** @internal */ private _reevaluating: boolean = false;\n  /** @internal */ private _innerItemsExpression: IsBindingBehavior | null = null;\n  /** @internal */ private _normalizedItems?: unknown[] = void 0;\n  /** @internal */ private _hasDestructuredLocal: boolean = false;\n\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _parent = resolve(IController) as IHydratableController;\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _resolver = resolve(IRepeatableHandlerResolver);\n\n  public constructor() {\n    const instruction = resolve(IInstruction) as HydrateTemplateController;\n    const keyProp = (instruction.props[0] as IteratorBindingInstruction).props[0];\n    if (keyProp !== void 0) {\n      const { to, value, command } = keyProp;\n      if (to === 'key') {\n        if (command === null) {\n          this.key = value;\n        } else if (command === 'bind') {\n          this.key = resolve(IExpressionParser).parse(value, etIsProperty);\n        } else {\n          throw createMappedError(ErrorNames.repeat_invalid_key_binding_command, command);\n        }\n      } else {\n        throw createMappedError(ErrorNames.repeat_extraneous_binding, to);\n      }\n    }\n  }\n\n  public binding(\n    _initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    const bindings = this._parent.bindings as PropertyBinding[];\n    const ii = bindings.length;\n    let binding: PropertyBinding = (void 0)!;\n    let forOf!: ForOfStatement;\n    let i = 0;\n    for (; ii > i; ++i) {\n      binding = bindings[i];\n      if (binding.target === this && binding.targetProperty === 'items') {\n        forOf = this.forOf = binding.ast as ForOfStatement;\n        this._forOfBinding = binding;\n\n        let expression = forOf.iterable;\n        while (expression != null && wrappedExprs.includes(expression.$kind)) {\n          expression = (expression as ValueConverterExpression | BindingBehaviorExpression).expression;\n          this._observingInnerItems = true;\n        }\n        this._innerItemsExpression = expression;\n\n        break;\n      }\n    }\n\n    this._refreshCollectionObserver();\n    const dec = forOf.declaration;\n    if(!(this._hasDestructuredLocal = dec.$kind === 'ArrayDestructuring' || dec.$kind === 'ObjectDestructuring')) {\n      this.local = astEvaluate(dec, this.$controller.scope, binding, null) as string;\n    }\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._normalizeToArray();\n    this._createScopes(void 0);\n\n    return this._activateAllViews(initiator, this._normalizedItems ?? emptyArray);\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._refreshCollectionObserver();\n\n    return this._deactivateAllViews(initiator);\n  }\n\n  public unbinding(\n    _initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._scopeMap.clear();\n  }\n\n  // called by SetterObserver\n  public itemsChanged(): void {\n    if (!this.$controller.isActive) {\n      return;\n    }\n    this._refreshCollectionObserver();\n    this._normalizeToArray();\n    this._createScopes(void 0);\n    this._applyIndexMap(void 0);\n  }\n\n  public handleCollectionChange(collection: Collection, indexMap: IndexMap | undefined): void {\n    const $controller = this.$controller;\n    if (!$controller.isActive) {\n      return;\n    }\n    if (this._observingInnerItems) {\n      if (this._reevaluating) {\n        return;\n      }\n      this._reevaluating = true;\n      this.items = astEvaluate(this.forOf.iterable, $controller.scope, this._forOfBinding, null) as Items<C>;\n      this._reevaluating = false;\n      return;\n    }\n\n    this._normalizeToArray();\n    this._createScopes(this.key === null ? indexMap : void 0);\n    this._applyIndexMap(indexMap);\n  }\n\n  /** @internal */\n  private _applyIndexMap(indexMap: IndexMap | undefined): void {\n    const oldViews = this.views;\n    this._oldViews = oldViews.slice();\n    const oldLen = oldViews.length;\n    const key = this.key;\n    const hasKey = key !== null;\n\n    const oldScopes = this._oldScopes;\n    const newScopes = this._scopes;\n\n    if (hasKey || indexMap === void 0) {\n      const local = this.local;\n      const newItems = this._normalizedItems as IIndexable[];\n\n      const newLen = newItems.length;\n      const forOf = this.forOf;\n      const dec = forOf.declaration;\n      const binding = this._forOfBinding;\n      const hasDestructuredLocal = this._hasDestructuredLocal;\n      indexMap = createIndexMap(newLen);\n      let i = 0;\n\n      if (oldLen === 0) {\n        // Only add new views\n        for (; i < newLen; ++i) {\n          indexMap[i] = -2;\n        }\n      } else if (newLen === 0) {\n        // Only remove old views\n        for (i = 0; i < oldLen; ++i) {\n          indexMap.deletedIndices.push(i);\n          indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));\n        }\n      } else if (hasKey) {\n        const oldKeys = Array<unknown>(oldLen);\n\n        for (i = 0; i < oldLen; ++i) {\n          oldKeys[i] = getKeyValue(hasDestructuredLocal, key, dec, oldScopes[i], binding, local);\n        }\n\n        const newKeys = Array<unknown>(oldLen);\n\n        for (i = 0; i < newLen; ++i) {\n          newKeys[i] = getKeyValue(hasDestructuredLocal, key, dec, newScopes[i], binding, local);\n        }\n\n        for (i = 0; i < newLen; ++i) {\n          if (oldKeys.includes(newKeys[i])) {\n            indexMap[i] = oldKeys.indexOf(newKeys[i]);\n          } else {\n            indexMap[i] = -2;\n          }\n        }\n\n        for (i = 0; i < oldLen; ++i) {\n          if (!newKeys.includes(oldKeys[i])) {\n            indexMap.deletedIndices.push(i);\n            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));\n          }\n        }\n      } else {\n        for (i = 0; i < newLen; ++i) {\n          if (oldScopes.includes(newScopes[i])) {\n            indexMap[i] = oldScopes.indexOf(newScopes[i]);\n          } else {\n            indexMap[i] = -2;\n          }\n        }\n\n        for (i = 0; i < oldLen; ++i) {\n          if (!newScopes.includes(oldScopes[i])) {\n            indexMap.deletedIndices.push(i);\n            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i], binding, local));\n          }\n        }\n      }\n    }\n\n    // first detach+unbind+(remove from array) the deleted view indices\n    if (indexMap.deletedIndices.length > 0) {\n      const ret = onResolve(\n        this._deactivateAndRemoveViewsByKey(indexMap),\n        () => {\n          // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add a variety of `if` integration tests\n          return this._createAndActivateAndSortViewsByKey(indexMap);\n        },\n      );\n      if (isPromise(ret)) { ret.catch(rethrow); }\n    } else {\n      // TODO(fkleuver): add logic to the controller that ensures correct handling of race conditions and add integration tests\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._createAndActivateAndSortViewsByKey(indexMap);\n    }\n  }\n\n  // todo: subscribe to collection from inner expression\n  /** @internal */\n  private _refreshCollectionObserver(): void {\n    const scope = this.$controller.scope;\n\n    let innerItems = this._innerItems;\n    let observingInnerItems = this._observingInnerItems;\n    let newObserver: CollectionObserver | undefined;\n\n    if (observingInnerItems) {\n      innerItems = this._innerItems = astEvaluate(this._innerItemsExpression!, scope, this._forOfBinding, null) as Items<C> ?? null;\n      observingInnerItems = this._observingInnerItems = !areEqual(this.items, innerItems);\n    }\n\n    const oldObserver = this._observer;\n    if (this.$controller.isActive) {\n      const items = observingInnerItems ? innerItems : this.items;\n      newObserver = this._observer = this._resolver.resolve(items).getObserver?.(items);\n      if (oldObserver !== newObserver) {\n        oldObserver?.unsubscribe(this);\n        newObserver?.subscribe(this);\n      }\n    } else {\n      oldObserver?.unsubscribe(this);\n      this._observer = undefined;\n    }\n  }\n\n  /** @internal */\n  private _createScopes(indexMap: IndexMap | undefined): void {\n    const oldScopes = this._scopes;\n    this._oldScopes = oldScopes.slice();\n\n    const items = this._normalizedItems!;\n    const len = items.length;\n    const scopes = this._scopes = Array(items.length);\n\n    const oldScopeMap = this._scopeMap;\n    const newScopeMap = new Map<unknown, Scope | Scope[]>();\n    const parentScope = this.$controller.scope;\n    const binding = this._forOfBinding;\n    const forOf = this.forOf;\n    const local = this.local;\n    const hasDestructuredLocal = this._hasDestructuredLocal;\n\n    if (indexMap === void 0) {\n      const key = this.key;\n      const hasKey = key !== null;\n      if (hasKey) {\n        const keys = Array<unknown>(len);\n        if (typeof key === 'string') {\n          for (let i = 0; i < len; ++i) {\n            keys[i] = (items[i] as IIndexable)[key];\n          }\n        } else {\n          for (let i = 0; i < len; ++i) {\n            // This method of creating a throwaway scope just for key evaluation is inefficient but requires a lot less code this way.\n            // It seems acceptable for what should be a niche use case and this way it's guaranteed to work correctly in all cases.\n            // When performance matters, it is advised to use normal string-based keys instead of expressions:\n            // `repeat.for=\"i of items; key.bind: i.key\" - inefficient\n            // `repeat.for=\"i of items; key: key\" - efficient\n            const scope = createScope(items[i], forOf, parentScope, binding, local, hasDestructuredLocal);\n            setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, items[i]);\n            keys[i] = astEvaluate(key, scope, binding, null);\n          }\n        }\n        for (let i = 0; i < len; ++i) {\n          scopes[i] = getScope(oldScopeMap, newScopeMap, keys[i], items[i], forOf, parentScope, binding, local, hasDestructuredLocal);\n        }\n      } else {\n        for (let i = 0; i < len; ++i) {\n          scopes[i] = getScope(oldScopeMap, newScopeMap, items[i], items[i], forOf, parentScope, binding, local, hasDestructuredLocal);\n        }\n      }\n    } else {\n      const oldLen = oldScopes.length;\n      for (let i = 0; i < len; ++i) {\n        const src = indexMap[i];\n\n        if (src >= 0 && src < oldLen) {\n          scopes[i] = oldScopes[src];\n        } else {\n          scopes[i] = createScope(items[i], forOf, parentScope, binding, local, hasDestructuredLocal);\n        }\n        setItem(hasDestructuredLocal, forOf.declaration, scopes[i], binding, local, items[i]);\n      }\n    }\n\n    oldScopeMap.clear();\n    this._scopeMap = newScopeMap;\n  }\n\n  /** @internal */\n  private _normalizeToArray(): void {\n    const items = this.items;\n    if (isArray(items)) {\n      this._normalizedItems = items.slice(0);\n      return;\n    }\n    const normalizedItems: unknown[] = [];\n\n    this._resolver.resolve(items).iterate(items, (item, index) => {\n      normalizedItems[index] = item;\n    });\n    this._normalizedItems = normalizedItems;\n  }\n\n  /** @internal */\n  private _activateAllViews(\n    initiator: IHydratedController | null,\n    $items: unknown[],\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n    let scope: Scope;\n\n    const { $controller, _factory, _location, _scopes } = this;\n    const newLen = $items.length;\n    const views = this.views = Array(newLen);\n\n    for (let i = 0; i < newLen; ++i) {\n      view = views[i] = _factory.create().setLocation(_location);\n      view.nodes.unlink();\n      scope = _scopes[i];\n\n      setContextualProperties(scope.overrideContext as RepeatOverrideContext, i, newLen);\n      ret = view.activate(initiator ?? view, $controller, scope);\n      if (isPromise(ret)) {\n        (promises ??= []).push(ret);\n      }\n    }\n\n    if (promises !== void 0) {\n      return promises.length === 1\n        ? promises[0]\n        : Promise.all(promises) as unknown as Promise<void>;\n    }\n  }\n\n  /** @internal */\n  private _deactivateAllViews(\n    initiator: IHydratedController | null,\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n    let i = 0;\n\n    const { views, $controller } = this;\n    const ii = views.length;\n\n    for (; ii > i; ++i) {\n      view = views[i];\n      view.release();\n      ret = view.deactivate(initiator ?? view, $controller);\n      if (isPromise(ret)) {\n        (promises ?? (promises = [])).push(ret);\n      }\n    }\n\n    if (promises !== void 0) {\n      return (promises.length === 1\n        ? promises[0]\n        : Promise.all(promises)) as unknown as Promise<void>;\n    }\n  }\n\n  /** @internal */\n  private _deactivateAndRemoveViewsByKey(\n    indexMap: IndexMap,\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n\n    const { $controller, views } = this;\n\n    const deleted = indexMap.deletedIndices.slice().sort(compareNumber);\n    const deletedLen = deleted.length;\n    let i = 0;\n    for (; deletedLen > i; ++i) {\n      view = views[deleted[i]];\n      view.release();\n      ret = view.deactivate(view, $controller);\n      if (isPromise(ret)) {\n        (promises ?? (promises = [])).push(ret);\n      }\n    }\n\n    i = 0;\n    for (; deletedLen > i; ++i) {\n      views.splice(deleted[i] - i, 1);\n    }\n\n    if (promises !== void 0) {\n      return promises.length === 1\n        ? promises[0]\n        : Promise.all(promises) as unknown as Promise<void>;\n    }\n  }\n\n  /** @internal */\n  private _createAndActivateAndSortViewsByKey(\n    indexMap: IndexMap,\n  ): void | Promise<void> {\n    let promises: Promise<void>[] | undefined = void 0;\n    let ret: void | Promise<void>;\n    let view: ISyntheticView;\n    let i = 0;\n\n    const { $controller, _factory, _location, views, _scopes, _oldViews } = this;\n    const newLen = indexMap.length;\n\n    for (; newLen > i; ++i) {\n      if (indexMap[i] === -2) {\n        view = _factory.create();\n        views.splice(i, 0, view);\n      }\n    }\n\n    if (views.length !== newLen) {\n      throw createMappedError(ErrorNames.repeat_mismatch_length, [views.length, newLen]);\n    }\n\n    let source = 0;\n    i = 0;\n    for (; i < indexMap.length; ++i) {\n      if ((source = indexMap[i]) !== -2) {\n        views[i] = _oldViews[source];\n      }\n    }\n\n    // this algorithm retrieves the indices of the longest increasing subsequence of items in the repeater\n    // the items on those indices are not moved; this minimizes the number of DOM operations that need to be performed\n    const seq = longestIncreasingSubsequence(indexMap);\n    const seqLen = seq.length;\n\n    let next: ISyntheticView;\n    let j = seqLen - 1;\n    i = newLen - 1;\n    for (; i >= 0; --i) {\n      view = views[i];\n      next = views[i + 1];\n\n      if (indexMap[i] === -2) {\n        view.nodes.link(next?.nodes ?? _location);\n        view.setLocation(_location);\n        setContextualProperties(_scopes[i].overrideContext as RepeatOverrideContext, i, newLen);\n        ret = view.activate(view, $controller, _scopes[i]);\n        if (isPromise(ret)) {\n          (promises ?? (promises = [])).push(ret);\n        }\n      } else if (j < 0 || i !== seq[j]) {\n        view.nodes.link(next?.nodes ?? _location);\n        setContextualProperties(view.scope.overrideContext as RepeatOverrideContext, i, newLen);\n        view.nodes.insertBefore(view.location!);\n      } else {\n        setContextualProperties(view.scope.overrideContext as RepeatOverrideContext, i, newLen);\n        --j;\n      }\n    }\n\n    if (promises !== void 0) {\n      return promises.length === 1\n        ? promises[0]\n        : Promise.all(promises) as unknown as Promise<void>;\n    }\n  }\n\n  public dispose(): void {\n    this.views.forEach(dispose);\n    this.views = (void 0)!;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    const { views } = this;\n\n    if (views !== void 0) {\n      for (let i = 0, ii = views.length; i < ii; ++i) {\n        if (views[i].accept(visitor) === true) {\n          return true;\n        }\n      }\n    }\n  }\n}\n\nlet maxLen = 16;\nlet prevIndices = new Int32Array(maxLen);\nlet tailIndices = new Int32Array(maxLen);\n\n// Based on inferno's lis_algorithm @ https://github.com/infernojs/inferno/blob/master/packages/inferno/src/DOM/patching.ts#L732\n// with some tweaks to make it just a bit faster + account for IndexMap (and some names changes for readability)\n/** @internal */\nexport function longestIncreasingSubsequence(indexMap: IndexMap): Int32Array {\n  const len = indexMap.length;\n\n  if (len > maxLen) {\n    maxLen = len;\n    prevIndices = new Int32Array(len);\n    tailIndices = new Int32Array(len);\n  }\n\n  let cursor = 0;\n  let cur = 0;\n  let prev = 0;\n  let i = 0;\n  let j = 0;\n  let low = 0;\n  let high = 0;\n  let mid = 0;\n\n  for (; i < len; i++) {\n    cur = indexMap[i];\n    if (cur !== -2) {\n      j = prevIndices[cursor];\n\n      prev = indexMap[j];\n      if (prev !== -2 && prev < cur) {\n        tailIndices[i] = j;\n        prevIndices[++cursor] = i;\n        continue;\n      }\n\n      low = 0;\n      high = cursor;\n\n      while (low < high) {\n        mid = (low + high) >> 1;\n        prev = indexMap[prevIndices[mid]];\n        if (prev !== -2 && prev < cur) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n\n      prev = indexMap[prevIndices[low]];\n      if (cur < prev || prev === -2) {\n        if (low > 0) {\n          tailIndices[i] = prevIndices[low - 1];\n        }\n        prevIndices[low] = i;\n      }\n    }\n  }\n  i = ++cursor;\n  const result = new Int32Array(i);\n  cur = prevIndices[cursor - 1];\n\n  while (cursor-- > 0) {\n    result[cursor] = cur;\n    cur = tailIndices[cur];\n  }\n  while (i-- > 0) prevIndices[i] = 0;\n  return result;\n}\n\ninterface IRepeatOverrideContext extends IOverrideContext {\n  $index: number;\n  $odd: boolean;\n  $even: boolean;\n  $first: boolean;\n  $middle: boolean;\n  $last: boolean;\n  $length: number; // new in v2, there are a few requests, not sure if it should stay\n}\n\nclass RepeatOverrideContext implements IRepeatOverrideContext {\n  public get $odd(): boolean {\n    return !this.$even;\n  }\n  public get $even(): boolean {\n    return this.$index % 2 === 0;\n  }\n  public get $first(): boolean {\n    return this.$index === 0;\n  }\n  public get $middle(): boolean {\n    return !this.$first && !this.$last;\n  }\n  public get $last(): boolean {\n    return this.$index === this.$length - 1;\n  }\n\n  public constructor(\n    public readonly $index: number = 0,\n    public readonly $length: number = 1,\n  ) {}\n}\n\nconst setContextualProperties = (oc: IRepeatOverrideContext, index: number, length: number): void => {\n  oc.$index = index;\n  oc.$length = length;\n};\n\nexport const IRepeatableHandlerResolver = /*@__PURE__*/ createInterface<IRepeatableHandlerResolver>(\n  'IRepeatableHandlerResolver',\n  x => x.singleton(RepeatableHandlerResolver)\n);\n/**\n * An interface describings the capabilities of a repeatable handler.\n */\nexport interface IRepeatableHandlerResolver {\n  resolve(value: unknown): IRepeatableHandler;\n}\n\n/**\n * The default implementation of the IRepeatableHandlerResolver interface\n */\nclass RepeatableHandlerResolver implements IRepeatableHandlerResolver {\n  /** @internal */\n  private readonly _handlers = resolve(all(IRepeatableHandler));\n\n  public resolve(value: Repeatable): IRepeatableHandler {\n    if (_arrayHandler.handles(value)) {\n      return _arrayHandler;\n    }\n    if (_setHandler.handles(value)) {\n      return _setHandler;\n    }\n    if (_mapHandler.handles(value)) {\n      return _mapHandler;\n    }\n    if (_numberHandler.handles(value)) {\n      return _numberHandler;\n    }\n    if (_nullishHandler.handles(value)) {\n      return _nullishHandler;\n    }\n    const handler = this._handlers.find(x => x.handles(value));\n    if (handler !== void 0) {\n      return handler;\n    }\n    return _unknownHandler;\n  }\n}\n\n/**\n * A simple implementation for handling common array like values, such as:\n * - HTMLCollection\n * - NodeList\n * - FileList,\n * - etc...\n */\nexport class ArrayLikeHandler implements IRepeatableHandler<ArrayLike<unknown>> {\n  public static register(c: IContainer) {\n    c.register(singletonRegistration(IRepeatableHandler, this));\n  }\n\n  public handles(value: NonNullable<unknown>): boolean {\n    return 'length' in value && isNumber(value.length);\n  }\n\n  public iterate(items: ArrayLike<unknown>, func: (item: unknown, index: number, arr: ArrayLike<unknown>) => void): void {\n    for (let i = 0, ii = items.length; i < ii; ++i) {\n      func(items[i], i, items);\n    }\n  }\n\n}\n\n/**\n * An interface describing a repeatable value handler\n */\nexport const IRepeatableHandler = /*@__PURE__*/ createInterface<IRepeatableHandler>('IRepeatableHandler');\n\nexport interface IRepeatableHandler<TValue extends Repeatable = Repeatable> {\n  handles(value: unknown): boolean;\n  getObserver?(value: TValue): CollectionObserver | undefined;\n  iterate(value: TValue, func: (item: unknown, index: number, value: TValue) => void): void;\n  // getCount(items: TValue): number;\n}\n\nconst _arrayHandler: IRepeatableHandler<unknown[]> = {\n  handles: isArray,\n  getObserver: getCollectionObserver,\n  /* istanbul ignore next */\n  iterate(value, func): void {\n    const ii = value.length;\n    let i = 0;\n    for (; i < ii; ++i) {\n      func(value[i], i, value);\n    }\n  },\n  // getCount: items => items.length,\n};\n\nconst _setHandler: IRepeatableHandler<Set<unknown>> = {\n  handles: isSet,\n  getObserver: getCollectionObserver,\n  iterate(value, func): void {\n    let i = 0;\n    let key: unknown;\n    for (key of value.keys()) {\n      func(key, i++, value);\n    }\n  },\n  // getCount: s => s.size,\n};\n\nconst _mapHandler: IRepeatableHandler<Map<unknown, unknown>> = {\n  handles: isMap,\n  getObserver: getCollectionObserver,\n  iterate(value, func): void {\n    let i = 0;\n    let entry: [unknown, unknown] | undefined;\n    for (entry of value.entries()) {\n      func(entry, i++, value);\n    }\n  },\n  // getCount: s => s.size,\n};\n\nconst _numberHandler: IRepeatableHandler<number> = {\n  handles: isNumber,\n  iterate(value, func): void {\n    let i = 0;\n    for (; i < value; ++i) {\n      func(i, i, value);\n    }\n  },\n  // getCount: v => v,\n};\n\nconst _nullishHandler: IRepeatableHandler<null | undefined> = {\n  handles: v => v == null,\n  iterate() {/* do nothing */},\n  // getCount: () => 0,\n};\n\nconst _unknownHandler: IRepeatableHandler = {\n  handles(_value: unknown): boolean {\n    // Should only return as an explicit last fallback\n    return false;\n  },\n  iterate(value: Repeatable, _func: (item: unknown, index: number, value: Repeatable) => void): void {\n    throw createMappedError(ErrorNames.repeat_non_iterable, value);\n  },\n  // getCount: () => 0,\n};\n\ntype Repeatable = Collection | ArrayLike<unknown> | number | null | undefined;\n\nconst setItem = (\n  hasDestructuredLocal: boolean,\n  dec: ForOfStatement['declaration'],\n  scope: Scope,\n  binding: PropertyBinding,\n  local: string,\n  item: unknown,\n) => {\n  if (hasDestructuredLocal) {\n    astAssign(dec, scope, binding, null, item);\n  } else {\n    scope.bindingContext[local] = item;\n  }\n};\n\nconst getItem = (\n  hasDestructuredLocal: boolean,\n  dec: ForOfStatement['declaration'],\n  scope: Scope,\n  binding: PropertyBinding,\n  local: string,\n): unknown => {\n  return hasDestructuredLocal ? astEvaluate(dec, scope, binding, null) : scope.bindingContext[local];\n};\n\nconst getKeyValue = (\n  hasDestructuredLocal: boolean,\n  key: string | IsBindingBehavior,\n  dec: ForOfStatement['declaration'],\n  scope: Scope,\n  binding: PropertyBinding,\n  local: string,\n) => {\n  if (typeof key === 'string') {\n    const item = getItem(hasDestructuredLocal, dec, scope, binding, local);\n    return (item as IIndexable)[key];\n  }\n\n  return astEvaluate(key, scope, binding, null);\n};\n\nconst getScope = (\n  oldScopeMap: Map<unknown, Scope | Scope[]>,\n  newScopeMap: Map<unknown, Scope | Scope[]>,\n  key: unknown,\n  item: unknown,\n  forOf: ForOfStatement,\n  parentScope: Scope,\n  binding: PropertyBinding,\n  local: string,\n  hasDestructuredLocal: boolean,\n) => {\n  let scope = oldScopeMap.get(key);\n  if (scope === void 0) {\n    scope = createScope(item, forOf, parentScope, binding, local, hasDestructuredLocal);\n  } else if (scope instanceof Scope) {\n    oldScopeMap.delete(key);\n  } else if (scope.length === 1) {\n    scope = scope[0];\n    oldScopeMap.delete(key);\n  } else {\n    scope = scope.shift()!;\n  }\n\n  if (newScopeMap.has(key)) {\n    const entry = newScopeMap.get(key)!;\n    if (entry instanceof Scope) {\n      newScopeMap.set(key, [entry, scope]);\n    } else {\n      entry.push(scope);\n    }\n  } else {\n    newScopeMap.set(key, scope);\n  }\n  setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, item);\n  return scope;\n};\n\nconst createScope = (\n  item: unknown,\n  forOf: ForOfStatement,\n  parentScope: Scope,\n  binding: PropertyBinding,\n  local: string,\n  hasDestructuredLocal: boolean,\n) => {\n  if (hasDestructuredLocal) {\n    const scope = Scope.fromParent(parentScope, new BindingContext(), new RepeatOverrideContext());\n    astAssign(forOf.declaration, scope, binding, null, item);\n  }\n  return Scope.fromParent(parentScope, new BindingContext(local, item), new RepeatOverrideContext());\n};\n\nconst compareNumber = (a: number, b: number): number => a - b;\n", "import { resolve } from '@aurelia/kernel';\nimport { Scope } from '@aurelia/runtime';\nimport { IRenderLocation } from '../../dom';\nimport { IViewFactory } from '../../templating/view';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport type { ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, ControllerVisitor } from '../../templating/controller';\n\nexport class With implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'with',\n    isTemplateController: true,\n    bindables: ['value'],\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value?: object;\n\n  private view = resolve(IViewFactory).create().setLocation(resolve(IRenderLocation));\n\n  public valueChanged(\n    newValue: unknown,\n    _oldValue: unknown,\n  ): void {\n    const $controller = this.$controller;\n    const bindings = this.view.bindings;\n    let scope: Scope;\n    let i = 0, ii = 0;\n    if ($controller.isActive && bindings != null) {\n      scope = Scope.fromParent($controller.scope, newValue === void 0 ? {} : newValue as object);\n      for (ii = bindings.length; ii > i; ++i) {\n        bindings[i].bind(scope);\n      }\n    }\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    const { $controller, value } = this;\n    const scope = Scope.fromParent($controller.scope, value === void 0 ? {} : value);\n    return this.view.activate(initiator, $controller, scope);\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    return this.view.deactivate(initiator, this.$controller);\n  }\n\n  public dispose(): void {\n    this.view.dispose();\n    this.view = (void 0)!;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n}\n", "import {\n  isArray,\n  ILogger,\n  onResolve,\n  onResolveAll,\n  resolve,\n  Writable,\n} from '@aurelia/kernel';\nimport {\n  type ICollectionObserver,\n  IObserverLocator,\n  type Scope,\n} from '@aurelia/runtime';\nimport type { IInstruction } from '@aurelia/template-compiler';\nimport { IRenderLocation } from '../../dom';\nimport { attrTypeName, CustomAttributeStaticAuDefinition, defineAttribute } from '../custom-attribute';\nimport { IViewFactory } from '../../templating/view';\nimport { oneTime } from '../../binding/interfaces-bindings';\n\nimport type { Controller, ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, IHydratedParentController, IHydratableController, ISyntheticView, ControllerVisitor } from '../../templating/controller';\nimport type { INode } from '../../dom.node';\nimport { createMappedError, ErrorNames } from '../../errors';\nimport { PartialBindableDefinition } from '../../bindable';\n\nexport class Switch implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'switch',\n    isTemplateController: true,\n    bindables: ['value'],\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n  private view!: ISyntheticView;\n\n  public value: unknown;\n\n  /** @internal */\n  public readonly cases: Case[] = [];\n  /** @internal */\n  public defaultCase?: Case;\n  private activeCases: Case[] = [];\n  /**\n   * This is kept around here so that changes can be awaited from the tests.\n   * This needs to be removed after the scheduler is ready to handle/queue the floating promises.\n   */\n  public readonly promise: Promise<void> | void = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    _controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    this.view = this._factory.create(this.$controller).setLocation(this._location);\n  }\n\n  public attaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    const view = this.view;\n    const $controller = this.$controller;\n\n    this.queue(() => view.activate(initiator, $controller, $controller.scope));\n    this.queue(() => this.swap(initiator, this.value));\n    return this.promise;\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    this.queue(() => {\n      const view = this.view;\n      return view.deactivate(initiator, this.$controller);\n    });\n    return this.promise;\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n\n  public valueChanged(_newValue: boolean, _oldValue: boolean): void {\n    if (!this.$controller.isActive) { return; }\n    this.queue(() => this.swap(null, this.value));\n  }\n\n  public caseChanged($case: Case): void {\n    this.queue(() => this._handleCaseChange($case));\n  }\n\n  /** @internal */\n  private _handleCaseChange($case: Case): void | Promise<void> {\n    const isMatch = $case.isMatch(this.value);\n    const activeCases = this.activeCases;\n    const numActiveCases = activeCases.length;\n\n    // Early termination #1\n    if (!isMatch) {\n      /** The previous match started with this; thus clear. */\n      if (numActiveCases > 0 && activeCases[0].id === $case.id) {\n        return this._clearActiveCases(null);\n      }\n      /**\n       * There are 2 different scenarios here:\n       * 1. $case in activeCases: Indicates by-product of fallthrough. The starting case still satisfies. Return.\n       * 2. $case not in activeCases: It was previously not active, and currently also not a match. Return.\n       */\n      return;\n    }\n\n    // Early termination #2\n    if (numActiveCases > 0 && activeCases[0].id < $case.id) {\n      // Even if this case now a match, the previous case still wins by as that has lower ordinal.\n      return;\n    }\n\n    // compute the new active cases\n    const newActiveCases: Case[] = [];\n    let fallThrough = $case.fallThrough;\n    if (!fallThrough) {\n      newActiveCases.push($case);\n    } else {\n      const cases = this.cases;\n      const idx = cases.indexOf($case);\n      for (let i = idx, ii = cases.length; i < ii && fallThrough; i++) {\n        const c = cases[i];\n        newActiveCases.push(c);\n        fallThrough = c.fallThrough;\n      }\n    }\n\n    return onResolve(\n      this._clearActiveCases(null, newActiveCases),\n      () => {\n        this.activeCases = newActiveCases;\n        return this._activateCases(null);\n      }\n    );\n  }\n\n  private swap(initiator: IHydratedController | null, value: unknown): void | Promise<void> {\n    const newActiveCases: Case[] = [];\n\n    let fallThrough: boolean = false;\n    for (const $case of this.cases) {\n      if (fallThrough || $case.isMatch(value)) {\n        newActiveCases.push($case);\n        fallThrough = $case.fallThrough;\n      }\n      if (newActiveCases.length > 0 && !fallThrough) { break; }\n    }\n    const defaultCase = this.defaultCase;\n    if (newActiveCases.length === 0 && defaultCase !== void 0) {\n      newActiveCases.push(defaultCase);\n    }\n\n    return onResolve(\n      this.activeCases.length > 0\n        ? this._clearActiveCases(initiator, newActiveCases)\n        : void 0!,\n      () => {\n        this.activeCases = newActiveCases;\n        if (newActiveCases.length === 0) { return; }\n        return this._activateCases(initiator);\n      }\n    );\n  }\n\n  /** @internal */\n  private _activateCases(initiator: IHydratedController | null): void | Promise<void> {\n    const controller = this.$controller;\n    if (!controller.isActive) { return; }\n\n    const cases = this.activeCases;\n    const length = cases.length;\n    if (length === 0) { return; }\n\n    const scope = controller.scope;\n\n    // most common case\n    if (length === 1) {\n      return cases[0].activate(initiator, scope);\n    }\n\n    return onResolveAll(...cases.map(($case) => $case.activate(initiator, scope)));\n  }\n\n  /** @internal */\n  private _clearActiveCases(initiator: IHydratedController | null, newActiveCases: Case[] = []): void | Promise<void> {\n    const cases = this.activeCases;\n    const numCases = cases.length;\n\n    if (numCases === 0) { return; }\n\n    if (numCases === 1) {\n      const firstCase = cases[0];\n      if (!newActiveCases.includes(firstCase)) {\n        cases.length = 0;\n        return firstCase.deactivate(initiator);\n      }\n      return;\n    }\n\n    return onResolve(\n      onResolveAll(...cases.reduce((acc: (void | Promise<void>)[], $case) => {\n        if (!newActiveCases.includes($case)) {\n          acc.push($case.deactivate(initiator));\n        }\n        return acc;\n      }, [])),\n      () => {\n        cases.length = 0;\n      }\n    );\n  }\n\n  private queue(action: () => void | Promise<void>): void {\n    const previousPromise = this.promise;\n    let promise: void | Promise<void> = void 0;\n    promise = (this as Writable<Switch>).promise = onResolve(\n      onResolve(previousPromise, action),\n      () => {\n        if (this.promise === promise) {\n          (this as Writable<Switch>).promise = void 0;\n        }\n      }\n    );\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.$controller.accept(visitor) === true) {\n      return true;\n    }\n    if (this.activeCases.some(x => x.accept(visitor))) {\n      return true;\n    }\n  }\n}\n\nlet caseId = 0;\nconst bindables: (string | PartialBindableDefinition & { name: string })[] = [\n  'value',\n  {\n    name: 'fallThrough',\n    mode: oneTime,\n    set(v: unknown): boolean {\n      switch (v) {\n        case 'true': return true;\n        case 'false': return false;\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        default: return !!v;\n      }\n    }\n  }\n];\n\nexport class Case implements ICustomAttributeViewModel {\n  static {\n    defineAttribute({ name: 'case', bindables, isTemplateController: true }, Case);\n  }\n  /** @internal */ public readonly id: number = ++caseId;\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value: unknown;\n  public fallThrough: boolean = false;\n\n  public view: ISyntheticView | undefined = void 0;\n  private $switch!: Switch;\n  /** @internal */ private _observer: ICollectionObserver<'array'> | undefined;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _locator = resolve(IObserverLocator);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _logger = resolve(ILogger).scopeTo(`Case-#${this.id}`);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    const switchController: IHydratedParentController = (controller as Controller).parent! as IHydratedParentController;\n    const $switch = switchController?.viewModel;\n    if ($switch instanceof Switch) {\n      this.$switch = $switch;\n      this.linkToSwitch($switch);\n    } else {\n      throw createMappedError(ErrorNames.switch_invalid_usage);\n    }\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public isMatch(value: unknown): boolean {\n    this._logger.debug('isMatch()');\n    const $value = this.value;\n    if (isArray($value)) {\n      if (this._observer === void 0) {\n        this._observer = this._observeCollection($value);\n      }\n      return $value.includes(value);\n    }\n    return $value === value;\n  }\n\n  public valueChanged(newValue: unknown, _oldValue: unknown): void {\n    if (isArray(newValue)) {\n      this._observer?.unsubscribe(this);\n      this._observer = this._observeCollection(newValue);\n    } else if (this._observer !== void 0) {\n      this._observer.unsubscribe(this);\n    }\n    this.$switch.caseChanged(this);\n  }\n\n  public handleCollectionChange(): void {\n    this.$switch.caseChanged(this);\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope): void | Promise<void> {\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(initiator ?? view, this.$controller, scope);\n  }\n\n  public deactivate(initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(initiator ?? view, this.$controller);\n  }\n\n  public dispose(): void {\n    this._observer?.unsubscribe(this);\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n\n  protected linkToSwitch(auSwitch: Switch): void {\n    auSwitch.cases.push(this);\n  }\n\n  /** @internal */\n  private _observeCollection($value: unknown[]) {\n    const observer = this._locator.getArrayObserver($value);\n    observer.subscribe(this);\n    return observer;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.$controller.accept(visitor) === true) {\n      return true;\n    }\n    return this.view?.accept(visitor);\n  }\n}\n\nexport class DefaultCase extends Case {\n  static {\n    defineAttribute({ name: 'default-case', bindables, isTemplateController: true }, DefaultCase);\n  }\n\n  protected linkToSwitch($switch: Switch): void {\n    if ($switch.defaultCase !== void 0) {\n      throw createMappedError(ErrorNames.switch_no_multiple_default);\n    }\n    $switch.defaultCase = this;\n  }\n}\n", "import { ILogger, onResolve, onResolveAll, resolve, isPromise, registrableMetadataKey } from '@aurelia/kernel';\nimport { queueAsyncTask, Task, Scope } from '@aurelia/runtime';\nimport { IRenderLocation } from '../../dom';\nimport { INode } from '../../dom.node';\nimport { IPlatform } from '../../platform';\nimport { fromView, toView } from '../../binding/interfaces-bindings';\nimport {\n  Controller,\n  ICustomAttributeController,\n  ICustomAttributeViewModel,\n  IHydratableController,\n  IHydratedController,\n  IHydratedParentController,\n  ISyntheticView\n} from '../../templating/controller';\nimport { IViewFactory } from '../../templating/view';\nimport { IInstruction, AttrSyntax, AttributePattern } from '@aurelia/template-compiler';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport { safeString, tsRunning } from '../../utilities';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport class PromiseTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'promise',\n    isTemplateController: true,\n    bindables: ['value'],\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n  private view!: ISyntheticView;\n\n  public value!: Promise<unknown>;\n\n  public pending?: PendingTemplateController;\n  public fulfilled?: FulfilledTemplateController;\n  public rejected?: RejectedTemplateController;\n\n  private viewScope!: Scope;\n  private preSettledTask: Task<void | Promise<void>> | null = null;\n  private postSettledTask: Task<void | Promise<void>> | null = null;\n  private postSettlePromise!: Promise<void>;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _platform = resolve(IPlatform);\n  /** @internal */ private readonly logger = resolve(ILogger).scopeTo('promise.resolve');\n\n  public link(\n    _controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    this.view = this._factory.create(this.$controller).setLocation(this._location);\n  }\n\n  public attaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    const view = this.view;\n    const $controller = this.$controller;\n\n    return onResolve(\n      view.activate(initiator, $controller, this.viewScope = Scope.fromParent($controller.scope, {})),\n      () => this.swap(initiator)\n    );\n  }\n\n  public valueChanged(_newValue: boolean, _oldValue: boolean): void {\n    if (!this.$controller.isActive) { return; }\n    this.swap(null);\n  }\n\n  private swap(initiator: IHydratedController | null): void {\n    const value = this.value;\n    if (!isPromise(value)) {\n      if (__DEV__) {\n        /* istanbul ignore next */\n        this.logger.warn(`The value '${safeString(value)}' is not a promise. No change will be done.`);\n      }\n      return;\n    }\n    const fulfilled = this.fulfilled;\n    const rejected = this.rejected;\n    const pending = this.pending;\n    const s = this.viewScope;\n\n    let preSettlePromise: Promise<void>;\n    const $swap = () => {\n      // Note that the whole thing is not wrapped in a q.queueTask intentionally.\n      // Because that would block the app till the actual promise is resolved, which is not the goal anyway.\n      void onResolveAll(\n        // At first deactivate the fulfilled and rejected views, as well as activate the pending view.\n        // The order of these 3 should not necessarily be sequential (i.e. order-irrelevant).\n        preSettlePromise = (this.preSettledTask = queueAsyncTask(() => {\n          return onResolveAll(\n            fulfilled?.deactivate(initiator),\n            rejected?.deactivate(initiator),\n            pending?.activate(initiator, s)\n          );\n        })).result.catch((err) => { throw err; }),\n        value\n          .then(\n            (data) => {\n              if (this.value !== value) {\n                return;\n              }\n              const fulfill = () => {\n                // Deactivation of pending view and the activation of the fulfilled view should not necessarily be sequential.\n                this.postSettlePromise = (this.postSettledTask = queueAsyncTask(() => onResolveAll(\n                  pending?.deactivate(initiator),\n                  rejected?.deactivate(initiator),\n                  fulfilled?.activate(initiator, s, data),\n                ))).result;\n              };\n              if (this.preSettledTask!.status === tsRunning) {\n                void preSettlePromise.then(fulfill);\n              } else {\n                this.preSettledTask!.cancel();\n                fulfill();\n              }\n            },\n            (err) => {\n              if (this.value !== value) {\n                return;\n              }\n              const reject = () => {\n                // Deactivation of pending view and the activation of the rejected view should also not necessarily be sequential.\n                this.postSettlePromise = (this.postSettledTask = queueAsyncTask(() => onResolveAll(\n                  pending?.deactivate(initiator),\n                  fulfilled?.deactivate(initiator),\n                  rejected?.activate(initiator, s, err),\n                ))).result;\n              };\n              if (this.preSettledTask!.status === tsRunning) {\n                void preSettlePromise.then(reject);\n              } else {\n                this.preSettledTask!.cancel();\n                reject();\n              }\n            },\n          ));\n    };\n\n    if (this.postSettledTask?.status === tsRunning) {\n      void this.postSettlePromise.then($swap);\n    } else {\n      this.postSettledTask?.cancel();\n      $swap();\n    }\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    this.preSettledTask?.cancel();\n    this.postSettledTask?.cancel();\n    this.preSettledTask = this.postSettledTask = null;\n    return this.view.deactivate(initiator, this.$controller);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nexport class PendingTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'pending',\n    isTemplateController: true,\n    bindables: {\n      value: { mode: toView }\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value!: Promise<unknown>;\n\n  public view: ISyntheticView | undefined = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    getPromiseController(controller).pending = this;\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope): void | Promise<void> {\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(view, this.$controller, scope);\n  }\n\n  public deactivate(_initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(view, this.$controller);\n  }\n\n  public detaching(initiator: IHydratedController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nexport class FulfilledTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'then',\n    isTemplateController: true,\n    bindables: {\n      value: { mode: fromView }\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value!: unknown;\n\n  public view: ISyntheticView | undefined = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    getPromiseController(controller).fulfilled = this;\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope, resolvedValue: unknown): void | Promise<void> {\n    this.value = resolvedValue;\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(view, this.$controller, scope);\n  }\n\n  public deactivate(_initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(view, this.$controller);\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nexport class RejectedTemplateController implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'catch',\n    isTemplateController: true,\n    bindables: {\n      value: { mode: fromView }\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>; // This is set by the controller after this instance is constructed\n\n  public value!: unknown;\n\n  public view: ISyntheticView | undefined = void 0;\n\n  /** @internal */ private readonly _factory = resolve(IViewFactory);\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n\n  public link(\n    controller: IHydratableController,\n    _childController: ICustomAttributeController,\n    _target: INode,\n    _instruction: IInstruction,\n  ): void {\n    getPromiseController(controller).rejected = this;\n  }\n\n  public activate(initiator: IHydratedController | null, scope: Scope, error: unknown): void | Promise<void> {\n    this.value = error;\n    let view = this.view;\n    if (view === void 0) {\n      view = this.view = this._factory.create().setLocation(this._location);\n    }\n    if (view.isActive) { return; }\n    return view.activate(view, this.$controller, scope);\n  }\n\n  public deactivate(_initiator: IHydratedController | null): void | Promise<void> {\n    const view = this.view;\n    if (view === void 0 || !view.isActive) { return; }\n    return view.deactivate(view, this.$controller);\n  }\n\n  public detaching(initiator: IHydratedController, _parent: IHydratedParentController): void | Promise<void> {\n    return this.deactivate(initiator);\n  }\n\n  public dispose(): void {\n    this.view?.dispose();\n    this.view = (void 0)!;\n  }\n}\n\nfunction getPromiseController(controller: IHydratableController) {\n  const promiseController: IHydratedParentController = (controller as Controller).parent! as IHydratedParentController;\n  const $promise = promiseController?.viewModel;\n  if ($promise instanceof PromiseTemplateController) {\n    return $promise;\n  }\n  throw createMappedError(ErrorNames.promise_invalid_usage);\n}\n\nexport class PromiseAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: AttributePattern.create([{ pattern: 'promise.resolve', symbols: '' }], PromiseAttributePattern)\n  };\n  public 'promise.resolve'(name: string, value: string): AttrSyntax {\n    return new AttrSyntax(name, value, 'promise', 'bind');\n  }\n}\n\nexport class FulfilledAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: AttributePattern.create([{ pattern: 'then', symbols: '' }], FulfilledAttributePattern)\n  };\n  public 'then'(name: string, value: string): AttrSyntax {\n    return new AttrSyntax(name, value, 'then', 'from-view');\n  }\n}\n\nexport class RejectedAttributePattern {\n  public static [Symbol.metadata] = {\n    [registrableMetadataKey]: AttributePattern.create([{ pattern: 'catch', symbols: '' }], RejectedAttributePattern)\n  };\n  public 'catch'(name: string, value: string): AttrSyntax {\n    return new AttrSyntax(name, value, 'catch', 'from-view');\n  }\n}\n", "import { twoWay } from '../../binding/interfaces-bindings';\nimport { INode } from '../../dom.node';\nimport { IPlatform } from '../../platform';\nimport { attrTypeName, type CustomAttributeStaticAuDefinition } from '../custom-attribute';\nimport type { ICustomAttributeController, ICustomAttributeViewModel } from '../../templating/controller';\nimport { resolve } from '@aurelia/kernel';\n\n/**\n * Focus attribute for element focus binding\n */\nexport class Focus implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'focus',\n    bindables: {\n      value: { mode: twoWay },\n    }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>;\n\n  public value: unknown;\n\n  /**\n   * Indicates whether `apply` should be called when `attached` callback is invoked\n   *\n   * @internal\n   */\n  private _needsApply: boolean = false;\n\n  /** @internal */\n  private readonly _element = resolve(INode) as INode<HTMLElement>;\n\n  /** @internal */\n  private readonly _platform = resolve(IPlatform);\n\n  public binding(): void {\n    this.valueChanged();\n  }\n\n  /**\n   * Invoked everytime the bound value changes.\n   *\n   * @param newValue - The new value.\n   */\n  public valueChanged(): void {\n    // In theory, we could/should react immediately\n    // but focus state of an element cannot be achieved\n    // while it's disconnected from the document\n    // thus, there neesd to be a check if it's currently connected or not\n    // before applying the value to the element\n    if (this.$controller.isActive) {\n      this._apply();\n    } else {\n      // If the element is not currently connect\n      // toggle the flag to add pending work for later\n      // in attached lifecycle\n      this._needsApply = true;\n    }\n  }\n\n  /**\n   * Invoked when the attribute is attached to the DOM.\n   */\n  public attached(): void {\n    if (this._needsApply) {\n      this._needsApply = false;\n      this._apply();\n    }\n    this._element.addEventListener('focus', this);\n    this._element.addEventListener('blur', this);\n  }\n\n  /**\n   * Invoked when the attribute is afterDetachChildren from the DOM.\n   */\n  public detaching(): void {\n    const el = this._element;\n    el.removeEventListener('focus', this);\n    el.removeEventListener('blur', this);\n  }\n\n  /**\n   * EventTarget interface handler for better memory usage\n   */\n  public handleEvent(e: FocusEvent): void {\n    // there are only two event listened to\n    // if the even is focus, it menans the element is focused\n    // only need to switch the value to true\n    if (e.type === 'focus') {\n      this.value = true;\n    } else if (!this._isElFocused) {\n      // else, it's blur event\n      // when a blur event happens, there are two situations\n      // 1. the element itself lost the focus\n      // 2. window lost the focus\n      // To handle both (1) and (2), only need to check if\n      // current active element is still the same element of this focus custom attribute\n      // If it's not, it's a blur event happened on Window because the browser tab lost focus\n      this.value = false;\n    }\n  }\n\n  /**\n   * Focus/blur based on current value\n   *\n   * @internal\n   */\n  private _apply(): void {\n    const el = this._element;\n    const isFocused = this._isElFocused;\n    const shouldFocus = this.value;\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (shouldFocus && !isFocused) {\n      el.focus();\n      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    } else if (!shouldFocus && isFocused) {\n      el.blur();\n    }\n  }\n\n  /** @internal */\n  private get _isElFocused(): boolean {\n    return this._element === this._platform.document.activeElement;\n  }\n}\n", "import { onResolve, resolve, isPromise, isString } from '@aurelia/kernel';\nimport { IRenderLocation, setEffectiveParentNode } from '../../dom';\nimport { IPlatform } from '../../platform';\nimport { IViewFactory } from '../../templating/view';\nimport { CustomAttributeStaticAuDefinition, attrTypeName } from '../custom-attribute';\nimport { rethrow } from '../../utilities';\nimport { createLocation, insertManyBefore } from '../../utilities-dom';\nimport type { ControllerVisitor, ICustomAttributeController, ICustomAttributeViewModel, IHydratedController, ISyntheticView } from '../../templating/controller';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport type PortalTarget = string | Element | null | undefined;\ntype ResolvedTarget = Element;\n\nexport type PortalLifecycleCallback = (target: PortalTarget, view: ISyntheticView) => void | Promise<void>;\n\nexport class Portal implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition<keyof Pick<\n    Portal,\n    'target' | 'position' | 'renderContext' | 'strict' | 'deactivating' | 'deactivated' | 'activated' | 'activating' | 'callbackContext'\n  >> = {\n    type: attrTypeName,\n    name: 'portal',\n    isTemplateController: true,\n    bindables: [\n      { name: 'target', primary: true },\n      'position',\n      'activated',\n      'activating',\n      'callbackContext',\n      { name: 'renderContext', callback: 'targetChanged' },\n      'strict',\n      'deactivated',\n      'deactivating'\n    ],\n    // bindables: {\n    //   target: { primary: true },\n    //   position: true,\n    //   renderContext: { callback: 'targetChanged' },\n    //   activated: true,\n    //   activating: true,\n    //   callbackContext: true,\n    //   deactivated: true,\n    //   deactivating: true,\n    //   strict: true\n    // }\n  };\n\n  public readonly $controller!: ICustomAttributeController<this>;\n\n  public target: PortalTarget;\n  public position: InsertPosition = 'beforeend';\n  public renderContext: PortalTarget;\n  public strict: boolean = false;\n  public deactivating?: PortalLifecycleCallback;\n  public activating?: PortalLifecycleCallback;\n  public deactivated?: PortalLifecycleCallback;\n  public activated?: PortalLifecycleCallback;\n  public callbackContext: unknown;\n\n  public view: ISyntheticView;\n\n  /** @internal */ private _resolvedTarget: ResolvedTarget;\n  /** @internal */ private readonly _platform: IPlatform;\n  /** @internal */ private readonly _targetLocation: IRenderLocation;\n\n  public constructor() {\n    const factory = resolve(IViewFactory);\n    const originalLoc = resolve(IRenderLocation);\n    const p = resolve(IPlatform);\n    this._platform = p;\n    // to make the shape of this object consistent.\n    // todo: is this necessary\n    this._resolvedTarget = p.document.createElement('div');\n\n    (this.view = factory.create()).setLocation(\n      this._targetLocation = createLocation(p)\n    );\n    setEffectiveParentNode(this.view.nodes, originalLoc as unknown as Node);\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n  ): void | Promise<void> {\n    if (this.callbackContext == null) {\n      this.callbackContext = this.$controller.scope.bindingContext;\n    }\n    const newTarget = this._resolvedTarget = this._getTarget();\n    this._moveLocation(newTarget, this.position);\n\n    return this._activating(initiator, newTarget);\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n  ): void | Promise<void> {\n    return this._deactivating(initiator, this._resolvedTarget);\n  }\n\n  public targetChanged(): void {\n    const { $controller } = this;\n    if (!$controller.isActive) {\n      return;\n    }\n\n    const newTarget = this._getTarget();\n\n    if (this._resolvedTarget === newTarget) {\n      return;\n    }\n    this._resolvedTarget = newTarget;\n\n    // TODO(fkleuver): fix and test possible race condition\n    const ret = onResolve(\n      this._deactivating(null, newTarget),\n      () => {\n        this._moveLocation(newTarget, this.position);\n        return this._activating(null, newTarget);\n      },\n    );\n    if (isPromise(ret)) { ret.catch(rethrow); }\n  }\n\n  public positionChanged(): void {\n    const { $controller, _resolvedTarget } = this;\n    if (!$controller.isActive) {\n      return;\n    }\n    // TODO(fkleuver): fix and test possible race condition\n    const ret = onResolve(\n      this._deactivating(null, _resolvedTarget),\n      () => {\n        this._moveLocation(_resolvedTarget, this.position);\n        return this._activating(null, _resolvedTarget);\n      },\n    );\n    if (isPromise(ret)) { ret.catch(rethrow); }\n  }\n\n  /** @internal */\n  private _activating(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { activating, callbackContext, view } = this;\n\n    // view.setHost(target);\n\n    return onResolve(\n      activating?.call(callbackContext, target, view),\n      () => {\n        return this._activate(initiator, target);\n      },\n    );\n  }\n\n  /** @internal */\n  private _activate(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { $controller, view } = this;\n\n    if (initiator === null) {\n      view.nodes.insertBefore(this._targetLocation);\n    } else {\n      // TODO(fkleuver): fix and test possible race condition\n      return onResolve(\n        view.activate(initiator ?? view, $controller, $controller.scope),\n        () => {\n          return this._activated(target);\n        },\n      );\n    }\n\n    return this._activated(target);\n  }\n\n  /** @internal */\n  private _activated(\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { activated, callbackContext, view } = this;\n\n    return activated?.call(callbackContext, target, view);\n  }\n\n  /** @internal */\n  private _deactivating(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { deactivating, callbackContext, view } = this;\n\n    return onResolve(\n      deactivating?.call(callbackContext, target, view),\n      () => {\n        return this._deactivate(initiator, target);\n      },\n    );\n  }\n\n  /** @internal */\n  private _deactivate(\n    initiator: IHydratedController | null,\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { $controller, view } = this;\n\n    if (initiator === null) {\n      view.nodes.remove();\n    } else {\n      return onResolve(\n        view.deactivate(initiator, $controller),\n        () => {\n          return this._deactivated(target);\n        },\n      );\n    }\n\n    return this._deactivated(target);\n  }\n\n  /** @internal */\n  private _deactivated(\n    target: ResolvedTarget,\n  ): void | Promise<void> {\n    const { deactivated, callbackContext, view } = this;\n\n    return onResolve(\n      deactivated?.call(callbackContext, target, view),\n      () => this._removeLocation()\n    );\n  }\n\n  /** @internal */\n  private _getTarget(): ResolvedTarget {\n    const p = this._platform;\n    // with a $ in front to make it less confusing/error prone\n    const $document = p.document;\n    let target = this.target;\n    let context = this.renderContext;\n\n    if (target === '') {\n      if (this.strict) {\n        throw createMappedError(ErrorNames.portal_query_empty);\n      }\n      return $document.body;\n    }\n\n    if (isString(target)) {\n      let queryContext: ParentNode = $document;\n      if (isString(context)) {\n        context = $document.querySelector(context) as ResolvedTarget;\n      }\n      if (context instanceof p.Node) {\n        queryContext = context;\n      }\n      target = queryContext.querySelector(target) as ResolvedTarget;\n    }\n\n    if (target instanceof p.Node) {\n      return target;\n    }\n\n    if (target == null) {\n      if (this.strict) {\n        throw createMappedError(ErrorNames.portal_no_target);\n      }\n      return $document.body;\n    }\n\n    return target;\n  }\n\n  /** @internal */\n  private _removeLocation(): void {\n    this._targetLocation.remove();\n    this._targetLocation.$start!.remove();\n  }\n\n  /** @internal */\n  private _moveLocation(target: Element, position: InsertPosition) {\n    const end = this._targetLocation;\n    const start = end.$start!;\n    const parent = target.parentNode;\n    const nodes = [start, end];\n    switch (position) {\n      case 'beforeend':\n        insertManyBefore(target, null, nodes);\n        break;\n      case 'afterbegin':\n        insertManyBefore(target, target.firstChild, nodes);\n        break;\n      case 'beforebegin':\n        insertManyBefore(parent, target, nodes);\n        break;\n      case 'afterend':\n        insertManyBefore(parent, target.nextSibling, nodes);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw createMappedError(ErrorNames.portal_invalid_insert_position, position);\n    }\n  }\n\n  public dispose(): void {\n    this.view.dispose();\n    this.view = (void 0)!;\n    this.callbackContext = null;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n}\n", "import { IContainer, InstanceProvider, Writable, emptyArray, isFunction, onResolve, resolve } from '@aurelia/kernel';\nimport { Scope } from '@aurelia/runtime';\nimport { IInstruction, type HydrateElementInstruction } from '@aurelia/template-compiler';\nimport { IRenderLocation } from '../../dom';\nimport { CustomElementDefinition, CustomElementStaticAuDefinition, elementTypeName } from '../custom-element';\nimport { IHydrationContext } from '../../templating/controller';\nimport { IRendering } from '../../templating/rendering';\nimport { registerResolver } from '../../utilities-di';\nimport { createMutationObserver, isElement } from '../../utilities-dom';\n\nimport type { ControllerVisitor, ICustomElementController, ICustomElementViewModel, IHydratedController, IHydratedParentController, ISyntheticView } from '../../templating/controller';\nimport type { IViewFactory } from '../../templating/view';\nimport { type IAuSlot, type IAuSlotSubscriber, IAuSlotWatcher, defaultSlotName, auslotAttr } from '../../templating/controller.projection';\n\nlet emptyTemplate: CustomElementDefinition;\n\nexport class AuSlot implements ICustomElementViewModel, IAuSlot {\n  public static readonly $au: CustomElementStaticAuDefinition = {\n    type: elementTypeName,\n    name: 'au-slot',\n    template: null,\n    containerless: true,\n    processContent(el, p, data) {\n      data.name = el.getAttribute('name') ?? defaultSlotName;\n\n      let node: Node | null = el.firstChild;\n      let next: Node | null = null;\n      while (node !== null) {\n        next = node.nextSibling;\n        if (isElement(node) && node.hasAttribute(auslotAttr)) {\n          if (__DEV__) {\n            // eslint-disable-next-line no-console\n            console.warn(\n              `[DEV:aurelia] detected [au-slot] attribute on a child node`,\n              `of an <au-slot> element: \"<${node.nodeName} au-slot>\".`,\n              `This element will be ignored and removed`\n            );\n          }\n          el.removeChild(node);\n        }\n        node = next;\n      }\n    },\n    bindables: ['expose', 'slotchange'],\n  };\n\n  public readonly view: ISyntheticView;\n  /** @internal */\n  public readonly $controller!: ICustomElementController<this>; // This is set by the controller after this instance is constructed\n\n  /** @internal */ private readonly _location: IRenderLocation;\n  /** @internal */ private _parentScope: Scope | null = null;\n  /** @internal */ private _outerScope: Scope | null = null;\n  /** @internal */ private readonly _hasProjection: boolean;\n  /** @internal */ private readonly _hdrContext: IHydrationContext;\n  /** @internal */ private readonly _slotwatchers: readonly IAuSlotWatcher[];\n  /** @internal */ private readonly _hasSlotWatcher: boolean;\n  /** @internal */ private _attached: boolean = false;\n\n  /**\n   * The binding context that will be exposed to slotted content\n   */\n  public expose: object | null = null;\n\n  /**\n   * A callback that will be called when the content of this slot changed\n   */\n  public slotchange: ((name: string, nodes: readonly Node[]) => void) | null = null;\n\n  public constructor() {\n    const hdrContext = resolve(IHydrationContext);\n    const location = resolve(IRenderLocation);\n    const instruction = resolve(IInstruction) as HydrateElementInstruction<{ name: string }>;\n    const rendering = resolve(IRendering);\n    const slotName = this.name = instruction.data.name;\n    // when <au-slot> is empty, there's not even projections\n    // hence ?. operator is used\n    // for fallback, there's only default slot used\n    const fallback = instruction.projections?.[defaultSlotName];\n    const projection = hdrContext.instruction?.projections?.[slotName];\n    const contextContainer = hdrContext.controller.container;\n    let factory: IViewFactory;\n    let container: IContainer;\n\n    if (projection == null) {\n      container = contextContainer.createChild({ inheritParentResources: true });\n      factory = rendering.getViewFactory(fallback ?? (emptyTemplate ??= CustomElementDefinition.create({\n        name: 'au-slot-empty-template',\n        template: '',\n        needsCompile: false,\n      })), container);\n      this._hasProjection = false;\n    } else {\n      // projection could happen within a projection, example:\n      // --my-app--\n      // <s-1>\n      //   ---projection 1---\n      //   <s-2>\n      //     ---projection 2---\n      //     <s-3>\n      // for the template above, if <s-3> is injecting <S1>,\n      // we won't find the information in the hydration context hierarchy <MyApp>/<S3>\n      // as it's a flat wysiwyg structure based on the template html\n      //\n      // since we are constructing the projection (2) view based on the\n      // container of <my-app>, we need to pre-register all information stored\n      // in projection (1) into the container created for the projection (2) view\n      // =============================\n\n      // my-app template:\n      // my-app  --- hydration context\n      // <el>     --- owning element (this has this <au-slot> that uses ---projection)\n      //   <s-1>  --- projection\n      //\n      container = contextContainer.createChild();\n      // registering resources from the parent hydration context is necessary\n      // as that's where the projection is declared in the template\n      //\n      // if neccessary, we can do the same gymnastic of registering information related to\n      // a custom element registration like in renderer.ts from line 1088 to 1098\n      // so we don't accidentally get information related to owning element (host, controller, instruction etc...)\n      // although it may be more desirable to have owning element information available here\n      container.useResources(hdrContext.parent!.controller.container);\n      // doing this to shadow the owning element hydration context\n      // since we created a container out of the owning element container\n      // instead of the hydration context container\n      registerResolver(container, IHydrationContext, new InstanceProvider(void 0, hdrContext.parent));\n      factory = rendering.getViewFactory(projection, container);\n      this._hasProjection = true;\n      this._slotwatchers = contextContainer.getAll(IAuSlotWatcher, false)?.filter(w => w.slotName === '*' || w.slotName === slotName) ?? emptyArray;\n    }\n    this._hasSlotWatcher = (this._slotwatchers ??= emptyArray).length > 0;\n    this._hdrContext = hdrContext;\n    this.view = factory.create().setLocation(this._location = location);\n  }\n\n  // all the following properties (name, nodes, _subs, subscribe & unsubscribe) are relevant to the slot watcher feature\n  // so grouping them here for better readability\n\n  public readonly name: string;\n\n  public get nodes() {\n    const nodes = [];\n    const location = this._location;\n    let curr = location.$start!.nextSibling;\n    while (curr != null && curr !== location) {\n      if (curr.nodeType !== /* comment */8) {\n        nodes.push(curr);\n      }\n      curr = curr.nextSibling;\n    }\n    return nodes;\n  }\n  /** @internal */\n  private readonly _subs = new Set<IAuSlotSubscriber>();\n\n  public subscribe(subscriber: IAuSlotSubscriber): void {\n    this._subs.add(subscriber);\n  }\n\n  public unsubscribe(subscriber: IAuSlotSubscriber): void {\n    this._subs.delete(subscriber);\n  }\n\n  public binding(\n    _initiator: IHydratedController,\n    parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._parentScope = parent.scope;\n\n    // The following block finds the real host scope for the content of this <au-slot>\n    //\n    // if this <au-slot> was created by another au slot, the controller hierarchy will be like this:\n    // C(au-slot)#1 --> C(synthetic)#1 --> C(au-slot)#2 --> C(synthetic)#2\n    //\n    // C(synthetic)#2 is what will provide the content for C(au-slot)#1\n    // but C(au-slot)#1 is what will provide the $host value for the content of C(au-slot)#2\n    //\n    // example:\n    // <template as-custom-element=\"parent\">\n    //   <child>\n    //    <au-slot> #2\n    //   </child>\n    // ...\n    // <template as-custom-element=\"child\">\n    //  <au-slot> #1\n    //\n    // because of this structure, walk 2 level of controller at once to find the right parent scope for $host value\n    while (parent.vmKind === 'synthetic' && parent.parent?.viewModel instanceof AuSlot) {\n      parent = parent.parent.parent as IHydratedParentController;\n    }\n    const host = parent.scope.bindingContext;\n\n    let outerScope: Scope;\n    if (this._hasProjection) {\n      // if there is a projection,\n      // then the au-slot should connect the outer scope with the inner scope binding context\n      // via overlaying the outerscope with another scope that has\n      // - binding context & override context pointing to the outer scope binding & override context respectively\n      // - override context has the $host pointing to inner scope binding context\n      outerScope = this._hdrContext.controller.scope.parent!;\n      (this._outerScope = Scope.fromParent(outerScope, outerScope.bindingContext))\n        .overrideContext.$host = this.expose ?? host;\n    }\n  }\n\n  public attaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    return onResolve(this.view.activate(\n      initiator,\n      this.$controller,\n      this._hasProjection ? this._outerScope! : this._parentScope!,\n    ), () => {\n      if (this._hasSlotWatcher || isFunction(this.slotchange)) {\n        this._slotwatchers.forEach(w => w.watch(this));\n        this._observe();\n        this._notifySlotChange();\n        this._attached = true;\n      }\n    });\n  }\n\n  public detaching(\n    initiator: IHydratedController,\n    _parent: IHydratedParentController,\n  ): void | Promise<void> {\n    this._attached = false;\n    this._unobserve();\n    this._slotwatchers.forEach(w => w.unwatch(this));\n    return this.view.deactivate(initiator, this.$controller);\n  }\n\n  public exposeChanged(v: object): void {\n    if (this._hasProjection && this._outerScope != null) {\n      this._outerScope.overrideContext.$host = v;\n    }\n  }\n\n  public dispose(): void {\n    this.view.dispose();\n    (this as Writable<this>).view = (void 0)!;\n  }\n\n  public accept(visitor: ControllerVisitor): void | true {\n    if (this.view?.accept(visitor) === true) {\n      return true;\n    }\n  }\n\n  /** @internal */\n  private _observer: MutationObserver | null = null;\n  /** @internal */\n  private _observe(): void {\n    if (this._observer != null) {\n      return;\n    }\n    const location = this._location;\n    const parent = location.parentElement;\n    if (parent == null) {\n      return;\n    }\n    (this._observer = createMutationObserver(parent, records => {\n      if (isMutationWithinLocation(location, records)) {\n        this._notifySlotChange();\n      }\n    })).observe(parent, { childList: true });\n  }\n\n  /** @internal */\n  private _unobserve(): void {\n    this._observer?.disconnect();\n    this._observer = null;\n  }\n\n  /** @internal */\n  private _notifySlotChange() {\n    const nodes = this.nodes;\n    const subs = new Set(this._subs);\n    let sub: IAuSlotSubscriber;\n    if (this._attached) {\n      this.slotchange?.call(void 0, this.name, nodes);\n    }\n    for (sub of subs) {\n      sub.handleSlotChange(this, nodes);\n    }\n  }\n}\n\nconst comparePosition = (a: Node, b: Node) => a.compareDocumentPosition(b);\nconst isMutationWithinLocation = (location: IRenderLocation, records: MutationRecord[]) => {\n  for (const { addedNodes, removedNodes, nextSibling } of records) {\n    let i = 0;\n    // eslint-disable-next-line prefer-const\n    let ii = addedNodes.length;\n    let node: Node;\n    for (; i < ii; ++i) {\n      node = addedNodes[i];\n      if (comparePosition(location.$start!, node) === /* DOCUMENT_POSITION_FOLLOWING */4\n        && comparePosition(location, node) === /* DOCUMENT_POSITION_PRECEDING */2\n      ) {\n        return true;\n      }\n    }\n    if (removedNodes.length > 0) {\n      if (nextSibling != null && comparePosition(location.$start!, nextSibling) === /* DOCUMENT_POSITION_FOLLOWING */4\n        && comparePosition(location, nextSibling) === /* DOCUMENT_POSITION_PRECEDING */2\n      ) {\n        return true;\n      }\n    }\n  }\n};\n", "import { isFunction, isPromise, type Constructable, IContainer, InstanceProvider, type MaybePromise, emptyArray, onResolve, resolve, transient } from '@aurelia/kernel';\nimport { IExpressionParser } from '@aurelia/expression-parser';\nimport { IObserverLocator, Scope } from '@aurelia/runtime';\nimport { HydrateElementInstruction, IInstruction, ITemplateCompiler, AttrSyntax } from '@aurelia/template-compiler';\nimport { IRenderLocation, convertToRenderLocation, registerHostNode } from '../../dom';\nimport { INode } from '../../dom.node';\nimport { IPlatform } from '../../platform';\nimport { Controller, HydrationContext, IController, ICustomElementController, IHydratedController, IHydrationContext, ISyntheticView, vmkCe } from '../../templating/controller';\nimport { IRendering } from '../../templating/rendering';\nimport { registerResolver } from '../../utilities-di';\nimport { CustomElement, CustomElementDefinition, CustomElementStaticAuDefinition, elementTypeName } from '../custom-element';\nimport { ErrorNames, createMappedError } from '../../errors';\nimport { fromView } from '../../binding/interfaces-bindings';\nimport { SpreadBinding } from '../../binding/spread-binding';\n\n/**\n * An optional interface describing the dynamic composition activate convention.\n */\nexport interface IDynamicComponentActivate<T> {\n  /**\n   * Implement this hook if you want to perform custom logic just before the component is is composed.\n   * The returned value is not used.\n   */\n  activate?(model?: T): unknown;\n}\n\ntype ChangeSource = keyof Pick<AuCompose, 'template' | 'component' | 'model' | 'scopeBehavior' | 'composing' | 'composition' | 'tag'>;\n\n// Desired usage:\n// <au-component template.bind=\"Promise<string>\" component.bind=\"\" model.bind=\"\" />\n// <au-component template.bind=\"<string>\" model.bind=\"\" />\nexport class AuCompose {\n  /** @internal */\n  public static readonly $au: CustomElementStaticAuDefinition<keyof Pick<\n    AuCompose,\n    'template' | 'component' | 'model' | 'scopeBehavior' | 'composing' | 'composition' | 'tag'\n  >> = {\n    type: elementTypeName,\n    name: 'au-compose',\n    capture: true,\n    containerless: true,\n    bindables: [\n      'template',\n      'component',\n      'model',\n      { name: 'scopeBehavior', set: v => {\n        if (v === 'scoped' || v === 'auto') {\n          return v;\n        }\n        throw createMappedError(ErrorNames.au_compose_invalid_scope_behavior, v);\n      }},\n      { name: 'composing', mode: fromView},\n      { name: 'composition', mode: fromView },\n      'tag'\n    ]\n  };\n\n  /* determine what template used to compose the component */\n  public template?: string | Promise<string>;\n\n  /**\n   * Determine the component instance used to compose the component.\n   *\n   * - When a string is given as a value, it will be used as the name of the custom element to compose.\n   * If there is no locally or globally registered custom element with that name, an error will be thrown.\n   *\n   * - When an object is given as a value, the object will be used as the component instance.\n   * - When a constructor is given as a value, the constructor will be used to create the component instance.\n   * - When a null/undefined is given as a value, the component will be composed as a template-only composition with an empty component instance.\n   * - When a promise is given as a value, the promise will be awaited and the resolved value will be used as the value.\n   */\n  public component?: string | Constructable | object | Promise<string | Constructable | object>;\n\n  /* the model used to pass to activate lifecycle of the component */\n  public model?: unknown;\n\n  /**\n   * Control scoping behavior of the view created by the au-compose.\n   * This only affects template-only composition. Does not have effects on custom element composition.\n   *\n   * auto = inherit parent scope\n   * scoped = do not inherit parent scope\n   */\n  public scopeBehavior: 'auto' | 'scoped' = 'auto';\n\n  /** @internal */\n  private _composing?: Promise<void> | void;\n  public get composing(): Promise<void> | void {\n    return this._composing;\n  }\n\n  /** @internal */\n  private _composition: ICompositionController | undefined = void 0;\n  public get composition(): ICompositionController | undefined {\n    return this._composition;\n  }\n\n  /**\n   * The tag name of the element to be created for non custom element composition.\n   *\n   * `null`/`undefined` means containerless\n   */\n  public tag: string | null | undefined = null;\n\n  /** @internal */ public readonly $controller!: ICustomElementController<AuCompose>;\n  /** @internal */ private readonly _container = resolve(IContainer);\n  /** @internal */ private readonly parent = resolve(IController) as ISyntheticView | ICustomElementController;\n  /** @internal */ private readonly _host = resolve(INode) as HTMLElement;\n  /** @internal */ private readonly _location = resolve(IRenderLocation);\n  /** @internal */ private readonly _platform = resolve(IPlatform);\n  /** @internal */ private readonly _rendering = resolve(IRendering);\n  /** @internal */ private readonly _instruction = resolve(IInstruction) as HydrateElementInstruction;\n  /** @internal */ private readonly _contextFactory = resolve(transient(CompositionContextFactory, null!));\n  /** @internal */ private readonly _compiler = resolve(ITemplateCompiler);\n  /** @internal */ private readonly _hydrationContext = resolve(IHydrationContext);\n  /** @internal */ private readonly _exprParser = resolve(IExpressionParser);\n  /** @internal */ private readonly _observerLocator = resolve(IObserverLocator);\n  /** @internal */ private _attached = false;\n\n  public attaching(initiator: IHydratedController, _parent: IHydratedController): void | Promise<void> {\n    this._attached = true;\n    return this._composing = onResolve(\n      this.queue(new ChangeInfo(this.template, this.component, this.model, void 0), initiator),\n      (context) => {\n        if (this._contextFactory._isCurrent(context)) {\n          this._composing = void 0;\n        }\n      }\n    );\n  }\n\n  public detaching(initiator: IHydratedController): void | Promise<void> {\n    this._attached = false;\n    const cmpstn = this._composition;\n    const pending = this._composing;\n    this._contextFactory.invalidate();\n    this._composition = this._composing = void 0;\n    return onResolve(pending, () => cmpstn?.deactivate(initiator));\n  }\n\n  /** @internal */\n  public propertyChanged(name: ChangeSource): void {\n    if (!this._attached) return;\n    if (name === 'composing' || name === 'composition') return;\n    if (name === 'model' && this._composition != null) {\n      this._composition.update(this.model);\n      return;\n    }\n    // tag change does not affect existing custom element composition\n    if (name === 'tag' && this._composition?.controller.vmKind === vmkCe) {\n      if (__DEV__) {\n        console.warn('[DEV:aurelia] Changing tag name of a custom element composition is ignored.'); // eslint-disable-line\n      }\n      return;\n    }\n\n    this._composing = onResolve(this._composing, () =>\n      onResolve(\n        this.queue(new ChangeInfo(this.template, this.component, this.model, name), void 0),\n        (context) => {\n          if (this._contextFactory._isCurrent(context)) {\n            this._composing = void 0;\n          }\n        }\n      )\n    );\n  }\n\n  /** @internal */\n  private queue(change: ChangeInfo, initiator: IHydratedController | undefined): CompositionContext | Promise<CompositionContext> {\n    const factory = this._contextFactory;\n    const prevCompositionCtrl = this._composition;\n    // todo: handle consequitive changes that create multiple queues\n    return onResolve(\n      factory.create(change),\n      context => {\n        // Don't compose [stale] template/component\n        // by always ensuring that the composition context is the latest one\n        if (factory._isCurrent(context)) {\n          return onResolve(this.compose(context), (result) => {\n            // Don't activate [stale] controller\n            // by always ensuring that the composition context is the latest one\n            if (factory._isCurrent(context)) {\n              return onResolve(result.activate(initiator), () => {\n                // Don't conclude the [stale] composition\n                // by always ensuring that the composition context is the latest one\n                if (factory._isCurrent(context)) {\n                  // after activation, if the composition context is still the most recent one\n                  // then the job is done\n                  this._composition = result;\n                  return onResolve(prevCompositionCtrl?.deactivate(initiator), () => context);\n                } else {\n                  // the stale controller should be deactivated\n                  return onResolve(\n                    result.controller.deactivate(result.controller, this.$controller),\n                    // todo: do we need to deactivate?\n                    () => {\n                      result.controller.dispose();\n                      return context;\n                    }\n                  );\n                }\n              });\n            }\n\n            result.controller.dispose();\n            return context;\n          });\n        }\n\n        return context;\n      }\n    );\n  }\n\n  /** @internal */\n  private compose(context: CompositionContext): MaybePromise<ICompositionController> {\n    // todo: when both component and template are empty\n    //       should it throw or try it best to proceed?\n    //       current: proceed\n    const {\n      _template: template,\n      _component: component,\n      _model: model\n    } = context.change;\n    const {\n      _container: container,\n      $controller,\n      _location: loc,\n      _instruction\n    } = this;\n    const vmDef = this._getDefinition(this._hydrationContext.controller.container, component);\n    const childCtn: IContainer = container.createChild();\n\n    const compositionHost = this._platform.document.createElement(vmDef == null ? this.tag ?? 'div' : vmDef.name);\n\n    loc.parentNode!.insertBefore(compositionHost, loc);\n\n    let compositionLocation: IRenderLocation | null;\n    if (vmDef == null) {\n      compositionLocation = this.tag == null ? convertToRenderLocation(compositionHost) : null;\n    } else {\n      compositionLocation = vmDef.containerless ? convertToRenderLocation(compositionHost) : null;\n    }\n\n    const removeCompositionHost = () => {\n      compositionHost.remove();\n      if (compositionLocation != null) {\n        let curr = compositionLocation.$start!.nextSibling;\n        let next: ChildNode | null = null;\n        while (curr !== null && curr !== compositionLocation) {\n          next = curr.nextSibling;\n          curr.remove();\n          curr = next;\n        }\n        compositionLocation.$start?.remove();\n        compositionLocation.remove();\n      }\n    };\n\n    const comp = this._createComponentInstance(\n      childCtn,\n      typeof component === 'string' ? vmDef!.Type : component,\n      compositionHost,\n      compositionLocation\n    );\n    const compose: () => ICompositionController = () => {\n      const aucomposeCapturedAttrs = _instruction.captures! ?? emptyArray;\n      // custom element based composition\n      if (vmDef !== null) {\n        const capture = vmDef.capture;\n        const [capturedBindingAttrs, transferedToHostBindingAttrs] = aucomposeCapturedAttrs\n          .reduce((attrGroups: [AttrSyntax[], AttrSyntax[]], attr) => {\n            const shouldCapture = !(attr.target in vmDef.bindables)\n              && (capture === true\n                || isFunction(capture) && !!capture(attr.target));\n            attrGroups[shouldCapture ? 0 : 1].push(attr);\n            return attrGroups;\n          }, [[], []]);\n\n        const controller = Controller.$el(\n          childCtn,\n          comp,\n          compositionHost,\n          {\n            projections: _instruction.projections,\n            captures: capturedBindingAttrs\n          },\n          vmDef,\n          compositionLocation\n        );\n        // Theoretically these bindings aren't bindings of the composed custom element\n        // Though they are meant to be activated (bound)/ deactivated (unbound) together\n        // with the custom element controller, so it's practically ok to let the composed\n        // custom element manage these bindings\n        this._createSpreadBindings(compositionHost, vmDef, transferedToHostBindingAttrs).forEach(b => controller.addBinding(b));\n\n        return new CompositionController(\n          controller,\n          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, $controller.scope.parent!),\n          // todo: call deactivate on the component component\n          (deactachInitiator) => onResolve(\n            controller.deactivate(deactachInitiator ?? controller, $controller),\n            removeCompositionHost\n          ),\n          // casting is technically incorrect\n          // but it's ignored in the caller anyway\n          (model) => comp.activate?.(model),\n          context,\n        );\n      } else {\n        const targetDef = CustomElementDefinition.create({\n          name: CustomElement.generateName(),\n          template: template,\n        });\n        const viewFactory = this._rendering.getViewFactory(targetDef, childCtn);\n        const controller = Controller.$view(\n          viewFactory,\n          $controller\n        );\n        const scope = this.scopeBehavior === 'auto'\n          ? Scope.fromParent(this.parent.scope, comp)\n          : Scope.create(comp);\n\n        controller.setHost(compositionHost);\n        if (compositionLocation == null) {\n          // only spread the bindings if there is an actual host\n          // otherwise we may accidentally do unnecessary work\n          this._createSpreadBindings(compositionHost, targetDef, aucomposeCapturedAttrs).forEach(b => controller.addBinding(b));\n        } else {\n          controller.setLocation(compositionLocation);\n        }\n\n        return new CompositionController(\n          controller,\n          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, scope),\n          // todo: call deactivate on the component\n          // a difference with composing custom element is that we leave render location/host alone\n          // as they all share the same host/render location\n          (detachInitiator) => onResolve(\n            controller.deactivate(detachInitiator ?? controller, $controller),\n            removeCompositionHost\n          ),\n          // casting is technically incorrect\n          // but it's ignored in the caller anyway\n          (model) => comp.activate?.(model),\n          context,\n        );\n      }\n    };\n    if ('activate' in comp) {\n      // todo: try catch\n      // req:  ensure synchronosity of compositions that dont employ promise\n      return onResolve(comp.activate!(model), () => compose());\n    } else {\n      return compose();\n    }\n  }\n\n  /** @internal */\n  private _createComponentInstance(\n    container: IContainer,\n    comp: Constructable | object | undefined,\n    host: HTMLElement | IRenderLocation,\n    location: IRenderLocation | null,\n  ): IDynamicComponentActivate<unknown> {\n    if (comp == null) {\n      return new EmptyComponent();\n    }\n    if (typeof comp === 'object') {\n      return comp;\n    }\n\n    const p = this._platform;\n    registerHostNode(container, host, p);\n    registerResolver(\n      container,\n      IRenderLocation,\n      new InstanceProvider('IRenderLocation', location)\n    );\n\n    const instance = container.invoke(comp);\n    registerResolver(container, comp, new InstanceProvider('au-compose.component', instance));\n\n    return instance;\n  }\n\n  /** @internal */\n  private _getDefinition(container: IContainer, component?: string | object | Constructable) {\n    if (typeof component === 'string') {\n      const def = CustomElement.find(container, component);\n      if (def == null) {\n        throw createMappedError(ErrorNames.au_compose_component_name_not_found, component);\n      }\n      return def;\n    }\n\n    const Ctor = (isFunction(component)\n      ? component\n      : component?.constructor) as Constructable;\n    return CustomElement.isType(Ctor, void 0)\n      ? CustomElement.getDefinition(Ctor, null)\n      : null;\n  }\n\n  /** @internal */\n  private _createSpreadBindings(host: HTMLElement, def: CustomElementDefinition, capturedAttrs: AttrSyntax[]) {\n    const transferHydrationContext = new HydrationContext(\n      this.$controller,\n      { projections: null, captures: capturedAttrs },\n      this._hydrationContext.parent\n    );\n    return SpreadBinding.create(\n      transferHydrationContext,\n      host,\n      def,\n      this._rendering,\n      this._compiler,\n      this._platform,\n      this._exprParser,\n      this._observerLocator,\n    );\n  }\n}\n\nclass EmptyComponent { }\n\nexport interface ICompositionController {\n  readonly controller: IHydratedController;\n  readonly context: CompositionContext;\n  activate(initiator?: IHydratedController): void | Promise<void>;\n  // deactivation is done differently, compared to activation\n  // when the `<au-component/>` is deactivated, initiator will be an ancestor controller\n  //\n  // while when the value of the @bindables changes, initiator should be\n  // the controller wrapped in this composition controller\n  deactivate(detachInitator?: IHydratedController): void | Promise<void>;\n  update(model: unknown): unknown;\n}\n\nclass CompositionContextFactory {\n  private id = 0;\n\n  public _isCurrent(context: CompositionContext): boolean {\n    return context.id === this.id;\n  }\n\n  public create(changes: ChangeInfo): MaybePromise<CompositionContext> {\n    return onResolve(changes.load(), (loaded) => new CompositionContext(++this.id, loaded));\n  }\n\n  // simplify increasing the id will invalidate all previously created context\n  public invalidate(): void {\n    this.id++;\n  }\n}\n\nclass ChangeInfo {\n  public constructor(\n    public readonly _template: MaybePromise<string> | undefined,\n    public readonly _component: MaybePromise<string | Constructable | object> | undefined,\n    public readonly _model: unknown,\n    public readonly _src: ChangeSource | undefined,\n  ) { }\n\n  public load(): MaybePromise<LoadedChangeInfo> {\n    if (isPromise(this._template) || isPromise(this._component)) {\n      return Promise\n        .all([this._template, this._component])\n        .then(([template, component]) => {\n          return new LoadedChangeInfo(template, component, this._model, this._src);\n        });\n    } else {\n      return new LoadedChangeInfo(this._template, this._component, this._model, this._src);\n    }\n  }\n}\n\nclass LoadedChangeInfo {\n  public constructor(\n    public readonly _template: string | undefined,\n    public readonly _component: string | Constructable | object | undefined,\n    public readonly _model: unknown,\n    public readonly _src: ChangeSource | undefined,\n  ) { }\n}\n\nclass CompositionContext {\n  public constructor(\n    public readonly id: number,\n    public readonly change: LoadedChangeInfo,\n  ) { }\n}\n\nclass CompositionController implements ICompositionController {\n  private state: /* stopped */-1 | /* initial */0 | /* started */1 = 0;\n\n  public constructor(\n    public readonly controller: ISyntheticView | ICustomElementController,\n    private readonly start: (attachInitiator?: IHydratedController) => void | Promise<void>,\n    private readonly stop: (detachInitator?: IHydratedController) => void | Promise<void>,\n    public readonly update: (model: unknown) => unknown,\n    public readonly context: CompositionContext,\n  ) {\n\n  }\n\n  public activate(initiator?: IHydratedController) {\n    if (this.state !== 0) {\n      throw createMappedError(ErrorNames.au_compose_invalid_run, this);\n    }\n    this.state = 1;\n    return this.start(initiator);\n  }\n\n  public deactivate(detachInitator?: IHydratedController) {\n    switch (this.state) {\n      case 1:\n        this.state = -1;\n        return this.stop(detachInitator);\n      case -1:\n        throw createMappedError(ErrorNames.au_compose_duplicate_deactivate);\n      default:\n        this.state = -1;\n    }\n  }\n}\n", "import { resolve } from '@aurelia/kernel';\nimport { createInterface } from '../../utilities-di';\nimport { type ValueConverterInstance, type ValueConverterStaticAuDefinition, converterTypeName } from '../value-converter';\nimport { ErrorNames, createMappedError } from '../../errors';\n\nexport interface ISanitizer {\n  /**\n   * Sanitizes the provided input.\n   *\n   * @param input - The input to be sanitized.\n   */\n  sanitize(input: string): string;\n}\n\nexport const ISanitizer = /*@__PURE__*/createInterface<ISanitizer>('ISanitizer', x => x.singleton(class {\n  public sanitize(): string {\n    throw createMappedError(ErrorNames.method_not_implemented, 'sanitize');\n  }\n}));\n\n/**\n * Simple html sanitization converter to preserve whitelisted elements and attributes on a bound property containing html.\n */\nexport class SanitizeValueConverter implements ValueConverterInstance {\n  public static readonly $au: ValueConverterStaticAuDefinition = {\n    type: converterTypeName,\n    name: 'sanitize',\n  };\n\n  /** @internal */ private readonly _sanitizer = resolve(ISanitizer);\n\n  /**\n   * Process the provided markup that flows to the view.\n   *\n   * @param untrustedMarkup - The untrusted markup to be sanitized.\n   */\n  public toView(untrustedMarkup: string): string|null {\n    if (untrustedMarkup == null) {\n      return null;\n    }\n\n    return this._sanitizer.sanitize(untrustedMarkup);\n  }\n}\n", "import { INode } from '../../dom.node';\nimport { IPlatform } from '../../platform';\nimport { attrTypeName, type CustomAttributeStaticAuDefinition } from '../custom-attribute';\n\nimport type { ICustomAttributeViewModel } from '../../templating/controller';\nimport { IInstruction, HydrateAttributeInstruction } from '@aurelia/template-compiler';\nimport { resolve } from '@aurelia/kernel';\nimport { queueTask } from '@aurelia/runtime';\n\nexport class Show implements ICustomAttributeViewModel {\n  public static readonly $au: CustomAttributeStaticAuDefinition = {\n    type: attrTypeName,\n    name: 'show',\n    bindables: ['value'],\n    aliases: ['hide']\n  };\n\n  public value: unknown;\n\n  private readonly el = resolve(INode) as INode<HTMLElement>;\n  private readonly p = resolve(IPlatform);\n\n  /** @internal */ private _isActive: boolean = false;\n  /** @internal */ private _isQueued: boolean = false;\n\n  /** @internal */ private _isToggled: boolean;\n  /** @internal */ private readonly _base: boolean;\n\n  public constructor() {\n    const instr = resolve(IInstruction) as HydrateAttributeInstruction;\n    // if this is declared as a 'hide' attribute, then this.base will be false, inverting everything.\n    this._isToggled = this._base = instr.alias !== 'hide';\n  }\n\n  public binding(): void {\n    this._isActive = true;\n    this.update();\n  }\n\n  public detaching() {\n    this._isActive = false;\n    this._isQueued = false;\n  }\n\n  public valueChanged(): void {\n    if (this._isActive && !this._isQueued) {\n      this._isQueued = true;\n      queueTask(this.update);\n    }\n  }\n\n  private $val: string = '';\n  private $prio: string = '';\n  private readonly update = (): void => {\n    this._isQueued = false;\n\n    // Only compare at the synchronous moment when we're about to update, because the value might have changed since the update was queued.\n    if (Boolean(this.value) !== this._isToggled) {\n      if (this._isToggled === this._base) {\n        this._isToggled = !this._base;\n        // Note: in v1 we used the 'au-hide' class, but in v2 it's so trivial to conditionally apply classes (e.g. 'hide.class=\"someCondition\"'),\n        // that it's probably better to avoid the CSS inject infra involvement and keep this CA as simple as possible.\n        // Instead, just store and restore the property values (with each mutation, to account for in-between updates), to cover the common cases, until there is convincing feedback to do otherwise.\n        this.$val = this.el.style.getPropertyValue('display');\n        this.$prio = this.el.style.getPropertyPriority('display');\n        this.el.style.setProperty('display', 'none', 'important');\n      } else {\n        this._isToggled = this._base;\n        this.el.style.setProperty('display', this.$val, this.$prio);\n        // If the style attribute is now empty, remove it.\n        if (this.el.getAttribute('style') === '') {\n          this.el.removeAttribute('style');\n        }\n      }\n    }\n  };\n}\n", "import { IContainer, noop } from '@aurelia/kernel';\nimport { ExpressionParser } from '@aurelia/expression-parser';\nimport { DirtyChecker, ICoercionConfiguration } from '@aurelia/runtime';\nimport {\n  AtPrefixedTriggerAttributePattern,\n  ColonPrefixedBindAttributePattern,\n  DotSeparatedAttributePattern,\n  RefAttributePattern,\n  EventAttributePattern,\n\n  DefaultBindingCommand,\n  ForBindingCommand,\n  FromViewBindingCommand,\n  OneTimeBindingCommand,\n  ToViewBindingCommand,\n  TwoWayBindingCommand,\n  AttrBindingCommand,\n  CaptureBindingCommand,\n  ClassBindingCommand,\n  RefBindingCommand,\n  StyleBindingCommand,\n  TriggerBindingCommand,\n  SpreadValueBindingCommand,\n} from '@aurelia/template-compiler';\nimport {\n  CustomAttributeRenderer,\n  CustomElementRenderer,\n  InterpolationBindingRenderer,\n  IteratorBindingRenderer,\n  LetElementRenderer,\n  PropertyBindingRenderer,\n  RefBindingRenderer,\n  SetPropertyRenderer,\n  TemplateControllerRenderer,\n  AttributeBindingRenderer,\n  ListenerBindingRenderer,\n  SetAttributeRenderer,\n  StylePropertyBindingRenderer,\n  TextBindingRenderer,\n  SetClassAttributeRenderer,\n  SetStyleAttributeRenderer,\n  SpreadRenderer,\n  SpreadValueRenderer,\n} from './renderer';\nimport {\n  FromViewBindingBehavior,\n  OneTimeBindingBehavior,\n  ToViewBindingBehavior,\n  TwoWayBindingBehavior,\n} from './resources/binding-behaviors/binding-mode';\nimport { DebounceBindingBehavior } from './resources/binding-behaviors/debounce';\nimport { SignalBindingBehavior } from './resources/binding-behaviors/signals';\nimport { ThrottleBindingBehavior } from './resources/binding-behaviors/throttle';\nimport { AttrBindingBehavior } from './resources/binding-behaviors/attr';\nimport { SelfBindingBehavior } from './resources/binding-behaviors/self';\nimport { UpdateTriggerBindingBehavior } from './resources/binding-behaviors/update-trigger';\nimport { Focus } from './resources/custom-attributes/focus';\nimport { Show } from './resources/custom-attributes/show';\nimport { Portal } from './resources/template-controllers/portal';\nimport { Else, If } from './resources/template-controllers/if';\nimport { Repeat } from './resources/template-controllers/repeat';\nimport { With } from './resources/template-controllers/with';\nimport { Switch, Case, DefaultCase } from './resources/template-controllers/switch';\nimport {\n  PromiseTemplateController,\n  PendingTemplateController,\n  FulfilledTemplateController,\n  RejectedTemplateController,\n  PromiseAttributePattern,\n  FulfilledAttributePattern,\n  RejectedAttributePattern,\n} from './resources/template-controllers/promise';\nimport { AuCompose } from './resources/custom-elements/au-compose';\nimport { AuSlot } from './resources/custom-elements/au-slot';\nimport { SanitizeValueConverter } from './resources/value-converters/sanitize';\nimport { NodeObserverLocator } from './observation/observer-locator';\nimport { instanceRegistration } from './utilities-di';\nimport { EventModifierRegistration } from './binding/listener-binding';\nimport { RuntimeTemplateCompilerImplementation } from './compiler/template-compiler';\n\n/**\n * Default HTML-specific (but environment-agnostic) implementations for the following interfaces:\n * - `ITemplateCompiler`\n * - `ITargetAccessorLocator`\n * - `ITargetObserverLocator`\n */\nexport const DefaultComponents = [\n  RuntimeTemplateCompilerImplementation,\n  DirtyChecker,\n  NodeObserverLocator,\n];\n\n/**\n * Default binding syntax for the following attribute name patterns:\n * - `ref`\n * - `target.command` (dot-separated)\n */\nexport const DefaultBindingSyntax = [\n  RefAttributePattern,\n  DotSeparatedAttributePattern,\n  EventAttributePattern,\n  EventModifierRegistration,\n];\n\n/**\n * Binding syntax for short-hand attribute name patterns:\n * - `@target` (short-hand for `target.trigger`)\n * - `:target` (short-hand for `target.bind`)\n */\nexport const ShortHandBindingSyntax = [\n  AtPrefixedTriggerAttributePattern,\n  ColonPrefixedBindAttributePattern,\n];\n\n/**\n * Default HTML-specific (but environment-agnostic) binding commands:\n * - Property observation: `.bind`, `.one-time`, `.from-view`, `.to-view`, `.two-way\n * - Collection observation: `.for`\n * - Event listeners: `.trigger`, `.capture`\n */\nexport const DefaultBindingLanguage = [\n  DefaultBindingCommand,\n  OneTimeBindingCommand,\n  FromViewBindingCommand,\n  ToViewBindingCommand,\n  TwoWayBindingCommand,\n  ForBindingCommand,\n  RefBindingCommand,\n  TriggerBindingCommand,\n  CaptureBindingCommand,\n  ClassBindingCommand,\n  StyleBindingCommand,\n  AttrBindingCommand,\n  SpreadValueBindingCommand,\n];\n\n/**\n * Default HTML-specific (but environment-agnostic) resources:\n * - Binding Behaviors: `oneTime`, `toView`, `fromView`, `twoWay`, `signal`, `debounce`, `throttle`, `attr`, `self`, `updateTrigger`\n * - Custom Elements: `au-compose`, `au-slot`\n * - Custom Attributes: `blur`, `focus`, `portal`\n * - Template controllers: `if`/`else`, `repeat`, `with`\n * - Value Converters: `sanitize`\n */\nexport const DefaultResources = [\n  DebounceBindingBehavior,\n  OneTimeBindingBehavior,\n  ToViewBindingBehavior,\n  FromViewBindingBehavior,\n  SignalBindingBehavior,\n  ThrottleBindingBehavior,\n  TwoWayBindingBehavior,\n  SanitizeValueConverter,\n  If,\n  Else,\n  Repeat,\n  With,\n  Switch,\n  Case,\n  DefaultCase,\n  PromiseTemplateController,\n  PendingTemplateController,\n  FulfilledTemplateController,\n  RejectedTemplateController,\n  PromiseAttributePattern,\n  FulfilledAttributePattern,\n  RejectedAttributePattern,\n  AttrBindingBehavior,\n  SelfBindingBehavior,\n  UpdateTriggerBindingBehavior,\n  AuCompose,\n  Portal,\n  Focus,\n  Show,\n  AuSlot,\n];\n\n/**\n * Default renderers for:\n * - PropertyBinding: `bind`, `one-time`, `to-view`, `from-view`, `two-way`\n * - IteratorBinding: `for`\n * - CallBinding: `call`\n * - RefBinding: `ref`\n * - InterpolationBinding: `${}`\n * - SetProperty\n * - `customElement` hydration\n * - `customAttribute` hydration\n * - `templateController` hydration\n * - `let` element hydration\n * - Listener Bindings: `trigger`, `capture`, `delegate`\n * - SetAttribute\n * - StyleProperty: `style`, `css`\n * - TextBinding: `${}`\n */\nexport const DefaultRenderers = [\n  PropertyBindingRenderer,\n  IteratorBindingRenderer,\n  RefBindingRenderer,\n  InterpolationBindingRenderer,\n  SetPropertyRenderer,\n  CustomElementRenderer,\n  CustomAttributeRenderer,\n  TemplateControllerRenderer,\n  LetElementRenderer,\n  ListenerBindingRenderer,\n  AttributeBindingRenderer,\n  SetAttributeRenderer,\n  SetClassAttributeRenderer,\n  SetStyleAttributeRenderer,\n  StylePropertyBindingRenderer,\n  TextBindingRenderer,\n  SpreadRenderer,\n  SpreadValueRenderer,\n];\n\nexport const StandardConfiguration = /*@__PURE__*/createConfiguration(noop);\n\nfunction createConfiguration(optionsProvider: ConfigurationOptionsProvider) {\n  return {\n    optionsProvider,\n    /**\n     * Apply this configuration to the provided container.\n     */\n    register(container: IContainer): IContainer {\n      const runtimeConfigurationOptions: IRuntimeHtmlConfigurationOptions = {\n        coercingOptions: {\n          enableCoercion: false,\n          coerceNullish: false\n        }\n      };\n\n      optionsProvider(runtimeConfigurationOptions);\n\n      /**\n       * Standard DI configuration containing html-specific (but environment-agnostic) registrations:\n       * - `RuntimeConfiguration` from `@aurelia/runtime`\n       * - `DefaultComponents`\n       * - `DefaultResources`\n       * - `DefaultRenderers`\n       */\n      return container.register(\n        instanceRegistration(ICoercionConfiguration, runtimeConfigurationOptions.coercingOptions),\n        ExpressionParser,\n        ...DefaultComponents,\n        ...DefaultResources,\n        ...DefaultBindingSyntax,\n        ...DefaultBindingLanguage,\n        ...DefaultRenderers,\n      );\n    },\n    customize(cb?: ConfigurationOptionsProvider) {\n      return createConfiguration(cb ?? optionsProvider);\n    },\n  };\n}\n\nexport type ConfigurationOptionsProvider = (options: IRuntimeHtmlConfigurationOptions) => void;\ninterface IRuntimeHtmlConfigurationOptions {\n  coercingOptions: ICoercionConfiguration;\n}\n", "import { emptyArray, isString, type IContainer, type IServiceLocator, Key, IIndexable } from '@aurelia/kernel';\nimport { subscriberCollection , type ISubscriberCollection } from '@aurelia/runtime';\nimport { findElementControllerFor } from '../resources/custom-element';\nimport { ILifecycleHooks, lifecycleHooks } from './lifecycle-hooks';\nimport { def, objectAssign, safeString } from '../utilities';\nimport { instanceRegistration } from '../utilities-di';\nimport { type ICustomElementViewModel, type ICustomElementController } from './controller';\nimport { createMutationObserver } from '../utilities-dom';\n\nimport { ErrorNames, createMappedError } from '../errors';\nimport { getAnnotationKeyFor } from '../utilities-metadata';\nimport { IBinding } from '../binding/interfaces-bindings';\n\n/**\n * An interface describing options to observe the children elements of a custom element host\n */\nexport type PartialChildrenDefinition<TQuery extends string = string> = {\n  query?: TQuery;\n  callback?: PropertyKey;\n  name?: PropertyKey;\n  filter?: (node: TQuery extends '$all' ? Node : HTMLElement, viewModel: ICustomElementViewModel | null) => boolean;\n  map?: (node: TQuery extends '$all' ? Node : HTMLElement, viewModel: ICustomElementViewModel | null) => unknown;\n};\n\n/**\n * Decorator: Specifies custom behavior for an array children property that synchronizes its items with child content nodes of the element.\n *\n * @param config - The overrides\n */\nexport function children<TThis, TValue, TQuery extends string>(config?: PartialChildrenDefinition<TQuery>): (target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>) => void;\n/**\n * Decorator: Specifies an array property on a class that synchronizes its items with child content nodes of the element.\n *\n * @param selector - The CSS element selector for filtering children. Use `$all` to select everything including non element nodes.\n * If nothing is provided, it defaults to `*`, which means all elements\n */\nexport function children<TThis, TValue>(selector: string): (target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>) => void;\n/**\n * Decorator: Decorator: Specifies an array property that synchronizes its items with child content nodes of the element.\n *\n * @param target - The class\n * @param prop - The property name\n */\nexport function children<TThis, TValue>(target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>): void;\nexport function children<TThis, TValue, TQuery extends string>(configOrTarget?: PartialChildrenDefinition<TQuery> | string | undefined, context?: ClassFieldDecoratorContext<TThis,TValue>): void | ((target: undefined, context: ClassFieldDecoratorContext<TThis,TValue>) => void) {\n  if (!children.mixed) {\n    children.mixed = true;\n    subscriberCollection(ChildrenBinding, null!);\n    lifecycleHooks()(ChildrenLifecycleHooks, null!);\n  }\n  let config: PartialChildrenDefinition;\n\n  const dependenciesKey = getAnnotationKeyFor('dependencies');\n  function decorator(_target: undefined, context: ClassFieldDecoratorContext): void {\n    switch (context.kind) {\n      case 'field':\n        config.name = context.name;\n        break;\n    }\n\n    const dependencies = (context.metadata[dependenciesKey] ??= []) as Key[];\n    dependencies.push(new ChildrenLifecycleHooks(config as PartialChildrenDefinition & { name: PropertyKey } ?? {}));\n  }\n\n  if (arguments.length > 1) {\n    // Non invocation:\n    // - @children\n    config = {};\n    decorator(configOrTarget as undefined, context!);\n    return;\n  } else if (isString(configOrTarget)) {\n    // Direct call:\n    // - @children('div')(Foo)\n    config = {\n      query: configOrTarget,\n      // filter: (node: Node) => isElement(node) && node.matches(configOrTarget),\n      // map: el => el\n    };\n    return decorator;\n  }\n\n  // Invocation with or w/o opts:\n  // - @children()\n  // - @children({...opts})\n  config = configOrTarget === void 0 ? {} : configOrTarget;\n  return decorator;\n}\nchildren.mixed = false;\n\nexport interface ChildrenBinding extends ISubscriberCollection { }\n\n/**\n * A binding for observing & notifying the children of a custom element.\n */\nexport class ChildrenBinding implements IBinding {\n  /** @internal */\n  private readonly _callback: undefined | (() => void);\n  /** @internal */\n  private _children: unknown[] = (void 0)!;\n  /** @internal */\n  private readonly _observer: MutationObserver;\n  /** @internal */\n  private readonly _host: HTMLElement;\n  /** @internal */\n  private readonly _query: string;\n  /** @internal */\n  private readonly _filter?: (node: Node, viewModel: ICustomElementViewModel | null) => boolean;\n  /** @internal */\n  private readonly _map?: (node: Node, viewModel: ICustomElementViewModel | null) => unknown;\n\n  public isBound = false;\n  public readonly obj: ICustomElementViewModel;\n\n  public constructor(\n    host: HTMLElement,\n    obj: ICustomElementViewModel,\n    callback: undefined | (() => void),\n    query: string,\n    filter?: (node: Node, viewModel: ICustomElementViewModel | null) => boolean,\n    map?: (node: Node, viewModel: ICustomElementViewModel | null) => unknown,\n  ) {\n    this.obj = obj;\n    this._callback = callback;\n    this._query = query;\n    this._filter = filter;\n    this._map = map;\n    this._observer = createMutationObserver(this._host = host, () => {\n      this._onChildrenChanged();\n    });\n  }\n\n  public getValue(): unknown[] {\n    return this.isBound ? this._children : this._getNodes();\n  }\n\n  public setValue(_value: unknown): void { /* do nothing */ }\n\n  public bind(): void {\n    if (this.isBound) {\n      return;\n    }\n    this.isBound = true;\n    this._observer.observe(this._host, { childList: true });\n    this._children = this._getNodes();\n  }\n\n  public unbind(): void {\n    if (!this.isBound) {\n      return;\n    }\n    this.isBound = false;\n    // prevent memory leaks\n    this._observer.takeRecords();\n    this._observer.disconnect();\n    this._children = emptyArray;\n  }\n\n  /** @internal */\n  private _onChildrenChanged(): void {\n    this._children = this._getNodes();\n\n    this._callback?.call(this.obj);\n    this.subs.notify(this._children, undefined);\n  }\n\n  public get(): ReturnType<IServiceLocator['get']> {\n    throw createMappedError(ErrorNames.method_not_implemented, 'get');\n  }\n\n  /** @internal */\n  // freshly retrieve the children everytime\n  // in case this observer is not observing\n  private _getNodes() {\n    const query = this._query;\n    const filter = this._filter;\n    const map = this._map;\n    const nodes = query === '$all' ? this._host.childNodes : this._host.querySelectorAll(`:scope > ${query}`);\n    const ii = nodes.length;\n    const results: unknown[] = [];\n    const findControllerOptions = { optional: true };\n    let $controller: ICustomElementController | null;\n    let viewModel: ICustomElementViewModel | null;\n    let i = 0;\n    let node: Node;\n    while (ii > i) {\n      node = nodes[i];\n      $controller = findElementControllerFor(node, findControllerOptions);\n      viewModel = $controller?.viewModel ?? null;\n      if (filter == null ? true : filter(node, viewModel)) {\n        results.push(map == null ? viewModel ?? node : map(node, viewModel));\n      }\n      ++i;\n    }\n    return results;\n  }\n}\n\nclass ChildrenLifecycleHooks {\n  public constructor(\n    private readonly _def: PartialChildrenDefinition & { name: PropertyKey },\n  ) {}\n\n  public register(c: IContainer) {\n    instanceRegistration(ILifecycleHooks, this).register(c);\n  }\n\n  public hydrating(vm: IIndexable, controller: ICustomElementController) {\n    const $def = this._def;\n    const query = $def.query ?? '*';\n    const childrenObserver = new ChildrenBinding(\n      controller.host,\n      vm,\n      vm[$def.callback ?? `${safeString($def.name)}Changed`] as () => void,\n      query,\n      $def.filter as PartialChildrenDefinition<'$all'>['filter'],\n      $def.map as PartialChildrenDefinition<'$all'>['map'],\n    );\n    if (/[\\s>]/.test(query)) {\n      throw createMappedError(ErrorNames.children_invalid_query, query);\n    }\n    def(vm, $def.name, {\n      enumerable: true,\n      configurable: true,\n      get: objectAssign((/* ChildrenBinding */) => childrenObserver.getValue(), { getObserver: () => childrenObserver }),\n      set: (/* ChildrenBinding */) => {\n        if (__DEV__) {\n          // eslint-disable-next-line no-console\n          console.warn(`[DEV:aurelia] property ${safeString($def.name)} decorated with @children is readonly`);\n        }\n      },\n    });\n    controller.addBinding(childrenObserver);\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/ban-ts-comment */\nfunction testChildrenDecorator() {\n  class MyEl {\n    @children({\n      filter: (element) => element.getAttribute('hey') == null,\n      map: el => el.style\n    })\n    @children({\n      map: node => node.style\n    })\n    @children({\n      query: '$all',\n      // @ts-expect-error\n      map: node => node.style\n    })\n    public nodes: unknown[] = [];\n  }\n}\n", "import { DI, IContainer, Registration } from '@aurelia/kernel';\nimport { StandardConfiguration, Aurelia as $Aurelia, IPlatform, CustomElementType, CustomElement, ICustomElementViewModel } from '@aurelia/runtime-html';\nimport { BrowserPlatform } from '@aurelia/platform-browser';\nimport type { ISinglePageAppConfig, IEnhancementConfig } from '@aurelia/runtime-html';\n\nexport const PLATFORM = BrowserPlatform.getOrCreate(globalThis);\nexport { IPlatform };\n\nfunction createContainer(): IContainer {\n  return DI.createContainer()\n    .register(\n      Registration.instance(IPlatform, PLATFORM),\n      StandardConfiguration,\n    );\n}\n\nexport class Aurelia extends $Aurelia {\n  public constructor(container: IContainer = createContainer()) {\n    super(container);\n  }\n\n  public static app(config: ISinglePageAppConfig | CustomElementType): Omit<Aurelia, 'register' | 'app' | 'enhance'> {\n    return new Aurelia().app(config);\n  }\n\n  public static enhance<T extends ICustomElementViewModel>(config: IEnhancementConfig<T>): ReturnType<$Aurelia['enhance']> {\n    return new Aurelia().enhance(config);\n  }\n\n  public static register(...params: readonly unknown[]): Aurelia {\n    return new Aurelia().register(...params);\n  }\n\n  public app(config: ISinglePageAppConfig | CustomElementType): Omit<this, 'register' | 'app' | 'enhance'> {\n    if (CustomElement.isType(config)) {\n      // Default to custom element element name\n      const definition = CustomElement.getDefinition(config);\n      let host = document.querySelector(definition.name);\n      if (host === null) {\n        // When no target is found, default to body.\n        // For example, when user forgot to write <my-app></my-app> in html.\n        host = document.body;\n      }\n      return super.app({\n        host: host as HTMLElement,\n        component: config\n      });\n    }\n\n    return super.app(config);\n  }\n}\n\nexport default Aurelia;\n\nexport {\n  type ITask,\n  Platform,\n  type QueueTaskOptions,\n  Task,\n  TaskAbortError,\n  TaskQueue,\n  type TaskStatus\n} from '@aurelia/platform';\n\nexport {\n  all,\n  DI,\n  IContainer,\n  type IFactory,\n  inject,\n  resolve,\n  type IRegistration,\n  type IRegistry,\n  type IResolver,\n  IServiceLocator,\n  type Key,\n  lazy,\n  factory,\n  newInstanceOf,\n  newInstanceForScope,\n  optional,\n  resource,\n  allResources,\n  ignore,\n  Registration,\n  singleton,\n  transient,\n  // Injectable,\n  // InterfaceSymbol,\n  InstanceProvider,\n  type Resolved,\n  // Transformer,\n\n  type Class,\n  type Constructable,\n  type ConstructableClass,\n  // Diff,\n  type IDisposable,\n  // IFrameRequestCallback,\n  type IIndexable,\n  // IPerformance,\n  // ITimerHandler,\n  // IWindowOrWorkerGlobalScope,\n  // KnownKeys,\n  // NoInfer,\n  // Omit,\n  // OptionalKnownKeys,\n  // OptionalValuesOf,\n  // Overwrite,\n  // Param0,\n  // Param1,\n  // Param2,\n  // Param3,\n  // Pick2,\n  // Pick3,\n  // Primitive,\n  // Public,\n  // Purify,\n  // RequiredKnownKeys,\n  // RequiredValuesOf,\n  // StrictPrimitive,\n  // Unwrap,\n  // ValuesOf,\n  // Writable,\n  // IfEquals,\n  // ReadonlyKeys,\n  // WritableKeys,\n\n  // IConsoleLike,\n  type ColorOptions,\n  // ILogConfig,\n  // ILogEvent,\n  // ILogEventFactory,\n  // ISink,\n  ILogger,\n  // LogConfig,\n  // DefaultLogEvent,\n  // DefaultLogEventFactory,\n  // DefaultLogger,\n  ConsoleSink,\n  LoggerConfiguration,\n\n  // relativeToFile,\n  // join,\n  // parseQueryString,\n  // IQueryParams,\n\n  emptyArray,\n  emptyObject,\n  noop,\n\n  // ITraceInfo,\n  // ITraceWriter,\n  // ILiveLoggingOptions,\n  LogLevel,\n\n  // IResourceDefinition,\n  // IResourceDescriptions,\n  // IResourceKind,\n  // IResourceType,\n  // ResourceDescription,\n  // ResourcePartDescription,\n  // fromAnnotationOrDefinitionOrTypeOrDefault,\n  // fromAnnotationOrTypeOrDefault,\n  // fromDefinitionOrDefault,\n\n  EventAggregator,\n  IEventAggregator,\n\n  isArrayIndex,\n  camelCase,\n  kebabCase,\n  pascalCase,\n  toArray,\n  bound,\n  // mergeArrays,\n  // firstDefined,\n  // getPrototypeChain,\n} from '@aurelia/kernel';\n\nexport {\n  IExpressionParser,\n  CustomExpression,\n} from '@aurelia/expression-parser';\n\nexport {\n  type CollectionKind,\n  batch,\n  // connects,\n  // observes,\n  // callsFunction,\n  // hasAncestor,\n  // isAssignable,\n  // isLeftHandSide,\n  // isPrimary,\n  // isResource,\n  // hasBind,\n  // hasUnbind,\n  // isLiteral,\n  // arePureLiterals,\n  // isPureLiteral,\n\n  // IsResource,\n  // HasBind,\n  // HasUnbind,\n  // HasAncestor,\n\n  // IObserverLocatorBasedConnectable,\n  // IConnectableBinding,\n  // connectable,\n\n  // ArrayObserver,\n  // disableArrayObservation,\n\n  // MapObserver,\n  // enableMapObservation,\n  // disableMapObservation,\n\n  // SetObserver,\n  // enableSetObservation,\n  // disableSetObservation,\n\n  // BindingContext,\n  // OverrideContext,\n\n  // CollectionLengthObserver,\n\n  // CollectionSizeObserver,\n\n  // IDirtyChecker,\n  // DirtyCheckProperty,\n  // DirtyCheckSettings,\n\n  ComputedObserver,\n\n  IObservation,\n  // IObjectObservationAdapter,\n  IObserverLocator,\n  // ITargetObserverLocator,\n  // ITargetAccessorLocator,\n  // getCollectionObserver,\n  // ObserverLocator,\n\n  // PrimitiveObserver,\n\n  // PropertyAccessor,\n\n  // SetterObserver,\n\n  subscriberCollection,\n\n  // SignalableBinding,\n  // SignalBindingBehavior,\n\n  // ObserveShallow,\n  // ISanitizer,\n  // SanitizeValueConverter,\n\n  // ViewValueConverter,\n\n  observable,\n\n  // DefaultResources as RuntimeDefaultResources,\n  // RuntimeConfiguration,\n\n  // ExpressionKind,\n  // Hooks,\n  // State,\n\n  // CallBindingInstruction,\n  // HydrateAttributeInstruction,\n  // HydrateElementInstruction,\n  // HydrateTemplateController,\n  // InterpolationInstruction,\n  // IteratorBindingInstruction,\n  // LetBindingInstruction,\n  // HydrateLetElementInstruction,\n  // RefBindingInstruction,\n  // SetPropertyInstruction,\n\n  // ViewModelKind,\n  // IBinding,\n  // IViewModel,\n  // IController,\n  // IContainer,\n  // IViewCache,\n  // MountStrategy,\n\n  // AccessorOrObserver,\n  // Collection,\n  // CollectionKind,\n  // DelegationStrategy,\n  // IAccessor,\n  // IBindingContext,\n  // ICollectionChangeTracker,\n  // ICollectionSubscriber,\n\n  type IndexMap,\n  Scope,\n\n} from '@aurelia/runtime';\n\nexport {\n  attributePattern,\n  AttributePattern,\n  IAttrMapper,\n  IAttributeParser,\n  IAttributePattern,\n\n  bindingCommand,\n  BindingCommand,\n  type BindingCommandInstance,\n\n  ITemplateCompiler,\n  ITemplateElementFactory,\n  ITemplateCompilerHooks,\n  TemplateCompilerHooks,\n  templateCompilerHooks,\n\n  type BindingCommandStaticAuDefinition,\n\n} from '@aurelia/template-compiler';\n\nexport {\n  // BindingBehaviorDefinition,\n  // PartialBindingBehaviorDefinition,\n  // BindingBehaviorKind,\n  // BindingBehaviorDecorator,\n  // BindingBehaviorType,\n  type BindingBehaviorInstance,\n\n  // ValueConverterDefinition,\n  // PartialValueConverterDefinition,\n  // ValueConverterKind,\n  // ValueConverterDecorator,\n  // ValueConverterType,\n  type ValueConverterInstance,\n\n  // BindingModeBehavior,\n  // OneTimeBindingBehavior,\n  // ToViewBindingBehavior,\n  // FromViewBindingBehavior,\n  // TwoWayBindingBehavior,\n\n  // DebounceBindingBehavior,\n\n  // SignalableBinding,\n  // SignalBindingBehavior,\n\n  // ThrottleBindingBehavior,\n\n  customAttribute,\n  CustomAttribute,\n  // CustomAttributeDefinition\n  // CustomAttributeKind,\n  // CustomAttributeType,\n  // PartialCustomAttributeDefinition,\n  templateController,\n\n  // ObserveShallow,\n\n  // If,\n  // Else,\n\n  // Repeat,\n  IRepeatableHandlerResolver,\n  IRepeatableHandler,\n  ArrayLikeHandler,\n\n  // Replaceable,\n\n  // With,\n\n  containerless,\n  customElement,\n  CustomElement,\n  capture,\n  // CustomElementDecorator,\n  // CustomElementKind,\n  // CustomElementType,\n  // CustomElementDefinition,\n  // PartialCustomElementDefinition,\n  // IElementProjector,\n  // IProjectorLocator,\n  useShadowDOM,\n\n  // ISanitizer,\n  // SanitizeValueConverter,\n\n  // ViewValueConverter,\n\n  AppTask,\n  // TaskStatus,\n  // QueueTaskTargetOptions,\n\n  BindingMode,\n\n  bindable,\n  type PartialBindableDefinition,\n  // BindableDefinition,\n  Bindable,\n  coercer,\n\n  type PartialChildrenDefinition,\n  // Children,\n  children,\n\n  // These exports are temporary until we have a proper way to unit test them\n  Controller,\n\n  ViewFactory,\n  // IViewLocator,\n  // ViewLocator,\n  // view,\n  // Views,\n\n  // Aurelia, // Replaced by quick-start wrapper\n  // IDOMInitializer,\n  type ISinglePageAppConfig,\n  IAppRoot,\n\n  // DefaultResources as RuntimeDefaultResources,\n  // RuntimeConfiguration,\n\n  // AttributeInstruction,\n  // ICallBindingInstruction,\n  // IHydrateAttributeInstruction,\n  // IHydrateElementInstruction,\n  // IHydrateLetElementInstruction,\n  // IHydrateTemplateController,\n  // IInterpolationInstruction,\n  // IIteratorBindingInstruction,\n  // ILetBindingInstruction,\n  // IInstructionRow,\n  // IPropertyBindingInstruction,\n  // IRefBindingInstruction,\n  // ISetPropertyInstruction,\n  // isInstruction,\n  // IInstruction,\n  // NodeInstruction,\n  // IInstruction,\n  // InstructionType,\n  // PartialCustomElementDefinitionParts,\n\n  // DOM, should expose the one exported in runtime-html\n  INode,\n  IEventTarget,\n  IRenderLocation,\n\n  // ViewModelKind,\n  // IBinding,\n  // IViewModel,\n  type ICustomAttributeViewModel,\n  type ICustomElementViewModel,\n  IController,\n  // IContainer,\n  // IViewCache,\n  IViewFactory,\n  // MountStrategy,\n\n  // AccessorOrObserver,\n  // Collection,\n  // CollectionKind,\n  // DelegationStrategy,\n  // IAccessor,\n  // IBindingContext,\n  // ICollectionChangeTracker,\n  // ICollectionSubscriber,\n\n  IFlushQueue,\n  FlushQueue,\n  type IFlushable,\n\n  renderer,\n\n  // DefaultBindingLanguage as JitDefaultBindingLanguage,\n\n  // JitConfiguration,\n\n  // Access,\n  // Precedence,\n  // These exports are temporary until we have a proper way to unit test them\n\n  // parseExpression,\n\n  // BindableInfo,\n  // ElementInfo,\n  // AttrInfo,\n\n  // AnySymbol,\n  // BindingSymbol,\n  // CustomAttributeSymbol,\n  // CustomElementSymbol,\n  // ElementSymbol,\n  // LetElementSymbol,\n  // NodeSymbol,\n  // ParentNodeSymbol,\n  // PlainAttributeSymbol,\n  // PlainElementSymbol,\n  // ReplacePartSymbol,\n  // ResourceAttributeSymbol,\n  // SymbolFlags,\n  // SymbolWithBindings,\n  // SymbolWithMarker,\n  // SymbolWithTemplate,\n  // TemplateControllerSymbol,\n  // TextSymbol\n\n  IAurelia,\n  // Listener,\n\n  // AttributeBinding,\n\n  // AttributeNSAccessor,\n\n  // IInputElement,\n  // CheckedObserver,\n\n  // ClassAttributeAccessor,\n\n  // DataAttributeAccessor,\n\n  // EventSubscriber,\n  // EventDelegator,\n\n  NodeObserverLocator,\n\n  // TargetAccessorLocator,\n  // TargetObserverLocator,\n\n  // ISelectElement,\n  // IOptionElement,\n  // SelectValueObserver,\n\n  // StyleAttributeAccessor,\n\n  // ISVGAnalyzer,\n\n  // ValueAttributeObserver,\n\n  // AttrBindingBehavior,\n\n  // SelfBindingBehavior,\n\n  // UpdateTriggerBindingBehavior,\n\n  // Focus,\n\n  // Portal,\n  // PortalTarget,\n  // PortalLifecycleCallback,\n\n  // Subject,\n  // Compose,\n  type IAuSlot,\n  IAuSlotsInfo,\n  AuSlotsInfo,\n  IAuSlotWatcher,\n  slotted,\n\n  // DefaultComponents as RuntimeHtmlDefaultComponents,\n\n  // CompiledTemplate,\n  ChildrenBinding,\n  // IRenderer,\n  // IRenderingEngine,\n  // ITemplate,\n\n  RuntimeTemplateCompilerImplementation,\n\n  // RenderContext\n\n  // AttrSyntax,\n\n  // IAttributeParser,\n\n  // AtPrefixedTriggerAttributePattern,\n  // ColonPrefixedBindAttributePattern,\n  // DotSeparatedAttributePattern,\n  // RefAttributePattern,\n\n  alias,\n  registerAliases,\n\n  bindingBehavior,\n  BindingBehavior,\n\n  valueConverter,\n  ValueConverter,\n\n  // BindingCommandDefinition,\n  // BindingCommandKind,\n  // BindingCommandType,\n\n  // CallBindingCommand,\n  // DefaultBindingCommand,\n  // ForBindingCommand,\n  // FromViewBindingCommand,\n  // OneTimeBindingCommand,\n  // ToViewBindingCommand,\n  // TwoWayBindingCommand,\n\n  type IEnhancementConfig,\n  type IHydratedParentController,\n\n  // DefaultComponents as JitDefaultComponents,\n\n  // DefaultBindingSyntax,\n\n  ShortHandBindingSyntax,\n\n  // DefaultResources as RuntimeHtmlDefaultResources,\n\n  // DefaultRenderers,\n\n  // StandardConfiguration,\n\n  // AttributeInstruction,\n  // IInstructionRow,\n  // NodeInstruction,\n  // IInstruction,\n  // InstructionType,\n  // IAttributeBindingInstruction,\n  // ISetAttributeInstruction,\n  // isInstruction,\n\n  // NodeSequenceFactory,\n  // FragmentNodeSequence,\n\n  // AttributeBindingInstruction,\n  // SetAttributeInstruction,\n  // SetClassAttributeInstruction,\n  // SetStyleAttributeInstruction,\n  // StylePropertyBindingInstruction,\n\n  // ContainerlessProjector,\n  // HostProjector,\n  // HTMLProjectorLocator,\n  // ShadowDOMProjector,\n\n  StyleConfiguration,\n  // styles,\n  type IShadowDOMConfiguration,\n\n  // CSSModulesProcessorRegistry,\n  cssModules,\n\n  // ShadowDOMRegistry,\n  // IShadowDOMStyleFactory,\n  shadowCSS,\n  processContent,\n\n  // AdoptedStyleSheetsStyles,\n  // StyleElementStyles,\n  // IShadowDOMStyles,\n  // IShadowDOMGlobalStyles\n\n  // StandardConfiguration,\n\n  ILifecycleHooks,\n  type LifecycleHook,\n  LifecycleHooks,\n  lifecycleHooks,\n\n  watch,\n\n  IKeyMapping,\n  IModifiedEventHandlerCreator,\n  IEventModifier,\n  type IModifiedEventHandler,\n\n  ISignaler,\n\n  IWindow,\n  IHistory,\n\n  refs,\n} from '@aurelia/runtime-html';\n"],
  "mappings": "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",
  "names": ["nextChar", "lookup", "def", "factory", "inject", "key", "Resolver", "factory", "error", "factory", "_a", "isRegistry", "optional", "safeString", "createLookup", "createMappedError", "safeString", "getMessageByCode", "errorsMap", "createLookup", "id", "DAE", "DASE", "optional", "_optional", "createMappedError", "createLookup", "lookup", "IdParts", "CharScanners", "singletonRegistration", "etInterpolation", "etIsFunction", "etIsProperty", "createMappedError", "getMessageByCode", "errorsMap", "isSymbol", "def", "getMetadata", "defineMetadata", "containerless", "alias", "capture", "def", "singletonRegistration", "alias", "createMappedError", "getMetadata", "getDefinitionFromStaticAu", "defineMetadata", "info", "etIsProperty", "bindable", "etIsFunction", "children", "id", "createMappedError", "bindable", "bindingCommand", "etInterpolation", "etIsProperty", "capture", "bindables", "def", "singletonRegistration", "context", "createMappedError", "getMessageByCode", "errorsMap", "ekAccessThis", "ekAccessBoundary", "ekAccessGlobal", "ekAccessScope", "ekArrayLiteral", "ekObjectLiteral", "ekPrimitiveLiteral", "ekNew", "ekTemplate", "ekUnary", "ekCallScope", "ekCallMember", "ekCallFunction", "ekCallGlobal", "ekAccessMember", "ekAccessKeyed", "ekTaggedTemplate", "ekBinary", "ekConditional", "ekAssign", "ekArrowFunction", "ekValueConverter", "ekBindingBehavior", "ekArrayBindingPattern", "ekObjectBindingPattern", "ekBindingIdentifier", "ekForOfStatement", "ekInterpolation", "ekArrayDestructuring", "ekObjectDestructuring", "ekDestructuringAssignmentLeaf", "ekCustom", "astEvaluate", "safeString", "astAssign", "astBind", "astUnbind", "resolve", "error", "resolve", "subscriberCollection", "createMappedError", "getArrayObserver", "getSetObserver", "getMapObserver", "observeCollection", "connectableDecorator", "connectable", "coercer", "createMappedError", "coercer", "lookup", "observable", "context", "tsPending", "tsRunning", "tsCompleted", "tsCanceled", "Task", "TaskAbortError", "resolve", "console", "info", "id", "queue", "notImplemented", "getMetadata", "defineMetadata", "annotation", "getAnnotationKeyFor", "safeString", "objectFreeze", "objectAssign", "etInterpolation", "etIsIterator", "etIsFunction", "etIsProperty", "tsPending", "tsRunning", "atObserver", "atNode", "atLayout", "createMappedError", "getMessageByCode", "errorsMap", "getBindingCommandHelp", "context", "bindables", "isArray", "def", "bindable", "coercer", "createInterface", "singletonRegistration", "aliasRegistration", "instanceRegistration", "resource", "alias", "bindingHandlerMap", "defaultDelay", "IPlatform", "$IPlatform", "containerLookup", "lookup", "target", "dispose", "mixed", "capture", "insertManyBefore", "isElement", "defaultSlotName", "auslotAttr", "classes", "SetPropertyRenderer", "CustomElementRenderer", "containerless", "CustomAttributeRenderer", "TemplateControllerRenderer", "LetElementRenderer", "RefBindingRenderer", "InterpolationBindingRenderer", "PropertyBindingRenderer", "IteratorBindingRenderer", "TextBindingRenderer", "error", "ListenerBindingRenderer", "SetAttributeRenderer", "SetClassAttributeRenderer", "SetStyleAttributeRenderer", "StylePropertyBindingRenderer", "AttributeBindingRenderer", "SpreadRenderer", "SpreadValueRenderer", "factory", "all", "container", "wrap", "unwrap", "none", "resolve", "children", "none", "objectFreeze", "createInterface", "IPlatform", "context", "def", "getMetadata", "capture", "bindables", "containerless", "processContent", "createMappedError", "name", "generateElementName", "bindable", "defineMetadata", "singletonRegistration", "aliasRegistration", "alias", "id", "getAnnotationKeyFor", "cur", "objectAssign", "instanceRegistration", "dispose", "createError", "createMappedError", "bindables", "def", "info", "bindable", "atNode", "atLayout", "atObserver", "option", "oV", "objectAssign", "IPlatform", "lookup", "key", "getCollectionObserver", "children", "etIsProperty", "$index", "$length", "createInterface", "singletonRegistration", "safeString", "tsRunning", "error", "_a", "_b", "_c", "factory", "activating", "activated", "deactivating", "deactivated", "insertManyBefore", "defaultSlotName", "isElement", "auslotAttr", "capture", "model", "id", "instanceRegistration", "getAnnotationKeyFor", "context", "createContainer", "IPlatform", "Aurelia", "$Aurelia"]
}
